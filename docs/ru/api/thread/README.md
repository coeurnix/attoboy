# Thread

## Обзор

Класс `attoboy::Thread` предоставляет лёгкую оболочку над потоком операционной системы (ОС). Он позволяет:

* Запустить новый поток выполнения.
* Ожидать завершения потока и получить его результат.
* Проверить, выполняется ли поток.
* Принудительно завершить поток (только в крайнем случае).
* Безопасно разделять и сравнивать дескрипторы потоков.

Цель — предоставить простой, минимальный API, покрывающий самые распространённые задачи по работе с потоками, без зависимости от стандартной библиотеки C++ или сложных фреймворков конкурентности.

### Что такое Thread?

**Поток** — это независимый путь выполнения внутри процесса. Можно представить процесс как запущенную программу, а потоки — как отдельных «работников» внутри этой программы, которые могут выполняться параллельно:

* **Однопоточная** программа выполняет всю работу в одной последовательности инструкций.
* **Многопоточная** программа может выполнять несколько последовательностей одновременно, часто на нескольких ядрах процессора.

Типичные причины использования потоков:

* Выполнять медленные или блокирующие операции (например, сетевые запросы, ввод/вывод в файлы) в фоновом режиме.
* Выполнять вычислительно тяжёлую работу параллельно.
* Поддерживать отзывчивость пользовательского интерфейса во время фоновой работы.

Однако потоки добавляют сложности:

* **Разделяемое состояние** должно быть защищено (например, с помощью `Mutex`), чтобы избежать гонок данных.
* **Управление временем жизни** должно быть тщательным, чтобы потоки не оставались выполняться неожиданно.

### Функции потока и сигнатура `void *(*func)(void *)`

`Thread` начинает выполнение функции-указателя, которая соответствует следующей сигнатуре:

```cpp
void *(*func)(void *)
```

Это означает:

* Функция входа потока принимает один аргумент типа `void *`.
* Она возвращает `void *` в качестве результата.

Внутри функции обычно:

1. Приводят аргумент `void *` обратно к конкретному типу указателя (например, `String *`, небольшая структура или `nullptr`, если данные не требуются).
2. Выполняют работу.
3. Возвращают указатель-результат (часто `nullptr`, если результат не нужен).

Тот же указатель, который вы возвращаете, позже будет передан вызывающему при вызове `await()`.

### Время жизни потока и разделение дескриптора

Объект `Thread` сам по себе является **дескриптором** для лежащего под ним потока ОС. Важные моменты:

* **Конструктор создаёт и запускает** поток немедленно.
* **Деструктор «удаляет дескриптор», но не завершает поток**; соответствующий поток ОС может продолжать выполняться.
* **Конструктор копирования и оператор присваивания «делятся подлежащим потоком»**, то есть несколько объектов `Thread` могут ссылаться на один и тот же выполняющийся поток.
* Обычно вы вызываете **`await()`** на одном из дескрипторов, чтобы ждать завершения потока и получить его результат.

Такой дизайн поощряет следующий рабочий процесс:

* Запустить работу с помощью `Thread`.
* Хранить(ся) дескриптор(ы), пока нужен контроль.
* Вызвать `await()`, когда нужно убедиться, что поток завершён.
* Не полагаться на разрушение объекта для завершения или синхронизации.

---

## Справочник

Каждый пункт ниже описывает один публичный конструктор, метод или оператор `attoboy::Thread`. Для каждого приведено:

* **Сигнатура** — точное объявление из заголовочного файла.
* **Кратко** — исходный однострочный комментарий Doxygen.
* Описания **параметров** и **возвращаемого значения**.
* **Подробно** — дополнительные детали, оговорки и короткий пример.

> **Примечание:** Во всех примерах предполагается `using namespace attoboy;`.

---

#### `Thread(void *(*func)(void *), void *arg = nullptr)`

**Сигнатура**

```cpp
Thread(void *(*func)(void *), void *arg = nullptr);
```

**Кратко**
Создаёт и запускает поток, выполняющий указанную функцию.

**Параметры**

* `func` – указатель на функцию входа потока с сигнатурой `void *worker(void *arg)`.
* `arg` – необязательный указатель, передаваемый как аргумент в `func`. По умолчанию `nullptr`.

**Возвращаемое значение**

* *(конструктор; не применяется)*

**Подробно**

Этот конструктор одновременно **создаёт** и **запускает** новый поток. Как только объект `Thread` создан, соответствующий поток ОС начинает выполнять `func(arg)`.

Ключевые моменты:

* Функция входа потока должна быть свободной функцией или статической функцией-членом и соответствовать требуемой сигнатуре.
* Указатель `arg` передаётся без изменений; вы несёте ответственность за приведение типов и управление временем жизни данных, на которые он указывает.
* Функция возвращает `void *`, который позже доступен через `await()`.

Поскольку поток стартует немедленно, отдельного вызова «start» не требуется. Обычно вы:

1. Подготавливаете любые данные, необходимые потоку.
2. Конструируете `Thread`.
3. Продолжаете другую работу или в конце вызываете `await()`.

**Пример**

```cpp
// Simple worker function that sleeps and returns a message pointer.
void *worker(void *arg) {
  String *label = (String *)arg;
  Sleep(1000);  // 1 second of simulated work
  return label; // return the same pointer back to the caller
}

// Usage:
String *msg = new String("done");
Thread t(&worker, msg);
```

*Этот пример запускает поток, который засыпает на секунду, а затем возвращает указатель на результат типа `String`.*

---

#### `Thread(const Thread &other)`

**Сигнатура**

```cpp
Thread(const Thread &other);
```

**Кратко**
Создаёт копию (делится подлежащим потоком).

**Параметры**

* `other` – существующий дескриптор `Thread` для копирования.

**Возвращаемое значение**

* *(конструктор; не применяется)*

**Подробно**

Конструктор копирования создаёт новый объект `Thread`, который **ссылается на тот же подлежащий поток**, что и `other`. Новый поток ОС не создаётся.

Это полезно, когда:

* Вы хотите передать дескриптор потока другой функции или компоненту.
* Вам нужны несколько объектов, которые все могут вызывать `await()`, `isRunning()` или `cancel()` для одного и того же потока.

Разделение касается только управления дескриптором; сама выполняемая работа не дублируется.

**Пример**

```cpp
void *worker(void *arg) {
  Sleep(500);
  return nullptr;
}

Thread original(&worker, nullptr);
Thread copy(original);  // shares the same underlying thread
```

*В этом примере создаётся второй дескриптор к тому же выполняющемуся потоку.*

---

#### `~Thread()`

**Сигнатура**

```cpp
~Thread();
```

**Кратко**
Разрушает дескриптор (не завершает поток).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; не применяется)*

**Подробно**

Деструктор освобождает ресурсы, связанные с дескриптором потока, но **не останавливает сам поток ОС**. Если поток всё ещё выполняется, он продолжит работать даже после уничтожения всех объектов `Thread`, ссылающихся на него.

Это имеет важные последствия:

* Не полагайтесь на разрушение объекта для объединения (join) или отмены потока.
* Если нужно дождаться завершения потока, вызовите `await()`.
* Если необходимо принудительно завершить поток, вызовите `cancel()` (с осторожностью).

На практике обычно держат по крайней мере один объект `Thread` живым, пока поток не перестанет быть нужен, и управляют завершением явно.

**Пример**

```cpp
void *worker(void *arg) {
  Sleep(1000);
  return nullptr;
}

{
  Thread t(&worker, nullptr);
  // t goes out of scope here; the underlying thread may still be running.
}
// The OS thread continues until it finishes on its own.
```

*Этот пример показывает, что уничтожение дескриптора `Thread` не останавливает поток автоматически.*

---

#### `Thread &operator=(const Thread &other)`

**Сигнатура**

```cpp
Thread &operator=(const Thread &other);
```

**Кратко**
Присваивает другой поток (делится подлежащим потоком).

**Параметры**

* `other` – существующий дескриптор `Thread` для присваивания.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочку присваиваний.

**Подробно**

Оператор присваивания копированием заставляет `*this` ссылаться на тот же подлежащий поток, что и `other`. Любая предыдущая ассоциация `*this` с другим дескриптором потока освобождается.

Как и конструктор копирования:

* Новый поток ОС не создаётся.
* Подлежащий поток не перезапускается и не дублируется; оба объекта являются просто дескрипторами к одному потоку.

**Пример**

```cpp
void *worker(void *arg) {
  Sleep(100);
  return nullptr;
}

Thread a(&worker, nullptr);
Thread b(&worker, nullptr);

b = a;  // now both a and b refer to the same thread created for a
```

*В этом примере один дескриптор `Thread` переназначается, чтобы разделять поток, управляемый другим.*

---

#### `void *await()`

**Сигнатура**

```cpp
void *await();
```

**Кратко**
Ожидает завершения потока и возвращает его результат.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Значение `void *`, возвращённое функцией входа потока, или нулевой указатель в случае ошибки (зависит от реализации).

**Подробно**

`await()` — основной вызов синхронизации для `Thread`:

* Он **блокирует вызывающего**, пока соответствующий поток не завершится.
* После завершения потока `await()` возвращает указатель, который функция потока вернула.
* Последующие вызовы `await()` на том же дескрипторе обычно допустимы, но могут вернуть тот же указатель или вести себя по-разному; лучшая практика — вызывать `await()` ровно один раз для логической «сборки».

Вы несёте ответственность за:

* Правильную интерпретацию возвращённого указателя (приведение к нужному типу).
* Управление временем жизни любых динамически выделенных объектов, на которые он указывает.

**Пример**

```cpp
void *worker(void *arg) {
  String *label = (String *)arg;
  // Do some work...
  return label;
}

// Start the thread
String *msg = new String("done");
Thread t(&worker, msg);

// Wait for completion and retrieve result
void *resultPtr = t.await();
String *result = (String *)resultPtr;
// result now points to "done"
```

*В этом примере ожидают завершения потока и получают указатель-результат, возвращённый рабочей функцией.*

---

#### `void cancel()`

**Сигнатура**

```cpp
void cancel();
```

**Кратко**
Принудительно завершает поток (использовать осторожно).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(нет)*

**Подробно**

`cancel()` пытается **принудительно остановить** соответствующий поток. Это следует рассматривать как **последний ресурс**:

* Это может помешать выполнению кода очистки в потоке.
* Это может оставить разделяемые данные в неконсистентном состоянии.
* Ресурсы, принадлежащие потоку (блокировки, дескрипторы файлов и т. п.), могут не освободиться корректно.

По возможности предпочитайте кооперативное завершение:

* Используйте разделяемые флаги (защищённые `Mutex`, если нужно), которые поток периодически проверяет.
* Позвольте потоку выйти из функции естественным образом.
* Затем вызовите `await()`, чтобы объединить его.

Используйте `cancel()` только когда других вариантов нет и вы полностью понимаете риски.

**Пример**

```cpp
void *worker(void *arg) {
  // Potentially long-running or blocking work...
  Sleep(10000);
  return nullptr;
}

Thread t(&worker, nullptr);

// In some error or shutdown condition:
t.cancel();  // force termination (use with care)
```

*В этом примере поток долго выполняется, и его отменяют в экстренной ситуации.*

---

#### `bool isRunning() const`

**Сигнатура**

```cpp
bool isRunning() const;
```

**Кратко**
Возвращает true, если поток всё ещё выполняется.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если соответствующий поток в данный момент выполняется; `false`, если он завершился или не был запущен.

**Подробно**

`isRunning()` предоставляет простой способ проверить состояние потока:

* Немедленно после создания обычно возвращает `true`, если поток успешно запустился.
* После того как функция потока вернула управление, `isRunning()` становится `false`.
* Поток, который никогда не запускался или не смог запуститься, также помечается как не выполняющийся.

Вы можете использовать это в циклах опроса или для принятия решений о том, безопасно ли отменять, ожидать или повторно использовать дескриптор (хотя всё равно следует быть осторожным из-за гонок между проверками и операциями).

**Пример**

```cpp
void *worker(void *arg) {
  Sleep(500);
  return nullptr;
}

Thread t(&worker, nullptr);

while (t.isRunning()) {
  // Do something else while we wait
  Sleep(50);
}

void *result = t.await();  // safe: thread is no longer running
```

*В этом примере опрашивают `isRunning()`, чтобы выполнять другую работу, пока поток завершается в фоне.*

---

#### `bool equals(const Thread &other) const`

**Сигнатура**

```cpp
bool equals(const Thread &other) const;
```

**Кратко**
Возвращает true, если этот дескриптор равен другому.

**Параметры**

* `other` – другой `Thread` для сравнения.

**Возвращаемое значение**

* `true`, если оба объекта ссылаются на один и тот же подлежащий поток; иначе `false`.

**Подробно**

`equals()` проверяет, представляют ли два дескриптора `Thread` один и тот же подлежащий поток ОС. Это проверка **идентичности**, а не состояния выполнения:

* Два дескриптора, созданные посредством копирования или присваивания, ссылаются на один и тот же поток и считаются равными.
* Два независимых потока, выполняющие одну и ту же функцию, не равны.

Используйте это, когда нужно убедиться, что два дескриптора являются алиасами одного и того же потока.

**Пример**

```cpp
void *worker(void *arg) {
  Sleep(100);
  return nullptr;
}

Thread a(&worker, nullptr);
Thread b(a);  // shares thread

bool same = a.equals(b);  // true
```

*В этом примере копия дескриптора считается равной оригиналу согласно `equals()`.*

---

#### `bool operator==(const Thread &other) const`

**Сигнатура**

```cpp
bool operator==(const Thread &other) const;
```

**Кратко**
Возвращает true, если этот дескриптор равен другому.

**Параметры**

* `other` – другой `Thread` для сравнения.

**Возвращаемое значение**

* `true`, если оба дескриптора представляют один и тот же подлежащий поток; иначе `false`.

**Подробно**

Этот оператор — идиоматический сокращённый вариант для `equals(other)`:

```cpp
if (a == b) { ... }
```

Он сравнивает идентичность потока, а не то, выполняются ли оба потока или имеют ли они одинаковое поведение.

**Пример**

```cpp
void *worker(void *arg) {
  return nullptr;
}

Thread a(&worker, nullptr);
Thread b(a);       // same underlying thread
Thread c(&worker, nullptr);  // different thread

bool ab = (a == b); // true
bool ac = (a == c); // false
```

*В этом примере оператор равенства используется для проверки того, представляют ли два дескриптора один и тот же поток.*

---

#### `bool operator!=(const Thread &other) const`

**Сигнатура**

```cpp
bool operator!=(const Thread &other) const;
```

**Кратко**
Возвращает true, если этот дескриптор не равен другому.

**Параметры**

* `other` – другой `Thread` для сравнения.

**Возвращаемое значение**

* `true`, если два дескриптора ссылаются на разные подлежащие потоки; `false`, если они ссылаются на один и тот же поток.

**Подробно**

Этот оператор просто логическое отрицание `operator==`. Часто читаемее прямо выражать неравенство через `!=`.

**Пример**

```cpp
void *worker(void *arg) {
  return nullptr;
}

Thread a(&worker, nullptr);
Thread b(&worker, nullptr);

if (a != b) {
  // a and b manage different OS threads
}
```

*В этом примере выполняется ветвление, когда два дескриптора потоков относятся к разным потокам.*