# Registry

## Обзор

Класс `attoboy::Registry` предоставляет простой интерфейс в стиле RAII для работы с **реестром Windows**. Он позволяет:

* Открывать существующий ключ реестра.
* Создавать или удалять ключ.
* Читать и записывать **строковые**, **целочисленные** и **двоичные** значения.
* Перечислять имена значений и дочерние ключи.

Все операции выполняются через один объект `Registry`, который владеет (или разделяет) дескриптор определённого ключа, например:

* `HKEY_CURRENT_USER\Software\MyApp`
* `HKEY_LOCAL_MACHINE\Software\Vendor\Product`

Класс спроектирован таким образом, что:

* **Конструкция** открывает или ссылается на путь ключа.
* **Деструктор** автоматически закрывает подлежащий дескриптор.
* **Копирование и присваивание** разделяют один и тот же подлежащий ключ (легкое совместное использование дескриптора).

Это упрощает взаимодействие с реестром без необходимости вручную управлять дескрипторами.

### Кратко о реестре Windows

Реестр Windows — иерархическая база данных, которую Windows и многие приложения используют для хранения конфигурационных данных. Основные понятия:

* **Корневые разделы (hives)** — верхнеуровневые корневые ключи, такие как:

  * `HKEY_CURRENT_USER` (настройки текущего пользователя)
  * `HKEY_LOCAL_MACHINE` (настройки на уровне машины)
* **Ключи** — аналогичны каталогам в файловой системе. Пример:
  `HKEY_CURRENT_USER\Software\MyApp`
* **Значения** — именованные записи под ключом, каждая имеет:

  * **имя** (строка, может быть пустой для **значения по умолчанию**).
  * **тип** (строка, целое, двоичное и т.д.).
  * Данные (собственно значение).

В `attoboy::Registry` ключи указываются с помощью **одной строковой очереди пути**, например:

```cpp
"HKEY_CURRENT_USER\\Software\\MyApp"
```

Обратите внимание на удвоенные обратные слеши (`\\`) в исходном коде, которые представляют собой литеральный `\`.

### Ключи реестра, значения и значение по умолчанию

В рамках данного ключа:

* Каждое именованное значение имеет уникальную **строку-имя**, например `"InstallPath"` или `"WindowWidth"`.
* Также может существовать **неназванное значение по умолчанию**. В `attoboy::Registry` вы ссылаетесь на это значение по умолчанию, передавая **пустое имя** (`String()`) или опуская параметр, если предоставлен аргумент по умолчанию.

Например:

* `valueExists()` без аргументов проверяет, существует ли значение по умолчанию.
* `valueExists("InstallPath")` проверяет именованное значение.

### RAII и совместное использование дескрипторов

Класс `Registry` следует идиоме RAII:

* Когда объект `Registry` создаётся, он открывает или ссылается на путь ключа реестра.
* Когда он уничтожается, он закрывает подлежащий дескриптор (если владеет им).

Копирование или присваивание объектов `Registry`:

* **не** дублирует ключ; вместо этого все копии **разделяют один и тот же подлежащий дескриптор**.
* Это эффективно и безопасно: дескриптор освобождается только когда последний `Registry`, ссылающийся на него, будет уничтожен.

Таким образом, вы можете передавать объекты `Registry` по значению, не беспокоясь о витках ресурсов или утечках.

---

## Справочник

Каждый пункт ниже описывает один публичный конструктор, метод или оператор `attoboy::Registry`. Для каждого вы найдёте:

* **Сигнатура** – точное объявление из заголовочного файла.
* **Краткое описание** – однострочный комментарий Doxygen.
* Описания **параметров** и **возвращаемого значения**.
* **Подробнее** – дополнительные сведения и замечания.
* **Пример** – краткий реалистичный фрагмент использования с коротким пояснением.

Все примеры предполагают:

```cpp
using namespace attoboy;
```

---

#### `Registry(const String &key)`

**Сигнатура**

```cpp
Registry(const String &key);
```

**Краткое описание**
Открывает ключ реестра (например, "HKEY_CURRENT_USER\Software\MyApp").

**Параметры**

* `key` – полный путь реестра для открытия, включая корневой раздел, например
  `"HKEY_CURRENT_USER\\Software\\MyApp"`.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Этот конструктор представляет конкретный путь ключа реестра. Внутренне он открывает (или готовится открыть) ключ реестра, соответствующий указанной строке. Примеры допустимых строк `key` включают:

* `HKEY_CURRENT_USER\\Software\\MyApp`
* `HKEY_LOCAL_MACHINE\\Software\\Vendor\\Product`

Типичные сценарии использования:

* Вызвать `exists()`, чтобы узнать, существует ли ключ.
* Вызвать `create()`, чтобы создать ключ, если он не существует.
* Использовать `setStringValue`, `setIntegerValue` и т.д., чтобы задать значения под ключом.

Обычно следует выбирать подклю́ч под `HKEY_CURRENT_USER` или `HKEY_LOCAL_MACHINE`, специфичный для вашего приложения (например, `"HKEY_CURRENT_USER\\Software\\MyCompany\\MyApp"`).

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

if (!reg.exists()) {
  reg.create();
}
```

*Этот пример открывает ключ в ветке текущего пользователя и создаёт его, если он ещё не существует.*

---

#### `Registry(const Registry &other)`

**Сигнатура**

```cpp
Registry(const Registry &other);
```

**Краткое описание**
Создаёт копию (разделяет подлежащий ключ).

**Параметры**

* `other` – существующий экземпляр `Registry` для копирования.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Конструктор копирования не создаёт новый ключ реестра. Вместо этого он заставляет новый объект разделять тот же подлежащий дескриптор, что и `other`. Это эффективно и безопасно:

* Вы можете передавать объекты `Registry` по значению.
* Все копии ссылаются на один и тот же ключ.
* Дескриптор освобождается только когда последний `Registry`, ссылающийся на него, будет уничтожен.

Любая операция, выполненная через одну из копий (чтение или запись значений), влияет на тот же подлежащий ключ.

**Пример**

```cpp
Registry base("HKEY_CURRENT_USER\\Software\\MyApp");
Registry copy(base);  // shares the same key
```

*Этот пример создаёт второй объект `Registry`, который ссылается на тот же подлежащий ключ реестра, что и первый.*

---

#### `~Registry()`

**Сигнатура**

```cpp
~Registry();
```

**Краткое описание**
Закрывает ключ и освобождает ресурсы.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробнее**

Деструктор закрывает подлежащий дескриптор ключа реестра, когда последний объект `Registry`, ссылающийся на него, уничтожается. Это поведение в духе RAII:

* Явная очистка не требуется.
* Нельзя случайно забыть закрыть ключ.

**Пример**

```cpp
{
  Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");
  // use reg here
} // reg is destroyed here; the key is closed automatically
```

*Этот пример показывает, что ключ автоматически закрывается при выходе объекта `Registry` из области видимости.*

---

#### `Registry &operator=(const Registry &other)`

**Сигнатура**

```cpp
Registry &operator=(const Registry &other);
```

**Краткое описание**
Присваивает другой реестр (разделяет подлежащий ключ).

**Параметры**

* `other` – `Registry`, чьим подлежащим дескриптором следует поделиться.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочку присваиваний.

**Подробнее**

Оператор присваивания:

1. Освобождает текущий дескриптор ключа, удерживаемый `*this` (если он есть).
2. Делает так, чтобы `*this` разделял тот же подлежащий дескриптор, что и `other`.

После присваивания оба объекта ссылаются на один и тот же ключ. Самоприсваивание безопасно; реализация защищает от некорректного двойного освобождения дескриптора.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");
Registry other("HKEY_CURRENT_USER\\Software\\OtherApp");

reg = other;  // reg now refers to the "OtherApp" key
```

*Этот пример переназначает объект `Registry`, чтобы он ссылался на другой ключ.*

---

#### `bool exists() const`

**Сигнатура**

```cpp
bool exists() const;
```

**Краткое описание**
Возвращает true, если ключ существует.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если указанный ключ реестра в данный момент существует; иначе `false`.

**Подробнее**

Используйте `exists()`, чтобы проверить, присутствует ли ключ, указанный в конструкторе, в реестре. Это обычно первый шаг перед чтением или записью значений.

Эта функция не создаёт ключ; она только проверяет его наличие.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

if (!reg.exists()) {
  // Key has not been created yet
}
```

*Этот пример проверяет, существует ли уже ключ, связанный с приложением.*

---

#### `bool create()`

**Сигнатура**

```cpp
bool create();
```

**Краткое описание**
Создаёт ключ, если он не существует. Возвращает true при успехе.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если к моменту возврата ключ существует (либо был создан, либо уже существовал).
* `false`, если создание не удалось (например, из‑за прав доступа).

**Подробнее**

`create()` гарантирует существование ключа реестра. Типичная семантика:

* Если ключ не существует, он создаётся.
* Если ключ уже существует, вызов всё равно считается успешным и не изменяет ключ.

Это позволяет писать код в стиле «обеспечить существование»:

1. Создать объект `Registry`.
2. Вызвать `create()` один раз.
3. Читать или записывать значения под ключом.

В зависимости от того, какой раздел и путь вы используете (пользовательский или системный), могут потребоваться соответствующие права.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

// Ensure that the key exists before writing values
if (reg.create()) {
  reg.setStringValue("InstallPath", "C:\\MyApp");
}
```

*Этот пример создаёт ключ при необходимости и затем записывает конфигурационное значение.*

---

#### `bool remove(bool isRecursive = true)`

**Сигнатура**

```cpp
bool remove(bool isRecursive = true);
```

**Краткое описание**
Удаляет ключ. Возвращает true при успехе.

**Параметры**

* `isRecursive` – Если `true`, пытается удалить ключ и все его дочерние ключи. Если `false`, обычно удаляет ключ только если он пуст (зависит от реализации).

**Возвращаемое значение**

* `true`, если ключ успешно удалён.
* `false`, если удаление не удалось (например, из‑за прав доступа или если ключ не пуст и `isRecursive` = `false`).

**Подробнее**

`remove()` удаляет ключ реестра, ассоциированный с этим объектом `Registry`. Используйте с осторожностью:

* Предпочтительно удалять только те ключи, которые создало ваше приложение.
* Избегайте удаления системных или сторонних ключей.
* Если `isRecursive` установлен в `true` (по умолчанию), удаляются также все дочерние ключи и значения — удобно при деинсталляции приложения.

После успешного вызова `remove()` ключ больше не будет присутствовать в реестре. Сам объект `Registry` остаётся валидным, но вызовы вроде `exists()` будут возвращать `false`.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

// Remove this key and all its subkeys/values
bool ok = reg.remove(true);
```

*Этот пример рекурсивно удаляет ключ приложения и может использоваться в процессе удаления программы.*

---

#### `bool valueExists(const String &name = String()) const`

**Сигнатура**

```cpp
bool valueExists(const String &name = String()) const;
```

**Краткое описание**
Возвращает true, если значение существует (пустое имя = значение по умолчанию).

**Параметры**

* `name` – Имя значения для проверки. Когда `name` — пустой `String()` (по умолчанию), это относится к **значению по умолчанию (без имени)** ключа.

**Возвращаемое значение**

* `true`, если указанное значение существует под этим ключом.
* `false` в противном случае.

**Подробнее**

Перед чтением значения вы можете использовать `valueExists()`, чтобы определить, определено ли оно:

* Это особенно полезно для `getIntegerValue()`, который возвращает `0` как для «не найдено», так и для реального целого `0`.
* Для строковых и двоичных значений вы также можете проверить возвращаемый указатель от `get*Value()` функций, но `valueExists()` обеспечивает более явное намерение.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

if (reg.valueExists("WindowWidth")) {
  unsigned int width = reg.getIntegerValue("WindowWidth");
}
```

*Этот пример проверяет, присутствует ли конкретное целочисленное значение перед его чтением.*

---

#### `String getStringValue(const String &name = String()) const`

**Сигнатура**

```cpp
String getStringValue(const String &name = String()) const;
```

**Краткое описание**
Возвращает строковое значение, или пустую строку, если не найдено.

**Параметры**

* `name` – Имя значения для чтения. Пустой `String()` (по умолчанию) относится к значению по умолчанию.

**Возвращаемое значение**

* `String`, содержащая значение.
* Пустая строка, если значение не существует или не может быть представлено как строка.

**Подробнее**

`getStringValue()` читает значение типа **строка** из реестра. Важные моменты:

* Возвращаемый `String` — это значение, которым вы владеете; вы можете сохранять его по необходимости.
* Если значение не существует (или не является строкой), функция возвращает пустую строку.
* Используйте `isEmpty()`, чтобы проверить, найдено ли значение, или комбинируйте с `valueExists()` для большей ясности.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

String installPath = reg.getStringValue("InstallPath");
if (!installPath.isEmpty()) {
  // use installPath as a String
}
```

*Этот пример читает строковое значение и проверяет, не пусто ли оно, перед использованием.*

---

#### `Buffer getBinaryValue(const String &name = String()) const`

**Сигнатура**

```cpp
Buffer getBinaryValue(const String &name = String()) const;
```

**Краткое описание**
Возвращает двоичное значение, или пустой буфер, если не найдено.

**Параметры**

* `name` – Имя двоичного значения для чтения. Пустой `String()` (по умолчанию) относится к значению по умолчанию.

**Возвращаемое значение**

* `Buffer`, содержащий данные значения.
* Пустой буфер, если значение не существует или не является двоичным.

**Подробнее**

`getBinaryValue()` получает двоичное значение реестра. Возвращаемый `Buffer`:

* Является значением, которым вы владеете; его можно хранить по необходимости.
* Может быть проверен с помощью `isEmpty()` или `length()`, чтобы определить, существует ли значение.
* Предоставляет `length()` для доступа к размеру двоичных данных.

Это удобно для работы с двоичными данными, поскольку у вас есть и сами данные, и их длина.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

Buffer data = reg.getBinaryValue("Signature");
if (!data.isEmpty()) {
  // Interpret data using your own format or protocol.
  int size = data.length();
}
```

*Этот пример читает двоичное значение и проверяет, непустое ли оно, перед использованием.*

---

#### `unsigned int getIntegerValue(const String &name = String()) const`

**Сигнатура**

```cpp
unsigned int getIntegerValue(const String &name = String()) const;
```

**Краткое описание**
Возвращает целочисленное значение (0, если не найдено).

**Параметры**

* `name` – Имя целочисленного значения для чтения. Пустой `String()` (по умолчанию) относится к значению по умолчанию.

**Возвращаемое значение**

* Хранимое целочисленное значение.
* `0`, если значение не существует или не может быть прочитано как целое.

**Подробнее**

Эта функция читает целое значение (например, `REG_DWORD`) из реестра. Поскольку она возвращает `0` в случае ошибки, вы не можете различить:

* Отсутствие значения и
* Подлинное значение `0`.

Чтобы обнаружить отсутствие, комбинируйте её с `valueExists()`:

```cpp
if (reg.valueExists("Timeout")) {
  unsigned int timeout = reg.getIntegerValue("Timeout");
}
```

Используйте целочисленные значения для простых счётчиков, флагов или параметров конфигурации.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

unsigned int timeoutMs = reg.getIntegerValue("TimeoutMs");  // 0 if missing
```

*Этот пример читает целочисленный таймаут; если значение отсутствует, результат будет `0`.*

---

#### `bool setStringValue(const String &name, const String &str)`

**Сигнатура**

```cpp
bool setStringValue(const String &name, const String &str);
```

**Краткое описание**
Устанавливает строковое значение. Возвращает true при успехе.

**Параметры**

* `name` – Имя значения для установки. Используйте пустой `String()`, чтобы задать значение по умолчанию.
* `str` – `String`, содержащая текст в UTF‑8 для записи.

**Возвращаемое значение**

* `true`, если значение успешно записано.
* `false`, если запись не удалась (например, из‑за прав доступа или недействительного ключа).

**Подробнее**

`setStringValue()` записывает текстовое значение в реестр. Если значение с тем же именем уже существует:

* Оно перезаписывается новым содержимым.

Если сам ключ не существует, сначала следует вызвать `create()`.

Строковые значения обычно используются для путей, идентификаторов или настроек, естественно представимых в виде текста.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

if (reg.create()) {
  reg.setStringValue("InstallPath", "C:\\MyApp");
}
```

*Этот пример гарантирует существование ключа и затем записывает строковую настройку.*

---

#### `bool setBinaryValue(const String &name, const Buffer &buf)`

**Сигнатура**

```cpp
bool setBinaryValue(const String &name, const Buffer &buf);
```

**Краткое описание**
Устанавливает двоичное значение. Возвращает true при успехе.

**Параметры**

* `name` – Имя двоичного значения для установки.
* `buf` – `Buffer`, чьи сырые байты будут сохранены как значение.

**Возвращаемое значение**

* `true`, если значение успешно записано.
* `false`, если запись не удалась.

**Подробнее**

`setBinaryValue()` сохраняет произвольные двоичные данные в реестре. Тип значения соответствует двоичному типу реестра (например, `REG_BINARY`).

Типичные сценарии использования:

* Кэширование небольших двоичных фрагментов (подписей, контрольных сумм).
* Хранение данных фиксированного формата, который ваше приложение умеет декодировать.

**Пример**

```cpp
unsigned char signatureBytes[4] = {0xDE, 0xAD, 0xBE, 0xEF};
Buffer sigBuf(signatureBytes, 4);

Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");
if (reg.create()) {
  reg.setBinaryValue("Signature", sigBuf);
}
```

*Этот пример записывает небольшой двоичный подпись в реестр.*

---

#### `bool setIntegerValue(const String &name, unsigned int num)`

**Сигнатура**

```cpp
bool setIntegerValue(const String &name, unsigned int num);
```

**Краткое описание**
Устанавливает целочисленное значение. Возвращает true при успехе.

**Параметры**

* `name` – Имя целочисленного значения для установки.
* `num` – Беззнаковое целое число для сохранения.

**Возвращаемое значение**

* `true`, если значение успешно записано.
* `false`, если запись не удалась.

**Подробнее**

`setIntegerValue()` записывает числовое значение (например, `REG_DWORD`) под текущим ключом. Оно перезаписывает любое существующее значение с тем же именем.

Используйте целочисленные значения для счётчиков, размеров, флагов, включения/отключения функций или других числовых настроек.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");
if (reg.create()) {
  reg.setIntegerValue("WindowWidth", 1280);
  reg.setIntegerValue("WindowHeight", 720);
}
```

*Этот пример сохраняет размеры окна в виде целочисленных настроек.*

---

#### `bool deleteValue(const String &name = String())`

**Сигнатура**

```cpp
bool deleteValue(const String &name = String());
```

**Краткое описание**
Удаляет значение. Возвращает true при успехе.

**Параметры**

* `name` – Имя значения реестра для удаления. Пустой `String()` (по умолчанию) относится к значению по умолчанию.

**Возвращаемое значение**

* `true`, если значение было удалено или к концу вызова не существовало (успех зависит от реализации).
* `false`, если удаление не удалось (например, из‑за прав доступа).

**Подробнее**

`deleteValue()` удаляет отдельное значение из ключа, не удаляя сам ключ. Используйте это, когда:

* Настройка больше не нужна.
* Вы хотите вернуть жёстко заданные по умолчанию значения, удалив выставленные в реестре переопределения.

Тщательно различайте удаление **значения** (внутри ключа) и удаление целого **ключа** с помощью `remove()`.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");
// Remove an obsolete configuration value
reg.deleteValue("OldSetting");
```

*Этот пример удаляет одно именованное значение из ключа приложения.*

---

#### `List listValueNames() const`

**Сигнатура**

```cpp
List listValueNames() const;
```

**Краткое описание**
Возвращает список всех имён значений.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `List`, содержащий имена всех значений под текущим ключом. Каждый элемент обычно является `String`.

**Подробнее**

`listValueNames()` позволяет узнать, какие значения определены под ключом. Это полезно для:

* Отладочных и инспекционных инструментов.
* Универсальных редакторов конфигурации.
* Сценариев «импортировать всё».

Обращение со значением по умолчанию зависит от реализации; оно может появляться как пустая строка-имя или обрабатываться особым образом.

Вы можете комбинировать это с `getStringValue`, `getIntegerValue` или `getBinaryValue`, чтобы итерироваться по всем значениям.

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

List names = reg.listValueNames();
for (int i = 0; i < names.length(); ++i) {
  String name = names.at<String>(i);
  // For each value name, you could read or display it.
}
```

*Этот пример перечисляет все имена значений под ключом и итерируется по ним.*

---

#### `List listSubkeys() const`

**Сигнатура**

```cpp
List listSubkeys() const;
```

**Краткое описание**
Возвращает список всех имён дочерних ключей.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `List` из значений типа `String`, каждое представляет имя дочернего ключа под текущим ключом.

**Подробнее**

`listSubkeys()` предоставляет имена дочерних ключей под текущим ключом. Это позволяет:

* Обнаруживать динамически созданные подписи (например, по профилю пользователя).
* Построить навигацию по дереву в инструментах настройки.
* Перечислить все экземпляры определённых настроек, вложенных под корнем.

В сочетании с конструктором вы можете рекурсивно обходить поддерево реестра:

```cpp
List subs = reg.listSubkeys();
for (int i = 0; i < subs.length(); ++i) {
  String childName = subs.at<String>(i);
  Registry child("HKEY_CURRENT_USER\\Software\\MyApp\\" + childName);
  // Work with child...
}
```

**Пример**

```cpp
Registry reg("HKEY_CURRENT_USER\\Software\\MyApp");

List subkeys = reg.listSubkeys();
for (int i = 0; i < subkeys.length(); ++i) {
  String childName = subkeys.at<String>(i);
  // childName is the name of a subkey under MyApp
}
```