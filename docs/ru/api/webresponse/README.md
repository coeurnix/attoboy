# WebResponse

## Обзор

Класс `attoboy::WebResponse` представляет результат HTTP-запроса, выполненного с помощью `attoboy::WebRequest`. Он предоставляет удобный, соответствующий RAII способ для проверки:

* Успешен ли запрос (**succeeded**) (коды статуса 2xx).
* Конечный **URL** после всех перенаправлений.
* HTTP **код статуса** и понятная **строка причины**.
* Все **заголовки ответа** в виде `attoboy::Map`.
* **Тело** в виде:

  * строки (`String`),
  * сырых байтов (`Buffer`),
  * или разобранного JSON-объекта (`Map`).

Обычно вы не создаёте `WebResponse` напрямую. Вместо этого:

1. Вы создаёте `WebRequest`.
2. Вы вызываете один из его методов, например `doGet()` или `doPost()`.
3. Вы получаете `WebResponse` из этого метода.

Пример шаблона:

```cpp
using namespace attoboy;

WebRequest request("https://api.example.com/info");
WebResponse response = request.doGet();

if (response.succeeded()) {
  String body = response.asString();
  // Use the response body...
}
```

`WebResponse` разработан так, чтобы быть:

* **Удобным для проверки** — высокоуровневые методы для статуса, заголовков и тела.
* **Интегрированным с типами attoboy** — использует `String`, `Map` и `Buffer` для содержимого и метаданных.
* **Безопасным для копирования** — копирование `WebResponse` разделяет внутреннюю реализацию, сохраняя простой интерфейс по значению.

### Структура HTTP-ответа

Если вы новичок в веб-программировании, полезно считать, что HTTP-ответ состоит из трёх основных частей:

1. **Строка состояния**
   Содержит:

   * Версию HTTP (например, `HTTP/1.1`),
   * **Код статуса** (например, `200`, `404`),
   * **Строку причины** (например, `"OK"`, `"Not Found"`).
     В `WebResponse` это представлено следующими методами:
   * `getStatusCode()`
   * `getStatusReason()`
   * `succeeded()` (проверяет, находится ли код в диапазоне 200–299).

2. **Заголовки**
   Набор пар ключ–значение, описывающих ответ:

   * Примеры: `Content-Type`, `Content-Length`, `Set-Cookie`.
     В `WebResponse` доступ к заголовкам осуществляется через:
   * `getResponseHeaders()`, возвращающий `Map`.

3. **Тело**
   Собственно полезная нагрузка:

   * HTML, JSON, двоичные данные (изображения, PDF и т.д.).
     В `WebResponse` доступ к нему возможен через:
   * `asString()` для текста (UTF-8),
   * `asBuffer()` для сырых байтов,
   * `asJson()` когда ожидается JSON-объект.

### Типичный сценарий использования

Обычный рабочий процесс:

1. Выполните запрос:

   ```cpp
   WebRequest req("https://api.example.com/user/42");
   WebResponse res = req.doGet();
   ```

2. Проверьте общий статус:

   ```cpp
   if (!res.succeeded()) {
     int code = res.getStatusCode();
     String reason = res.getStatusReason();
     // Обработайте ошибку на основе кода/причины
   }
   ```

3. Прочитайте заголовки при необходимости:

   ```cpp
   Map headers = res.getResponseHeaders();
   String contentType = headers.get("Content-Type", String());
   ```

4. Получите тело в наиболее подходящем формате:

   * JSON API: `const Map json = res.asJson();`
   * Текст: `String body = res.asString();`
   * Двоичные данные: `Buffer data = res.asBuffer();`

---

## Справочник

Каждый пункт ниже описывает один публичный конструктор, оператор присваивания или метод `attoboy::WebResponse` с:

* **Сигнатура** – точное объявление из заголовочного файла.
* **Краткое описание** – оригинальная однострочная Doxygen-нотация.
* **Параметры** и **Возвращаемое значение**.
* **Подробнее** – дополнительное пояснение и краткий пример.

Все примеры предполагают:

```cpp
using namespace attoboy;
```

---

#### `WebResponse(const WebResponse &other)`

**Сигнатура**

```cpp
WebResponse(const WebResponse &other);
```

**Краткое описание**
Создаёт копию (разделяет внутренний ответ).

**Параметры**

* `other` – существующий `WebResponse`, который копируется.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Конструктор копирования создаёт новый `WebResponse`, который **разделяет** ту же внутреннюю реализацию, что и `other`. Это поверхностное копирование:

* Код статуса, заголовки и тело разделяются внутренне.

Поскольку `WebResponse` логически неизменяем с точки зрения пользователя, совместное использование безопасно и эффективно.

**Пример**

```cpp
WebRequest request("https://example.com/info");
WebResponse original = request.doGet();

// Create a copy that shares the same underlying response
WebResponse copy(original);

int codeOriginal = original.getStatusCode();
int codeCopy     = copy.getStatusCode();   // same code
```

*В этом примере показано копирование ответа и доступ к общей информации о статусе.*

---

#### `~WebResponse()`

**Сигнатура**

```cpp
~WebResponse();
```

**Краткое описание**
Уничтожает ответ и освобождает ресурсы.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробнее**

Деструктор освобождает любые внутренние ресурсы, связанные с ответом, такие как:

* Внутренние сетевые дескрипторы.
* Буферы, используемые для хранения тела.

**Пример**

```cpp
WebResponse response = WebRequest("https://example.com").doGet();
{
  WebResponse innerCopy(response);
  // Use innerCopy here...
} // innerCopy is destroyed; response is still valid

// response can still be used here.
String body = response.asString();
```

*В этом примере демонстрируется, что копии ответа можно безопасно создавать и уничтожать, в то время как оригинал остаётся валидным.*

---

#### `WebResponse &operator=(const WebResponse &other)`

**Сигнатура**

```cpp
WebResponse &operator=(const WebResponse &other);
```

**Краткое описание**
Присваивает другой ответ (разделяет внутренний ответ).

**Параметры**

* `other` – `WebResponse`, из которого выполняется присваивание.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочку присваиваний.

**Подробнее**

Оператор копирующего присваивания:

* Освобождает ресурсы текущего ответа.
* Делает так, чтобы этот объект разделял внутренние данные ответа с `other`.

После присваивания:

* И `*this`, и `other` ссылаются на один и тот же ответ.
* Такие методы, как `getStatusCode()` и `asString()`, будут возвращать одинаковые значения для обоих объектов.

Самоприсваивание безопасно и обрабатывается реализацией.

**Пример**

```cpp
WebResponse a = WebRequest("https://example.com/a").doGet();
WebResponse b = WebRequest("https://example.com/b").doGet();

// Reassign b to share the same response as a
b = a;

if (b.succeeded()) {
  String body = b.asString();  // same body as a.asString()
}
```

*В этом примере один ответ переназначается так, чтобы разделять данные другого ответа.*

---

#### `bool succeeded() const`

**Сигнатура**

```cpp
bool succeeded() const;
```

**Краткое описание**
Возвращает true, если код статуса 200–299.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если HTTP-код статуса находится в диапазоне `200`–`299` (включительно).
* `false` в противном случае.

**Подробнее**

`succeeded()` предоставляет простой высокоуровневый способ проверить, был ли запрос признан успешным по HTTP-конвенциям:

* Коды 2xx означают успех:

  * `200 OK`
  * `201 Created`
  * `204 No Content` и т.д.

Для любого не-2xx статуса (включая перенаправления, ошибки клиента и ошибки сервера):

* `succeeded()` возвращает `false`.
* Вы всё ещё можете просмотреть код и тело с помощью `getStatusCode()` и `asString()`/`asBuffer()`.

Помните, что сетевые ошибки (например, таймаут или сбой соединения) могут привести к ответу, где `getStatusCode()` равен `0` или другому значению, определённому реализацией. Следует трактовать `!succeeded()` как «операция не дала успешного результата HTTP 2xx».

**Пример**

```cpp
WebRequest request("https://api.example.com/data");
WebResponse response = request.doGet(5000);

if (response.succeeded()) {
  String body = response.asString();
  // Process successful response body
} else {
  int code = response.getStatusCode();
  String reason = response.getStatusReason();
  // Handle non-2xx status or network error
}
```

*В этом примере проверяется успешность ответа перед обработкой тела.*

---

#### `String getUrl() const`

**Сигнатура**

```cpp
String getUrl() const;
```

**Краткое описание**
Возвращает конечный URL после перенаправлений.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая конечный URL, который привёл к этому ответу, включая все перенаправления, которые были выполнены.

**Подробнее**

`getUrl()` особенно полезен, когда:

* Вы начинаете с URL, который может перенаправлять (например, с `http` на `https` или на другой путь).
* Вы хотите знать **конечный** URL после всех перенаправлений, обработанных встроенным HTTP-клиентом.

Например, если вы запрашиваете `http://example.com` и сервер перенаправляет на `https://www.example.com/home`, `getUrl()` вернёт второй адрес.

Это особенно полезно при:

* Скачивании ресурсов, которые со временем перемещаются.
* Отладке цепочек перенаправлений.

**Пример**

```cpp
WebRequest request("http://example.com"); // may redirect to https
WebResponse response = request.doGet();

String finalUrl = response.getUrl();
// e.g., "https://www.example.com/"
```

*В этом примере показано получение конечного URL после возможных перенаправлений.*

---

#### `int getStatusCode() const`

**Сигнатура**

```cpp
int getStatusCode() const;
```

**Краткое описание**
Возвращает HTTP-код статуса (например, 200, 404).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Целочисленный HTTP-код статуса, возвращённый сервером, например `200`, `404` или `500`.

**Подробнее**

**Код статуса** — основной индикатор того, как сервер обработал запрос:

* **2xx** – успех (`200 OK`, `201 Created`, `204 No Content` и т.д.).
* **3xx** – перенаправления.
* **4xx** – ошибки клиента (`400 Bad Request`, `401 Unauthorized`, `404 Not Found` и т.д.).
* **5xx** – ошибки сервера (`500 Internal Server Error` и т.д.).

Вы можете использовать `getStatusCode()` для:

* Реализации детальной обработки ошибок.
* Различения разных типов сбоев даже когда `succeeded()` возвращает `false`.

Для сетевых ошибок код может быть `0` или другим значением, определённым реализацией. Используйте это в сочетании с `succeeded()` и, при необходимости, телом ответа для диагностики.

**Пример**

```cpp
WebResponse response = WebRequest("https://example.com/missing").doGet();

int code = response.getStatusCode();  // e.g., 404
if (code == 404) {
  // specific handling for "Not Found"
}
```

*В этом примере проверяется конкретный HTTP-код статуса.*

---

#### `String getStatusReason() const`

**Сигнатура**

```cpp
String getStatusReason() const;
```

**Краткое описание**
Возвращает строку причины статуса (например, "OK", "Not Found").

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая фразу причины, связанную с кодом статуса, например `"OK"`, `"Created"` или `"Not Found"`.

**Подробнее**

**Строка причины** — короткое читаемое человеком описание, сопровождающее код статуса. Она в основном полезна для:

* Логирования и отладки.
* Информативных сообщений, показываемых пользователям или разработчикам.

Строка причины обычно не используется для логики; для этого следует опираться на числовой код. Тем не менее, она может дать полезный контекст при диагностике проблем.

**Пример**

```cpp
WebResponse response = WebRequest("https://example.com/missing").doGet();

int code = response.getStatusCode();
String reason = response.getStatusReason();
// e.g., code == 404, reason == "Not Found"
```

*В этом примере получаются как числовой код, так и человекочитаемая строка причины.*

---

#### `Map getResponseHeaders() const`

**Сигнатура**

```cpp
Map getResponseHeaders() const;
```

**Краткое описание**
Возвращает отображение (map) заголовков ответа.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Map`, содержащая все заголовки ответа.

  * Ключи: имена заголовков в виде `String`.
  * Значения: значения заголовков в виде `String` (или типов, приводимых к `String`).

**Подробнее**

`getResponseHeaders()` позволяет просмотреть метаданные, предоставленные сервером:

* `Content-Type`
* `Content-Length`
* `Date`
* `Server`
* Пользовательские заголовки (например, `X-Request-ID`, `X-RateLimit-Limit`)

Особенности:

* Имена HTTP-заголовков нечувствительны к регистру, но фактический регистр, хранящийся в map, зависит от реализации. Обычно следует искать ключи в том регистре, который вы наблюдаете в типичных ответах, или нормализовать их самостоятельно при необходимости.
* Возвращаемый `Map` является **копией**. Изменение его не меняет оригинальный ответ.

Типичное использование:

* Проверить `Content-Type` перед разбором JSON.
* Просмотреть заголовки кэширования или ограничения скорости.
* Отладить проблемы с конфигурацией сервера.

**Пример**

```cpp
WebResponse response = WebRequest("https://api.example.com/data").doGet();

// Inspect headers
Map headers = response.getResponseHeaders();

String contentType = headers.get("Content-Type", String());
String requestId   = headers.get("X-Request-ID", String());

// Use header values for logging or conditional logic
```

*В этом примере читаются некоторые общие заголовки из ответа.*

---

#### `Map asJson() const`

**Сигнатура**

```cpp
Map asJson() const;
```

**Краткое описание**
Парсит тело как JSON-объект. Возвращает пустой Map, если тело не является JSON-объектом.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Map`, представляющая JSON-объект, распарсенный из тела, или пустой `Map`, если:

  * Тело пустое,
  * Тело не является корректным JSON,
  * JSON не является JSON-**объектом** (например, если это массив или примитив).

**Подробнее**

`asJson()` — удобная функция для JSON-ориентированных API:

* Она пытается распарсить тело ответа как JSON.
* Если разбор успешен и верхнеуровневое значение является JSON-объектом (`{ ... }`), возвращается `Map`, представляющая этот объект.
* Если разбор не удался или верхнеуровневое значение не является объектом (например, `[...]`), возвращается пустой `Map`.

Важные детали:

* Возвращаемый `Map` — это значение, которым вы владеете; вы можете сохранить его при необходимости.
* Используйте `isEmpty()`, чтобы проверить, удался ли парсинг JSON.
* Содержимое `Map` можно получить с помощью методов `Map`, таких как `get`, `hasKey`, `keys` и т.д.

Если вы ожидаете JSON-**массив** на верхнем уровне, следует разбирать тело вручную (например, используя `List::FromJSONString(response.asString())`), поскольку `asJson()` ориентирован именно на JSON-объекты.

**Пример**

```cpp
WebResponse response = WebRequest("https://api.example.com/user/42").doGet();

if (!response.succeeded()) {
  // handle error...
} else {
  Map json = response.asJson();
  if (!json.isEmpty()) {
    // Extract fields with defaults
    String name = json.get("name", String("Unknown"));
    int age     = json.get("age", 0);

    // Use parsed data...
  } else {
    // Body was not a JSON object
    String rawBody = response.asString();
    // handle unexpected format...
  }
}
```

*В этом примере тело ответа разбирается как JSON-объект и поля безопасно извлекаются с использованием значений по умолчанию.*

---

#### `String asString() const`

**Сигнатура**

```cpp
String asString() const;
```

**Краткое описание**
Возвращает тело как строку.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая тело ответа, интерпретированное как UTF-8 текст.

**Подробнее**

`asString()` — основной способ доступа к текстовым ответам:

* Он декодирует байты тела как UTF-8 и возвращает `String`.
* Подходит для:

  * JSON,
  * HTML,
  * простого текста,
  * или любого другого содержимого, совместимого с UTF-8.

Если ответ является двоичным (например, изображения, PDF или сжатые данные), лучше использовать `asBuffer()`. Вызов `asString()` для двоичных данных может дать нечитаемый текст или некорректные символы.

Возвращаемый `String` является копией; он остаётся валидным даже после уничтожения `WebResponse`.

**Пример**

```cpp
WebResponse response = WebRequest("https://example.com/hello.txt").doGet();

if (response.succeeded()) {
  String text = response.asString();
  // text now holds the entire body as UTF-8
}
```

*В этом примере читается простой текстовый файл с сервера как строка.*

---

#### `Buffer asBuffer() const`

**Сигнатура**

```cpp
Buffer asBuffer() const;
```

**Краткое описание**
Возвращает тело как буфер.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Buffer`, содержащий сырые байты тела ответа.

**Подробнее**

`asBuffer()` — низкоуровневый аналог `asString()`:

* Возвращает тело как двоичные данные, без какой-либо декодировки или предположений о кодировке.
* Идеален для:

  * Скачивания изображений.
  * Обработки двоичных протоколов.
  * Работы с сжатыми или зашифрованными данными.

Поскольку возвращаемый `Buffer` является копией, вы можете безопасно изменять его, извлекать части или хранить за пределами времени жизни `WebResponse`.

Вы можете комбинировать `asBuffer()` с другими методами `Buffer`:

* `length()`
* `toBase64()`
* `compress()` / `decompress()`
* `crypt()` для шифрования/дешифрования

**Пример**

```cpp
WebResponse response = WebRequest("https://example.com/image.png").doGet();

if (response.succeeded()) {
  Buffer data = response.asBuffer();

  int size = data.length();
  // You could write 'data' to disk with Path/File, or process it further.
}
```

*В этом примере изображение получается в виде буфера сырых байтов.*