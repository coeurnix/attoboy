# Set

## Обзор

Класс `attoboy::Set` — это **неупорядоченное множество уникальных значений**. Он задуман как компактная, гибкая альтернатива множествам из стандартной библиотеки, но без зависимости от стандартной библиотеки C++. Вместо этого он плотно интегрирован с другими типами attoboy:

* Примитивы: `bool`, `int`, `float`
* Текст: `String`
* Вложенные контейнеры: `List`, `Map`, `Set`

В общих чертах `Set` предоставляет:

* **Уникальность** — каждое значение присутствует не более одного раза.
* **Неупорядоченное хранение** — библиотека не гарантирует конкретный порядок итерации.
* **Элементы разных типов** — одно множество может хранить значения разных типов.
* **Операции над множествами** — объединение, пересечение и разность.
* **Интеграция с JSON** — преобразование в JSON и из JSON (строки массива).

Класс особенно полезен, когда для вас важна именно **принадлежность** («присутствует ли это значение?»), а не порядок или дубликаты.

### Множества, уникальность и порядок

В концептуальном плане множество — это математическая коллекция со следующими свойствами:

* **Без дубликатов**
  Если вы добавите одно и то же значение несколько раз, в множестве всё равно будет только одна копия этого значения.
* **Без гарантированного порядка**
  Множество не обещает, что значения будут появляться в том порядке, в котором вы их вставляли. Внутри может использоваться хеширование или другие структуры, не сохраняющие порядок вставки.

В `attoboy::Set`:

* `put(value)` добавляет значение, если оно ещё не присутствует.
* Добавление значения, которое уже существует, ничего не делает (дубликаты тихо игнорируются).
* `length()` считает, сколько различных значений хранится.
* `contains(value)` эффективно проверяет принадлежность.

### Смешанные типы и равенство

`Set` может хранить значения разных типов, например:

* `Set(1, "two", 3.0f)`
* `Set("apple", String("banana"), List(1, 2))`

Проверки равенства и членства используют внутренние, учитывающие типы, сравнения. На практике:

* Сохранённый `int` `1` отличается от строки `"1"`.
* Два значения разных типов не считаются равными, даже если они визуально похожи как текст.

Чтобы избежать неожиданностей при операциях над множествами, старайтесь по возможности хранить сопоставимые значения одного типа (например, все целые числа или все строки).

### Изменяемость, RAII и цепочки вызовов

В отличие от `String`, `Set` — **изменяемый**:

* Методы вроде `put()`, `remove()`, `clear()` и `setUnion()` изменяют множество на месте.
* Эти методы возвращают ссылку на `*this`, что позволяет выполнять удобные **цепочки вызовов**:

```cpp
using namespace attoboy;

Set items;
items.put(1)
     .put(2)
     .put(2)    // игнорируется дубликат
     .remove(1);
// теперь items содержит только {2}
```

`Set` также следует принципу RAII (получение ресурсов при инициализации):

* Конструкция выделяет любые внутренние ресурсы, которые нужны.
* Деструктор автоматически освобождает память, когда множество выходит из области видимости.
* Копирование и присваивание корректно управляют владением; освобождать что-либо вручную не требуется.

### Интеграция с `List` и JSON

`Set` хорошо интегрирован с другими контейнерами attoboy:

* Вы можете сконструировать множество из `List`, автоматически **удаляя дубликаты**.
* Вы можете преобразовать множество в `List` с помощью `toList()`, если нужен индексированный доступ или сортировка.
* Вы можете сериализовать множество в JSON и восстанавливать из JSON:

  * `toJSONString()` создаёт строку JSON-массива, представляющую содержимое множества.
  * `FromJSONString()` парсит строку JSON-массива и строит множество из неё.

Эти возможности делают `Set` хорошим инструментом для представления наборов тегов, уникальных идентификаторов или любых значений, где важнее членство и уникальность, чем порядок.

---

## Справочник

Каждый раздел ниже описывает один публичный конструктор, метод, статическую функцию или оператор `attoboy::Set`. Для каждого элемента вы найдёте:

* **Сигнатура** — точное объявление из заголовка.
* **Кратко** — исходный однострочный комментарий Doxygen.
* Описания **Параметров** и **Возвращаемого значения**.
* **Подробно** — дополнительные детали, оговорки и короткий пример.

> **Примечание:** Все примеры предполагают `using namespace attoboy;`.

---

#### `Set()`

**Сигнатура**

```cpp
Set();
```

**Кратко**
Создаёт пустое множество.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот конструктор создаёт множество без значений. Немедленно после конструктора:

* `length()` равно `0`.
* `isEmpty()` возвращает `true`.

Обычно вы начинаете с пустого множества и добавляете значения позднее с помощью `put()`.

**Пример**

```cpp
Set flags;
flags.put("debug");
// flags теперь содержит {"debug"}
```

*Этот пример начинается с пустого множества и добавляет одно значение.*

---

#### `Set(int capacity)`

**Сигнатура**

```cpp
Set(int capacity);
```

**Кратко**
Создаёт пустое множество с заранее зарезервированной вместимостью.

**Параметры**

* `capacity` – оценка количества значений, которые вы ожидаете сохранить.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот конструктор создаёт пустое множество, но резервирует внутреннее хранилище примерно под `capacity` элементов. Это может снизить количество перераспределений памяти, если вы заранее знаете, сколько различных значений планируете вставить.

Множество по-прежнему пустое; `length()` остаётся `0`, пока вы не вызовете `put()`.

**Пример**

```cpp
int expected = 100;
Set ids(expected);
for (int i = 0; i < expected; ++i) {
  ids.put(i);
}
// ids теперь содержит целые 0..99 (в неопределённом порядке)
```

*Этот пример резервирует место для 100 значений и затем заполняет множество целыми числами.*

---

#### `template <typename... Args> Set(const Args &...args)`

**Сигнатура**

```cpp
template <typename... Args> Set(const Args &...args) : Set() {
  variadic_put(args...);
}
```

**Кратко**
Создаёт множество с указанными значениями: Set(1, 2, 3)

**Параметры**

* `args` – одно или несколько значений для вставки. Каждый должен быть типом, поддерживаемым `Set` (например, `bool`, `int`, `float`, `const char *`, `String`, `List`, `Map` или другой `Set`).

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот вариативный конструктор создаёт новое множество и вставляет каждое переданное значение с семантикой `put()`:

* Каждый аргумент добавляется в множество.
* Дубликаты среди аргументов тихо игнорируются.

Поскольку порядок не гарантируется, а дубликаты отбрасываются, этот конструктор идеален для небольших, похожих на литералы множеств, когда нужна уникальность.

**Пример**

```cpp
Set numbers(1, 2, 2, 3);
// numbers содержит {1, 2, 3}, дубликат 2 игнорируется
```

*Этот пример создаёт множество с начальными значениями, демонстрируя, что дубликаты не хранятся дважды.*

---

#### `Set(const Set &other)`

**Сигнатура**

```cpp
Set(const Set &other);
```

**Кратко**
Создаёт копию другого множества.

**Параметры**

* `other` – существующее множество для копирования.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Конструктор копирования создаёт новое множество, содержащее те же значения, что и `other`. Поскольку множества неупорядочены, внутренний порядок может отличаться, даже если содержимое совпадает, но:

* `length()` будет одинаковым.
* `contains(value)` для любого значения даст одинаковый результат в обоих множествах.
* `compare(other)` и `operator==` сообщают о равенстве.

**Пример**

```cpp
Set original( "a", "b", "c" );
Set copy(original);
// copy изначально имеет те же значения, что и original
```

*Этот пример дублирует множество, чтобы две переменные представляли эквивалентные коллекции.*

---

#### `Set(const List &list)`

**Сигнатура**

```cpp
Set(const List &list);
```

**Кратко**
Создаёт множество из списка, удаляя дубликаты.

**Параметры**

* `list` – исходный `List`, значения которого будут вставлены в множество.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот конструктор конвертирует `List` в `Set` следующим образом:

1. Итерирует все элементы в `list`.
2. Вставляет каждое значение в множество через `put()`.

Как обычно для множеств, **дубликаты удаляются**, поэтому каждое различное значение появляется в результирующем множестве не более одного раза. Порядок не сохраняется.

**Пример**

```cpp
List values("red", "green", "red", "blue");
Set colors(values);
// colors содержит {"red", "green", "blue"}, дубликаты удалены
```

*Этот пример преобразует список с дубликатами в множество уникальных значений.*

---

#### `~Set()`

**Сигнатура**

```cpp
~Set();
```

**Кратко**
Уничтожает множество и освобождает память.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробно**

Когда `Set` выходит из области видимости или иным образом уничтожается, его деструктор освобождает любые внутренние ресурсы (такие как выделенные таблицы или буферы). Вам не нужно освобождать что-либо вручную; паттерн RAII гарантирует автоматическую очистку памяти.

**Пример**

```cpp
{
  Set temp(1, 2, 3);
  // использование temp
}
// temp уничтожается здесь; внутренние ресурсы освобождаются
```

*Этот пример показывает локальное множество, которое автоматически очищается в конце блока.*

---

#### `Set &operator=(const Set &other)`

**Сигнатура**

```cpp
Set &operator=(const Set &other);
```

**Кратко**
Присваивает этому множеству содержимое другого множества.

**Параметры**

* `other` – множество, содержимое которого должно заменить текущее.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочки присваиваний.

**Подробно**

Оператор копирующего присваивания делает так, чтобы текущее множество содержало точно те же значения, что и `other`. Любые ранее сохранённые значения в `*this` отбрасываются.

После присваивания:

* `length()` совпадает с `other.length()`.
* `contains(value)` даёт тот же результат в обоих множествах для любого значения.

Самоприсваивание (`set = set`) безопасно.

**Пример**

```cpp
Set a("apple", "banana");
Set b("cherry");

a = b;
// a теперь содержит только те значения, что были в b
```

*Этот пример заменяет содержимое одного множества на содержимое другого.*

---

#### `int length() const`

**Сигнатура**

```cpp
int length() const;
```

**Кратко**
Возвращает количество значений в множестве.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Число различных значений, хранящихся в множестве.

**Подробно**

`length()` считает, сколько уникальных значений в текущий момент присутствует. Поскольку дубликаты не сохраняются, это число означает количество **отличных** элементов.

**Пример**

```cpp
Set s(1, 2, 2, 3);
int n = s.length();  // 3
```

*Этот пример показывает, что дубликаты не увеличивают длину множества.*

---

#### `bool isEmpty() const`

**Сигнатура**

```cpp
bool isEmpty() const;
```

**Кратко**
Возвращает true, если множество пусто.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если `length() == 0`; `false` в противном случае.

**Подробно**

`isEmpty()` — удобный метод для проверки, содержит ли множество какие-либо значения. Семантически эквивалентен `length() == 0`, но часто яснее в условном коде.

**Пример**

```cpp
Set s;
if (s.isEmpty()) {
  s.put("first");
}
```

*Этот пример инициализирует множество значением только если оно в настоящий момент пусто.*

---

#### `template <typename T> Set &put(T value)`

**Сигнатура**

```cpp
template <typename T> Set &put(T value) {
  put_impl(value);
  return *this;
}
```

**Кратко**
Добавляет значение в множество. Дубликаты игнорируются. Возвращает это множество для цепочек.

**Параметры**

* `value` – значение для добавления. Должно быть типом, поддерживаемым `Set` (`bool`, `int`, `float`, `const char *`, `String`, `List`, `Map`, `Set` и т. д.).

**Возвращаемое значение**

* Ссылка на `*this`, позволяющая цепочки вызовов.

**Подробно**

`put()` вставляет `value` в множество:

* Если `value` ещё не присутствует, оно добавляется и `length()` увеличивается на единицу.
* Если `value` уже присутствует, ничего не меняется; дубликаты тихо игнорируются.

Метод шаблонный, и внутренняя функция `put_impl()` выбирает нужную перегрузку в зависимости от реального типа.

Поскольку порядок не гарантируется, позиция `value` во внутренней структуре не имеет смысла.

**Пример**

```cpp
Set tags;
tags.put("alpha")
    .put("beta")
    .put("alpha");  // дубликат игнорируется
// tags содержит {"alpha", "beta"}
```

*Этот пример демонстрирует, что добавление дубликата не изменяет множество.*

---

#### `template <typename T> Set &remove(T value)`

**Сигнатура**

```cpp
template <typename T> Set &remove(T value) {
  remove_impl(value);
  return *this;
}
```

**Кратко**
Удаляет значение из множества. Возвращает это множество для цепочек.

**Параметры**

* `value` – значение для удаления.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`remove()` удаляет `value` из множества, если оно присутствует. После успешного удаления:

* `contains(value)` возвращает `false`.
* `length()` уменьшается на единицу.

Если значение отсутствует, операция фактически является no-op.

Важна точность типов: удаляются только значения, считающиеся равными по правилам сравнения множества.

**Пример**

```cpp
Set ids(1, 2, 3);
ids.remove(2);
// ids содержит {1, 3}
```

*Этот пример удаляет значение из множества, оставляя остальные нетронутыми.*

---

#### `Set &clear()`

**Сигнатура**

```cpp
Set &clear();
```

**Кратко**
Удаляет все значения. Возвращает это множество для цепочек.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`clear()` полностью очищает множество:

* `length()` становится `0`.
* `isEmpty()` возвращает `true`.
* Все предыдущие значения удаляются.

Внутренняя ёмкость может оставаться выделенной для эффективности, но множество ведёт себя так, как будто оно только что сконструировано.

**Пример**

```cpp
Set s(1, 2, 3);
s.clear();
// s теперь пусто
```

*Этот пример удаляет все значения из множества.*

---

#### `Set &setUnion(const Set &other)`

**Сигнатура**

```cpp
Set &setUnion(const Set &other);
```

**Кратко**
Добавляет все значения из другого множества (объединение). Возвращает это множество для цепочек.

**Параметры**

* `other` – другое множество, значения которого будут включены.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`setUnion()` изменяет текущее множество, делая его **объединением** `*this` и `other`:

* Каждое значение, присутствующее в любом из множеств, окажется в `*this`.
* Значения из `other`, которые уже есть в `*this`, игнорируются как дубликаты.

`other` остаётся без изменений.

**Пример**

```cpp
Set a(1, 2);
Set b(2, 3);

a.setUnion(b);
// a содержит {1, 2, 3}
// b остаётся {2, 3}
```

*Этот пример объединяет значения двух множеств, не вводя дубликатов.*

---

#### `Set &intersect(const Set &other)`

**Сигнатура**

```cpp
Set &intersect(const Set &other);
```

**Кратко**
Оставляет только значения, присутствующие в обоих множествах (пересечение). Возвращает это множество для цепочек.

**Параметры**

* `other` – другое множество для пересечения.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`intersect()` изменяет текущее множество, оставляя только значения, которые присутствуют **как в `*this`, так и в `other`**:

* Значения, отсутствующие в `other`, удаляются из `*this`.
* Значения, присутствующие в `other`, но отсутствующие в `*this`, не добавляются.

В математическом виде:

```text
*this := *this ∩ other
```

**Пример**

```cpp
Set a(1, 2, 3);
Set b(2, 3, 4);

a.intersect(b);
// a содержит {2, 3}
```

*Этот пример вычисляет пересечение двух множеств, оставляя только общие значения.*

---

#### `Set &subtract(const Set &other)`

**Сигнатура**

```cpp
Set &subtract(const Set &other);
```

**Кратко**
Удаляет все значения из other (разность множеств). Возвращает это множество для цепочек.

**Параметры**

* `other` – множество, значения которого нужно удалить из текущего множества.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`subtract()` выполняет операцию **разности множеств**:

* Все значения, присутствующие и в `*this`, и в `other`, удаляются из `*this`.
* Значения, уникальные для `*this`, остаются.
* `other` не изменяется.

В математическом виде:

```text
*this := *this − other
```

**Пример**

```cpp
Set a(1, 2, 3, 4);
Set b(2, 4);

a.subtract(b);
// a содержит {1, 3}
```

*Этот пример удаляет все значения, которые встречаются в другом множестве.*

---

#### `template <typename T> bool contains(T value) const`

**Сигнатура**

```cpp
template <typename T> bool contains(T value) const;
```

**Кратко**
Возвращает true, если множество содержит значение.

**Параметры**

* `value` – значение для проверки на принадлежность.

**Возвращаемое значение**

* `true`, если значение присутствует в множестве; `false` в противном случае.

**Подробно**

`contains()` — основной тест на принадлежность. Он проверяет, есть ли в множестве значение, равное `value`. Для предсказуемых результатов следует передавать тот же тип (или совместимый тип), что и значения, которые вы вставляли.

**Пример**

```cpp
Set roles("admin", "user");
bool isAdmin = roles.contains("admin");  // true
bool isGuest = roles.contains("guest");  // false
```

*Этот пример проверяет, присутствуют ли определённые роли в множестве.*

---

#### `Set duplicate() const`

**Сигнатура**

```cpp
Set duplicate() const;
```

**Кратко**
Возвращает копию этого множества.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Новое `Set`, содержащее те же значения, что и оригинал.

**Подробно**

`duplicate()` явно создаёт копию множества. Это полезно, когда вы хотите выполнить изменяющие операции (например, `setUnion()` или `subtract()`) на копии, оставив оригинал без изменений.

**Пример**

```cpp
Set original(1, 2, 3);
Set copy = original.duplicate();

copy.remove(2);
// original всё ещё содержит {1, 2, 3}
// copy теперь содержит {1, 3}
```

*Этот пример показывает, как изменить копию множества, сохранив оригинал.*

---

#### `List toList() const`

**Сигнатура**

```cpp
List toList() const;
```

**Кратко**
Возвращает список всех значений множества.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `List`, содержащий значения множества в неопределённом порядке.

**Подробно**

`toList()` преобразует множество в `List`:

* Каждое значение множества появляется ровно один раз в результирующем списке.
* Порядок элементов не гарантируется и может отличаться между запусками или версиями.

Это преобразование полезно, когда нужен индексированный доступ, сортировка, экспорт в CSV или другие списковые операции над данными, которые естественно уникальны.

**Пример**

```cpp
Set numbers(3, 1, 2);
List asList = numbers.toList();
// asList содержит те же значения {1, 2, 3} в некотором порядке
```

*Этот пример преобразует множество в список для дальнейшей обработки.*

---

#### `String toJSONString() const`

**Сигнатура**

```cpp
String toJSONString() const;
```

**Кратко**
Преобразует это множество в строку JSON-массива.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая JSON-представление множества в виде массива.

**Подробно**

`toJSONString()` сериализует множество как JSON-массив. Например, множество, содержащее `1`, `"two"` и `true`, может быть сериализовано как:

```json
[1,"two",true]
```

Важные замечания:

* Порядок элементов в JSON-массиве не гарантируется.
* Значения конвертируются в JSON в соответствии с их типами:

  * Числа → JSON-числа
  * Булевы значения → `true`/`false`
  * Строки → JSON-строки
  * Вложенные контейнеры (`List`, `Map`, `Set`) → JSON-массивы/объекты

**Пример**

```cpp
Set flags("alpha", "beta");
String json = flags.toJSONString();
// например, ["alpha","beta"] (порядок не гарантируется)
```

*Этот пример сериализует множество строк в строку JSON-массива.*

---

#### `static Set FromJSONString(const String &json)`

**Сигнатура**

```cpp
static Set FromJSONString(const String &json);
```

**Кратко**
Создаёт множество из строки JSON-массива.

**Параметры**

* `json` – текст JSON-массива для парсинга.

**Возвращаемое значение**

* `Set`, содержащий значения, распарсенные из JSON-массива.

**Подробно**

`FromJSONString()` парсит строку JSON-массива и строит множество:

* Каждый элемент JSON-массива становится значением в множестве.
* Если JSON содержит дубликаты, результирующее множество всё равно сохраняет только одну копию каждого значения.
* Вложенные массивы и объекты становятся значениями `List` и `Map` соответственно, аналогично другим JSON-функциям библиотеки.

Если входная строка не является корректным JSON-массивом, результат может быть пустым множеством или отражать состояние ошибки; следует проверять или обрабатывать неожиданные входы соответствующим образом.

**Пример**

```cpp
String json("[\"alpha\",\"beta\",\"alpha\"]");
Set flags = Set::FromJSONString(json);
// flags содержит {"alpha", "beta"}
```

*Этот пример парсит JSON-массив в множество, автоматически удаляя дубликаты.*

---

#### `bool compare(const Set &other) const`

**Сигнатура**

```cpp
bool compare(const Set &other) const;
```

**Кратко**
Возвращает true, если это множество равно другому множеству.

**Параметры**

* `other` – множество для сравнения.

**Возвращаемое значение**

* `true`, если оба множества содержат точно одинаковые значения; `false` в противном случае.

**Подробно**

`compare()` проверяет равенство в терминах множеств:

* Два множества равны, если каждое значение из одного присутствует в другом и наоборот.
* Внутренний порядок не имеет значения; важна только принадлежность значений.
* Различия в дубликатах невозможны, так как множества не сохраняют дубликаты.

Функционально эквивалентна `operator==` и служит именованной альтернативой.

**Пример**

```cpp
Set a(1, 2, 3);
Set b(3, 2, 1);
Set c(1, 2);

bool ab = a.compare(b);  // true (одинаковые значения)
bool ac = a.compare(c);  // false (в c отсутствует 3)
```

*Этот пример показывает сравнение на равенство, игнорирующее порядок, но требующее одинакового набора значений.*

---

#### `bool operator==(const Set &other) const`

**Сигнатура**

```cpp
bool operator==(const Set &other) const;
```

**Кратко**
Возвращает true, если это множество равно другому множеству.

**Параметры**

* `other` – множество для сравнения.

**Возвращаемое значение**

* `true`, если множества равны; `false` в противном случае.

**Подробно**

Этот оператор предоставляет идиоматичный синтаксис для проверки равенства множеств:

```cpp
if (a == b) { ... }
```

Он использует ту же логику, что и `compare()`: множества считаются равными тогда и только тогда, когда содержат одинаковые значения, независимо от внутреннего порядка.

**Пример**

```cpp
Set a("x", "y");
Set b("y", "x");
Set c("x");

bool same = (a == b); // true
bool diff = (a == c); // false
```

*Этот пример демонстрирует сравнение множеств с помощью оператора `==`.*

---

#### `bool operator!=(const Set &other) const`

**Сигнатура**

```cpp
bool operator!=(const Set &other) const;
```

**Кратко**
Возвращает true, если это множество не равно другому множеству.

**Параметры**

* `other` – множество для сравнения.

**Возвращаемое значение**

* `true`, если множества не равны; `false`, если равны.

**Подробно**

Этот оператор является логическим отрицанием `operator==`. Удобен, когда нужно ветвить по неравенству:

```cpp
if (a != b) { ... }
```

**Пример**

```cpp
Set a(1, 2);
Set b(2, 3);

if (a != b) {
  // множества содержат разные значения
}
```

*Этот пример использует неравенство для обнаружения несовпадения множеств.*

---

#### `template <typename T> Set operator+(T value) const`

**Сигнатура**

```cpp
template <typename T> Set operator+(T value) const {
  Set result = duplicate();
  result.put(value);
  return result;
}
```

**Кратко**
Возвращает новое множество с добавленным значением.

**Параметры**

* `value` – значение для добавления в копию текущего множества.

**Возвращаемое значение**

* Новое `Set`, содержащее все значения исходного множества и `value` (если оно ещё не присутствовало).

**Подробно**

Этот оператор предоставляет функциональный способ расширить множество, не мутируя оригинал:

1. Дублирует текущее множество.
2. Добавляет `value` в дубликат (с семантикой `put()`).
3. Возвращает новое множество, оставляя оригинал без изменений.

Поскольку множества игнорируют дубликаты, добавление уже присутствующего значения просто вернёт множество с тем же содержимым.

**Пример**

```cpp
Set base("a", "b");
Set extended = base + "c";
// base всё ещё содержит {"a", "b"}
// extended содержит {"a", "b", "c"}
```

*Этот пример использует оператор `+` для создания нового множества с дополнительным значением, сохраняя оригинал.*