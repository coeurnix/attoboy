# Глобальные функции

## Обзор

Глобальные функции в библиотеке attoboy предоставляют небольшой, сфокусированный набор **системных утилит** и **структурированной подсистемы логирования**, которые можно использовать в любом месте вашей программы. Они спроектированы так, чтобы работать без CRT (C runtime) или стандартной библиотеки и гладко интегрируются с собственными типами attoboy, особенно с `String`.

Вкратце, эти функции охватывают:

* **Точку входа приложения и управление процессом**

  * `atto_main()` – пользовательская точка входа для программ attoboy.
  * `Exit()` – завершить процесс с кодом выхода.
  * `Sleep()` – приостановить текущий поток.

* **Информацию об окружении и процессе**

  * `GetEnv()` / `SetEnv()` – переменные окружения.
  * `GetUserName()` / `GetUserDisplayName()` – информация о текущем пользователе.
  * `GetProcessId()` – идентификатор текущего процесса.

* **Управление памятью**

  * `Alloc()` / `Realloc()` / `Free()` – выделение кучи без CRT.

* **Подсистема логирования**

  * `EnableLoggingToFile()` / `EnableLoggingToConsole()` – выбор места для логов.
  * `Log()`, `LogDebug()`, `LogInfo()`, `LogWarning()`, `LogError()` – API логирования с учётом уровня серьёзности.

Эти утилиты намеренно минимальны, но достаточно мощны, чтобы покрыть большинство потребностей в небольших утилитах и инструментах.

### Системные концепции

Прежде чем погружаться в справочник, полезно прояснить несколько системных идей, которые инкапсулируют эти функции.

#### Процессы и коды выхода

Процесс — это запущенный экземпляр программы, управляемый операционной системой. Когда ваша программа завершает работу, она возвращает ОС **код выхода** (также называемый «кодом возврата» или «статус-кодом»):

* `0` обычно означает **успех**.
* Ненулевые значения указывают на разные **условия ошибки** или причины неуспеха.

`Exit(int exitCode)` в attoboy предоставляет простой и явный способ завершить текущий процесс с выбранным кодом выхода.

#### Переменные окружения

Переменная окружения — это именованная пара ключ–значение, которая:

* Ассоциирована с процессом.
* Наследуется дочерними процессами (если не изменена).
* Часто хранит конфигурацию, например `PATH`, `HOME`, ключи API или настройки приложений.

attoboy предоставляет доступ к окружению через:

* `GetEnv(name)` – чтение переменной.
* `SetEnv(name, value)` – установка или изменение переменной.

Обе используют `String` для имён и значений, что облегчает их использование вместе с другими API attoboy.

#### Управление памятью в куче

В типичных C++ программах вы можете выделять память с помощью `new`/`delete` или `malloc`/`free`. В attoboy, чтобы уменьшить размер бинарников и избежать зависимости от CRT, вы используете:

* `Alloc(size)` – выделяет блок `size` байт.
* `Realloc(ptr, size)` – изменяет размер ранее выделенного блока.
* `Free(ptr)` – освобождает память.

Эти функции ведут себя аналогично своим CRT-эквивалентам, но предоставляются самой библиотекой attoboy. Они возвращают указатели `void *` и являются **безопасными для null**, где это описано.

#### Логирование, уровни логов и места назначения

Логирование — это запись информации о поведении вашей программы в **место назначения**, такое как:

* Консоль (стандартный вывод).
* Файл журнала на диске.

Подсистема логирования attoboy состоит из трёх основных частей:

1. **Конфигурация места назначения логов**

   * `EnableLoggingToFile(path, truncate)` – отправлять логи в файл.
   * `EnableLoggingToConsole()` – отправлять логи в консоль (по умолчанию).

   Одно место назначения активно одновременно; переключение является **глобальным** для процесса.

2. **Функции логирования по уровням серьёзности**

   * `Log()` – общее логирование без префикса уровня.
   * `LogDebug()` – сообщения уровня Debug.
   * `LogInfo()` – информационные сообщения.
   * `LogWarning()` – предупреждения.
   * `LogError()` – ошибки.

   Все они принимают любое количество аргументов, и каждый аргумент внутри конвертируется в `String`. Символ новой строки добавляется автоматически, поэтому вам не нужно вручную добавлять `"\n"`.

3. **Выбор уровня логирования во время компиляции (макросы)**

   В заголовке описан выбор уровня логирования через препроцессорные defines:

   * `ATTOBOY_LOG_DEBUG_ENABLE`   – включает Debug, Info, Warning, Error.
   * `ATTOBOY_LOG_INFO_ENABLE`    – включает Info, Warning, Error (по умолчанию).
   * `ATTOBOY_LOG_WARNING_ENABLE` – включает Warning, Error.
   * `ATTOBOY_LOG_ERROR_ENABLE`   – включает только Error.
   * `ATTOBOY_LOG_DISABLE`        – отключает всё логирование.

   Определите **один** из этих макросов (или `ATTOBOY_LOG_DISABLE`) **до** включения `attoboy.h` в единице трансляции, чтобы контролировать, какие функции логирования будут скомпилированы:

   * Вызовы для отключённых уровней компилируются и не создают накладных расходов во время выполнения.
   * Если вы ничего не определяете и не отключаете логирование, по умолчанию используется `ATTOBOY_LOG_INFO_ENABLE`.

Функции логирования используют внутренний помощник для добавления префиксов с отметками времени и, для логов с уровнями, тэгов уровней вроде `"DEBUG YYYY-MM-DDTHH:MM:SS.fffZ: ..."`. Вам не нужно форматировать отметки времени самостоятельно.

---

#### `atto_main`

Сигнатура

```cpp
extern "C" void atto_main();
```

Краткое описание
Точка входа приложения. Определите этот метод вместо `main()`.

Параметры

* *(нет; вы должны определить эту функцию в вашей программе)*

Возвращаемое значение

* *(функция, которую вы определяете; вызывается средой выполнения)*

Подробно

attoboy заменяет привычную точку входа `int main()` на пользовательскую функцию:

* Вы **определяете** `atto_main()` в своей программе.
* Среда выполнения attoboy обеспечивает вызов `atto_main()` при старте процесса.
* Поскольку `atto_main()` возвращает `void`, используйте `Exit(exitCode)`, если вам нужен конкретный код выхода.

Такая конструкция позволяет библиотеке контролировать процесс инициализации и завершения и избегать зависимостей от CRT, что помогает уменьшить размер бинарников.

Пример

```cpp
using namespace attoboy;

void atto_main() {
  EnableLoggingToConsole();
  LogInfo("Application started; user = ", GetUserName());

  // ... логика вашей программы здесь ...

  Exit(0);
}
```

*В этом примере определяется `atto_main()`, включается логирование в консоль, записывается сообщение о старте и затем происходит выход с кодом 0.*

---

#### `Exit(int exitCode = 0)`

Сигнатура

```cpp
void Exit(int exitCode = 0);
```

Краткое описание
Завершает процесс с указанным кодом выхода.

Параметры

* `exitCode` – числовой статус-код, возвращаемый операционной системе. `0` обычно означает успех; ненулевые коды указывают на разные состояния ошибки.

Возвращаемое значение

* *(нет; не возвращает управление вызывающему)*

Подробно

`Exit()` немедленно завершает текущий процесс:

* Управление не возвращается вызывающему.
* Код выхода виден shell-скриптам, родительским процессам или другим инструментам, которые запускают вашу программу.
* Используйте `Exit(0)` для нормального завершения и ненулевые значения для обозначения конкретных состояний ошибки.

Поскольку `Exit()` не возвращает управление, вам следует:

* Выполнить необходимую очистку (закрыть файлы, сбросить логи) **до** вызова, или обеспечить, чтобы ресурсы были обработаны RAII-объектами, которые будут очищены автоматически.

Пример

```cpp
using namespace attoboy;

if (!Path::GetWorkingDirectory().exists()) {
  LogError("Current working directory does not exist; exiting.");
  Exit(1);
}
```

*В этом примере логируется ошибка и происходит выход с ненулевым кодом, если проверка основного условия не выполняется.*

---

#### `Sleep(int milliseconds)`

Сигнатура

```cpp
void Sleep(int milliseconds);
```

Краткое описание
Приостанавливает текущий поток на указанное количество миллисекунд.

Параметры

* `milliseconds` – продолжительность приостановки текущего потока в миллисекундах. Неотрицательное значение.

Возвращаемое значение

* *(нет)*

Подробно

`Sleep()` приостанавливает **текущий поток** примерно на указанный интервал. Это полезно для:

* Ограничения скорости выполнения в циклах.
* Реализации простых повторных попыток.
* Ожидания внешнего процесса или ресурса без активного ожидания.

Фактическое время паузы может быть немного больше запрошенного из-за планирования в системе.

Пример

```cpp
using namespace attoboy;

// Простой цикл повторных попыток с задержкой 100 мс между попытками.
int attempts = 0;
while (attempts < 3) {
  String response = WebRequest("https://example.com").doGet(1000).asString();
  if (!response.isEmpty()) {
    break;
  }
  attempts++;
  Sleep(100);  // подождать 100 мс перед следующей попыткой
}
```

*В этом примере выполняется до трёх попыток веб-запроса с паузой между попытками.*

---

#### `String GetEnv(const String &name)`

Сигнатура

```cpp
String GetEnv(const String &name);
```

Краткое описание
Возвращает значение переменной окружения или пустую строку, если она не установлена.

Параметры

* `name` – имя переменной окружения для чтения (например, `"PATH"` или `"HOME"`).

Возвращаемое значение

* `String`, содержащая значение переменной, если она существует; иначе пустой `String`.

Подробно

`GetEnv()` предоставляет доступ к окружению процесса:

* Если `name` существует, возвращаемый `String` содержит его значение.
* Если `name` **не** существует, функция возвращает пустой `String`.

Поскольку переменная окружения легитимно может быть установлена в пустую строку, ваш код должен различать «отсутствует» и «присутствует, но пустая» при необходимости (например, проверяя значение по умолчанию или явно вызывая `SetEnv()` ранее в программе).

Пример

```cpp
using namespace attoboy;

String apiKey = GetEnv("MY_APP_API_KEY");
if (apiKey.isEmpty()) {
  LogWarning("MY_APP_API_KEY is not set; using limited mode.");
} else {
  LogInfo("Using configured API key.");
}
```

*В этом примере считывается переменная окружения и выводится предупреждение, если она не установлена.*

---

#### `bool SetEnv(const String &name, const String &value)`

Сигнатура

```cpp
bool SetEnv(const String &name, const String &value);
```

Краткое описание
Устанавливает переменную окружения. Возвращает true при успехе.

Параметры

* `name` – имя переменной окружения для установки или обновления.
* `value` – значение, которое присваивается переменной.

Возвращаемое значение

* `true`, если переменная окружения успешно установлена; `false` в противном случае.

Подробно

`SetEnv()` изменяет окружение для **текущего процесса** и, как правило, для дочерних процессов, запускаемых после изменения.

Примеры использования:

* Переопределение конфигурации для подпроцессов.
* Передача конфигурации инструментам, ожидающим данные через переменные окружения.

Ограничения и замечания:

* Не все имена или значения допустимы на всех системах; чрезвычайно длинные имена/значения или недопустимые символы могут привести к неудаче `SetEnv()`.
* Изменение окружения не влияет задним числом на уже запущенные дочерние процессы.

Пример

```cpp
using namespace attoboy;

if (!SetEnv("MY_APP_MODE", "test")) {
  LogError("Failed to set MY_APP_MODE environment variable.");
} else {
  LogInfo("MY_APP_MODE set to 'test'.");
}
```

*В этом примере устанавливается переменная окружения и логируется результат операции.*

---

#### `void *Alloc(int size)`

Сигнатура

```cpp
void *Alloc(int size);
```

Краткое описание
Выделяет память. Возвращает nullptr при неудаче.

Параметры

* `size` – количество байт для выделения в куче. Обычно неотрицательное.

Возвращаемое значение

* Указатель на блок памяти размером не менее `size` байт или `nullptr`, если выделение не удалось.

Подробно

`Alloc()` — это низкоуровневый аллокатор attoboy, аналогичный `malloc()`, но предоставляемый самой библиотекой. Основные моменты:

* Возвращённый указатель неинициализирован; содержимое неопределено.
* В конце вы обязаны освободить память с помощью `Free(ptr)`.
* Если `size` равен `0`, поведение зависит от реализации; следует избегать таких запросов, если вы не готовы обработать `nullptr`.

Хотя attoboy поощряет использование своих высокоуровневых типов (`String`, `List`, `Buffer` и т.д.), `Alloc()` доступен для специальных случаев, например для взаимодействия с API, ожидающими сырые указатели, или для реализации пользовательских структур данных.

Пример

```cpp
using namespace attoboy;

int size = 256;
void *buffer = Alloc(size);
if (buffer == nullptr) {
  LogError("Failed to allocate ", size, " bytes.");
  Exit(1);
}

// ... используйте буфер ...

Free(buffer);
```

*В этом примере выделяется буфер размером 256 байт, при неудаче логируется ошибка и происходит выход, после использования буфер освобождается.*

---

#### `void *Realloc(void *ptr, int size)`

Сигнатура

```cpp
void *Realloc(void *ptr, int size);
```

Краткое описание
Перевыделяет память. Возвращает nullptr при неудаче.

Параметры

* `ptr` – указатель, ранее возвращённый `Alloc()` или `Realloc()`, или `nullptr`.
* `size` – новый размер в байтах для выделения.

Возвращаемое значение

* Указатель на изменённый блок памяти, который может находиться по другому адресу, или `nullptr`, если перевыделение не удалось.

Подробно

`Realloc()` изменяет размер существующего выделения:

* Если `ptr` равен `nullptr`, `Realloc(ptr, size)` ведёт себя как `Alloc(size)`.
* Если операция успешна:

  * Оригинальная память освобождается, если требуется перемещение.
  * Возвращённый указатель указывает на блок с новым размером.
* Если операция не удалась:

  * Возвращается `nullptr`.
  * Оригинальный `ptr` остаётся **валидным**; вы по-прежнему должны вызвать `Free(ptr)` при необходимости.

Всегда присваивайте результат во временную переменную, пока не убедитесь, что перевыделение прошло успешно, чтобы не потерять исходный указатель:

```cpp
void *newPtr = Realloc(ptr, newSize);
if (newPtr != nullptr) {
  ptr = newPtr;
}
```

Пример

```cpp
using namespace attoboy;

int size = 128;
void *data = Alloc(size);
// ... со временем нужно больше места ...
int newSize = 256;
void *resized = Realloc(data, newSize);
if (resized == nullptr) {
  LogError("Failed to grow buffer from ", size, " to ", newSize, " bytes.");
  Free(data);  // все равно нужно освободить исходный
  Exit(1);
}
data = resized;
// используйте data с newSize байт...

Free(data);
```

*В этом примере безопасно изменяется размер буфера и обрабатывается отказ перевыделения.*

---

#### `void Free(void *ptr)`

Сигнатура

```cpp
void Free(void *ptr);
```

Краткое описание
Освобождает выделенную память (безопасно для nullptr).

Параметры

* `ptr` – указатель, возвращённый `Alloc()` или `Realloc()`, или `nullptr`.

Возвращаемое значение

* *(нет)*

Подробно

`Free()` освобождает память, ранее выделенную `Alloc()` или `Realloc()`:

* Передача `nullptr` явно безопасна и не имеет эффекта.
* После вызова `Free(ptr)` указатель становится недействительным; нельзя читать или записывать по нему.
* Хорошая практика — присваивать указателю `nullptr` после освобождения, чтобы избежать случайного повторного использования.

Пример

```cpp
using namespace attoboy;

void *buffer = Alloc(512);
// ... используйте буфер ...
Free(buffer);
buffer = nullptr;
```

*В этом примере выделяется и затем безопасно освобождается блок памяти.*

---

#### `String GetUserName()`

Сигнатура

```cpp
String GetUserName();
```

Краткое описание
Возвращает логин текущего пользователя.

Параметры

* *(нет)*

Возвращаемое значение

* `String`, содержащий имя учётной записи (например, имя пользователя, использованное для входа в ОС).

Подробно

`GetUserName()` получает **идентификатор входа** пользователя, запускающего процесс. Обычно это короткое имя учётной записи (например, `"jdoe"`). Это полезно для:

* Персонализации вывода в консоль.
* Включения идентичности пользователя в логи или пути к файлам.
* Пометки данных текущим пользователем.

Если имя получить не удаётся, функция может вернуть пустую строку.

Пример

```cpp
using namespace attoboy;

String user = GetUserName();
LogInfo("Running as user: ", user);
```

*В этом примере логируется имя пользователя, от имени которого выполняется процесс.*

---

#### `String GetUserDisplayName()`

Сигнатура

```cpp
String GetUserDisplayName();
```

Краткое описание
Возвращает отображаемое (френдли) имя текущего пользователя.

Параметры

* *(нет)*

Возвращаемое значение

* `String`, содержащий отображаемое имя пользователя (например, `"John Doe"`), или пустую строку, если оно недоступно.

Подробно

`GetUserDisplayName()` возвращает **читаемое человеком**, дружелюбное имя для текущей учётной записи пользователя, если оно доступно. Это может отличаться от логина:

* Логин: `"jdoe"`
* Отображаемое имя: `"John Doe"`

Используйте это в сообщениях для пользователя, заголовках или логах, где важна читаемость.

Пример

```cpp
using namespace attoboy;

String display = GetUserDisplayName();
if (!display.isEmpty()) {
  LogInfo("Welcome, ", display, "!");
}
```

*В этом примере отображаемое имя используется в приветствии.*

---

#### `int GetProcessId()`

Сигнатура

```cpp
int GetProcessId();
```

Краткое описание
Возвращает идентификатор текущего процесса.

Параметры

* *(нет)*

Возвращаемое значение

* Целочисленный идентификатор текущего процесса, присвоенный операционной системой.

Подробно

Идентификатор процесса (PID) уникально идентифицирует выполняющийся процесс в системе в конкретный момент времени. `GetProcessId()` возвращает это значение, что полезно для:

* Пометки строк логов, когда несколько процессов пишут в одно место.
* Отладки и диагностики (например, корреляции логов с внешним монитором процессов).

Пример

```cpp
using namespace attoboy;

int pid = GetProcessId();
LogInfo("Process ID: ", pid);
```

*В этом примере логируется ID текущего процесса для диагностических целей.*

---

#### `void EnableLoggingToFile(const String &path, bool truncate = false)`

Сигнатура

```cpp
void EnableLoggingToFile(const String &path, bool truncate = false);
```

Краткое описание
Включает логирование в файл. Взаимно исключает логирование в консоль.

Параметры

* `path` – путь к файлу, в который должны записываться сообщения журнала.
* `truncate` – если `true`, файл лога очищается перед записью. Если `false`, сообщения добавляются в конец существующего файла.

Возвращаемое значение

* *(нет)*

Подробно

`EnableLoggingToFile()` настраивает **глобальное место назначения логов** на файл:

* После вызова все последующие вызовы `Log()`, `LogDebug()`, `LogInfo()`, `LogWarning()` и `LogError()` пишут в указанный файл.
* Логирование в консоль отключается, пока активно логирование в файл; эти режимы взаимоисключающие.
* Если файл не удаётся создать или открыть, поведение зависит от реализации; обычно рекомендуется залогировать сообщение в консоль до переключения или удостовериться в корректности через тест.

Поскольку логирование глобально, обычно это делают **рано** в программе, часто в `atto_main()`.

Пример

```cpp
using namespace attoboy;

void atto_main() {
  // Начинать с чистого лог-файла при каждом запуске.
  EnableLoggingToFile("my_app.log", true);

  LogInfo("Logging to my_app.log; PID = ", GetProcessId());
  // ...
}
```

*В этом примере место назначения логов переключается на файл и записывается сообщение о старте.*

---

#### `void EnableLoggingToConsole()`

Сигнатура

```cpp
void EnableLoggingToConsole();
```

Краткое описание
Включает логирование в консоль (по умолчанию). Взаимно исключает логирование в файл.

Параметры

* *(нет)*

Возвращаемое значение

* *(нет)*

Подробно

`EnableLoggingToConsole()` настраивает **глобальное место назначения логов** на консоль:

* Обычно это поведение по умолчанию при инициализации библиотеки.
* Вызов `EnableLoggingToConsole()` переключает логирование с любого ранее настроенного файла обратно в консоль.

Используйте это, когда:

* Вы хотите, чтобы сообщения логов выводились непосредственно в терминал.
* Вы ранее переключились на логирование в файл и хотите вернуться к консоли.

Пример

```cpp
using namespace attoboy;

void atto_main() {
  EnableLoggingToConsole();
  LogInfo("Console logging enabled.");

  // Позже, если вы захотите переключиться на логирование в файл:
  EnableLoggingToFile("later.log", false);
  LogInfo("Now logging to later.log.");
}
```

*В этом примере сначала включено логирование в консоль, а затем в ходе выполнения переключается на файл.*

---

### Функции логирования

> Все функции логирования — это **вариативные шаблоны**, принимающие любое количество аргументов. Каждый аргумент внутри конвертируется в `String` с помощью конструкторов `String`, поэтому вы можете логировать значения многих типов: `String`, `const char *`, `int`, `float`, `bool`, `List`, `Map`, `Set` и т.д.

#### `template <typename... Args> void Log(const Args &...args)`

Сигнатура

```cpp
template <typename... Args> void Log(const Args &...args);
```

Краткое описание
Выводит аргументы в назначение логов с последующим переводом строки.

Параметры

* `args` – ноль или более значений для логирования. Каждое значение должно быть конструктивно совместимо с `attoboy::String`.

Возвращаемое значение

* *(нет)*

Подробно

`Log()` — базовая функция логирования:

* Она не добавляет префикс уровня (например, `"INFO"` или `"ERROR"`).
* Просто конкатенирует все аргументы, преобразует их в `String` и записывает результат как одну строку в текущее место назначения логов (консоль или файл), затем добавляет перевод строки.

Поведение в связке с макросами:

* `Log()` полностью **отключается**, если определён `ATTOBOY_LOG_DISABLE`.
* Если логирование включено, вызовы `Log()` всегда активны, независимо от макросов уровня логирования, таких как `ATTOBOY_LOG_INFO_ENABLE`.

Если вызвать `Log()` без аргументов, будет всё равно записан перевод строки (возможно с меткой времени или другим форматированием, в зависимости от реализации).

Пример

```cpp
using namespace attoboy;

Log("Started task ", 1, " for user ", GetUserName());
// Example output: "Started task 1 for user jdoe"
```

*В этом примере записывается простое сообщение, составленное из нескольких аргументов разных типов.*

---

#### `template <typename... Args> void LogDebug(const Args &...args)`

Сигнатура

```cpp
template <typename... Args> void LogDebug(const Args &...args);
```

Краткое описание
Выводит отладочное сообщение: "DEBUG YYYY-MM-DDTHH:MM:SS.fffZ: ..."

Параметры

* `args` – ноль или более значений для включения в отладочное сообщение.

Возвращаемое значение

* *(нет)*

Подробно

`LogDebug()` предназначен для **диагностических сообщений для разработчиков**:

* Сообщения обычно содержат префикс `"DEBUG"` и отметку времени.
* Используйте его для трассировки детального внутреннего состояния, решений алгоритма или значений переменных, полезных при разработке, но слишком шумных для production.

Управление на этапе компиляции:

* `LogDebug()` компилируется только когда определён `ATTOBOY_LOG_DEBUG_ENABLE` (и логирование не отключено).
* Если задан более низкий уровень логирования (например, `ATTOBOY_LOG_INFO_ENABLE`) или `ATTOBOY_LOG_DISABLE`, вызовы `LogDebug()` компилируются в пустоту и не создают накладных расходов во время выполнения.

Пример

```cpp
using namespace attoboy;

int retryCount = 2;
LogDebug("Connecting to server; retryCount = ", retryCount);
```

*В этом примере логируется отладочное сообщение, которое обычно видно только в отладочных сборках.*

---

#### `template <typename... Args> void LogInfo(const Args &...args)`

Сигнатура

```cpp
template <typename... Args> void LogInfo(const Args &...args);
```

Краткое описание
Выводит информационное сообщение: "INFO YYYY-MM-DDTHH:MM:SS.fffZ: ..."

Параметры

* `args` – ноль или более значений для включения в информационное сообщение.

Возвращаемое значение

* *(нет)*

Подробно

`LogInfo()` используется для **высокоуровневых информационных сообщений**:

* Типичные случаи: сообщения о старте, сводки конфигурации, общие обновления прогресса.
* Сообщения имеют префикс `"INFO"` и отметку времени.

Управление на этапе компиляции:

* `LogInfo()` компилируется, когда определён любой из следующих макросов:

  * `ATTOBOY_LOG_DEBUG_ENABLE` **или**
  * `ATTOBOY_LOG_INFO_ENABLE`
    (и логирование не отключено).
* Она исключается из компиляции, когда определены только `ATTOBOY_LOG_WARNING_ENABLE` или `ATTOBOY_LOG_ERROR_ENABLE`, либо когда задан `ATTOBOY_LOG_DISABLE`.

По умолчанию, если вы не определяете макрос уровня логирования и не отключаете логирование, автоматически включается `ATTOBOY_LOG_INFO_ENABLE`, поэтому вызовы `LogInfo()` активны.

Пример

```cpp
using namespace attoboy;

LogInfo("Service started at ", DateTime().toString(),
        "; PID = ", GetProcessId());
```

*В этом примере логируется информационное сообщение о запуске с отметкой времени и PID.*

---

#### `template <typename... Args> void LogWarning(const Args &...args)`

Сигнатура

```cpp
template <typename... Args> void LogWarning(const Args &...args);
```

Краткое описание
Выводит предупреждение: "WARNING YYYY-MM-DDTHH:MM:SS.fffZ: ..."

Параметры

* `args` – ноль или более значений, описывающих предупреждение.

Возвращаемое значение

* *(нет)*

Подробно

`LogWarning()` предназначен для условий, которые необычны или потенциально проблемны, но не являются немедленно фатальными:

* Примеры: откаты конфигурации, восстанавливаемые ошибки, ухудшение производительности.
* Сообщения имеют префикс `"WARNING"` и отметку времени.

Управление на этапе компиляции:

* `LogWarning()` компилируется, когда определён любой из следующих макросов:

  * `ATTOBOY_LOG_DEBUG_ENABLE`
  * `ATTOBOY_LOG_INFO_ENABLE`
  * `ATTOBOY_LOG_WARNING_ENABLE`
* Она исключается из компиляции только когда:

  * `ATTOBOY_LOG_ERROR_ENABLE` — единственный заданный макрос уровня, или
  * задан `ATTOBOY_LOG_DISABLE`.

Пример

```cpp
using namespace attoboy;

String configPath("config.json");
Path cfg(configPath);

if (!cfg.exists()) {
  LogWarning("Config file ", configPath, " not found; using defaults.");
}
```

*В этом примере логируется предупреждение, когда файл конфигурации отсутствует, но программа может продолжить работу с настройками по умолчанию.*

---

#### `template <typename... Args> void LogError(const Args &...args)`

Сигнатура

```cpp
template <typename... Args> void LogError(const Args &...args);
```

Краткое описание
Выводит сообщение об ошибке: "ERROR YYYY-MM-DDTHH:MM:SS.fffZ: ..."

Параметры

* `args` – ноль или более значений, описывающих ошибку.

Возвращаемое значение

* *(нет)*

Подробно

`LogError()` предназначен для **ошибок** и серьёзных проблем:

* Используйте его, когда операция завершается с ошибкой и может потребовать внимания или завершения работы.
* Сообщения имеют префикс `"ERROR"` и отметку времени.

Управление на этапе компиляции:

* `LogError()` активна при всех конфигурациях уровня логирования **за исключением** случая, когда задан `ATTOBOY_LOG_DISABLE`.
* Иными словами, если вы не отключаете логирование полностью, сообщения об ошибках всегда доступны.

Типичный шаблон:

* Зарегистрировать ошибку через `LogError()`.
* При необходимости завершить программу через `Exit(exitCode)`.

Пример

```cpp
using namespace attoboy;

File f(Path("data.bin"));
if (!f.isValid()) {
  LogError("Failed to open data.bin for reading.");
  Exit(2);
}
```

*В этом примере логируется ошибка при невозможности открыть файл и затем выполняется выход с ненулевым кодом.*