# Path

## Обзор

Класс `attoboy::Path` представляет собой **неизменяемый путь файловой системы** с большим набором вспомогательных методов для:

* Проверки того, на что указывает путь (файл, каталог, символическая ссылка и т.д.).
* Запроса метаданных, таких как размер, временные метки и атрибуты.
* Выполнения операций с файловой системой (создание каталогов, перемещение/копирование/удаление файлов).
* Чтения и записи файлов с помощью удобных помощников.
* Обнаружения системных расположений (домашний каталог, «Документы», временные файлы и т.д.).

Он спроектирован для небольших утилит под Windows, но скрывает большинство низкоуровневых деталей. `Path` по сути является **объектом-значением**, который содержит строковое представление пути и предоставляет высокоуровневые операции вокруг него. Текстовое представление пути не изменяется после создания экземпляра `Path`; такие операции, как `moveTo()`, изменяют файловую систему, а не сам объект `Path`.

### Понятия файловой системы

Если вы не очень знакомы с терминологией файловой системы, ниже приведены ключевые понятия, с которыми работает `Path`:

* **Обычный файл**: Обычный файл, в котором хранится данные (например, `config.txt`).
* **Каталог**: Папка, которая может содержать файлы и другие каталоги.
* **Именованный канал (named pipe)**: Специальный объект, похожий на файл, используемый для межпроцессного взаимодействия.
* **Символическая ссылка (symlink)**: Ссылка, указывающая на другой путь. Обращение к символической ссылке обычно затрагивает её цель.
* **Атрибуты файла**: Флаги, такие как «только для чтения» или «скрытый».
* **Текущий рабочий каталог**: Каталог, используемый как база для относительных путей.
* **Том**: Диск, например `C:` или `D:` в Windows.

Класс `Path` позволяет вам перемещаться по дереву, инспектировать и манипулировать этими сущностями, сохраняя код компактным и читабельным.

### Неизменяемость и семантика значения

`Path` является **неизменяемым** в отношении своего текстового представления:

* После создания `Path` его внутренняя строка не меняется.
* Операции, такие как `moveTo()` или `deleteFile()`, воздействуют на запись в файловой системе, на которую указывает путь, но не изменяют сам объект `Path`.
* Копирование и присваивание экземпляров `Path` дешёвы и безопасны; они все представляют одно и то же текстовое значение пути.

Это упрощает передачу путей по приложению без опасений случайного изменения хранимой строковой формы пути.

---

## Справочник

Каждый раздел ниже охватывает один публичный конструктор, метод, статическую функцию или оператор `attoboy::Path`.

Для каждого члена вы найдёте:

* **Сигнатура** – точное объявление из заголовочного файла.
* **Краткое описание** – оригинальная однострочная Doxygen-документация.
* **Параметры** и **Возвращаемое значение**.
* **Подробно** – назначение, поведение, оговорки и короткий пример.

Все примеры предполагают:

```cpp
using namespace attoboy;
```

---

#### `Path(const String &pathStr)`

**Сигнатура**

```cpp
Path(const String &pathStr);
```

**Краткое описание**
Создаёт путь из строки.

**Параметры**

* `pathStr` – Текстовое представление пути (абсолютное или относительное), обычно в стиле Windows, например `"C:\\temp\\file.txt"`.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Это основной способ построения `Path`. Строка сохраняется "как есть"; `Path` не нормализует и не канонизирует её автоматически. Одна и та же текстовая форма пути последовательно будет ссылаться на одно и то же файловое имя при интерпретации операционной системой.

Вы можете передать либо явный `String`, либо строковый литерал благодаря конструктору `String`:

```cpp
Path p("C:\\temp\\log.txt");  // implicit String construction
```

Путь может быть:

* **Абсолютным**, включая букву диска (`"C:\\users\\alice\\file.txt"`).
* **Относительным**, интерпретируемым относительно текущего рабочего каталога (`"logs\\today.txt"`).

**Пример**

```cpp
Path configPath("C:\\myapp\\config.json");
bool exists = configPath.exists();
```

*Этот пример создаёт путь из литерала и проверяет, существует ли файл.*

---

#### `Path(const Path &other)`

**Сигнатура**

```cpp
Path(const Path &other);
```

**Краткое описание**
Создаёт копию другого пути.

**Параметры**

* `other` – Существующий `Path`, который нужно скопировать.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Конструктор копирования создаёт новый `Path` с идентичным содержимым и поведением, как у `other`. Поскольку `Path` неизменяем в отношении своей строки, копии безопасно совместно использовать и применять в разных частях кода.

**Пример**

```cpp
Path original("C:\\data\\input.txt");
Path copy(original);

bool same = copy.equals(original);  // true
```

*Этот пример копирует путь и подтверждает, что оба экземпляра представляют одно и то же место.*

---

#### `~Path()`

**Сигнатура**

```cpp
~Path();
```

**Краткое описание**
Уничтожает путь и освобождает память.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробно**

Когда `Path` выходит из области видимости, его деструктор освобождает внутренние ресурсы (например, динамическую память для внутренней строки). Никаких автоматических изменений в файловой системе не происходит; путь просто перестаёт быть доступен из вашего кода.

**Пример**

```cpp
{
  Path temp("C:\\temp\\file.tmp");
  // Use temp here...
}
// temp is destroyed here; no automatic file deletion occurs.
```

*Этот пример показывает окончание срока жизни `Path` без воздействия на сам файл.*

---

#### `Path &operator=(const Path &other)`

**Сигнатура**

```cpp
Path &operator=(const Path &other);
```

**Краткое описание**
Присваивает этому пути значение другого пути.

**Параметры**

* `other` – `Path`, значение которого должно быть присвоено этому экземпляру.

**Возвращаемое значение**

* Ссылка на `*this`, позволяющая цепочные присваивания.

**Подробно**

Оператор присваивания заменяет текущее значение пути значением `other`. После присваивания оба объекта `Path` представляют одну и ту же текстовую форму пути и будут вести себя одинаково при последующих операциях.

Самоприсваивание безопасно.

**Пример**

```cpp
Path p("C:\\old\\file.txt");
Path q("C:\\new\\file.txt");

p = q;  // p now refers to "C:\\new\\file.txt"
```

*Этот пример переназначает переменную `Path`, чтобы она указывала на новое местоположение.*

---

#### `bool exists() const`

**Сигнатура**

```cpp
bool exists() const;
```

**Краткое описание**
Возвращает true, если путь существует в файловой системе.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если путь в данный момент указывает на существующий объект файловой системы; иначе `false`.

**Подробно**

`exists()` проверяет, указывает ли путь на что-либо, распознаваемое файловой системой: обычный файл, каталог, символическую ссылку, именованный канал или другой специальный файл.

Это хороший первый шаг перед вызовом операций, таких как `getSize()`, `readToString()` или `listChildren()`.

**Пример**

```cpp
Path logPath("C:\\logs\\today.log");
if (!logPath.exists()) {
  logPath.writeFromString("Log created.\n");
}
```

*Этот пример создаёт новый файл журнала только если он ещё не существует.*

---

#### `bool isRegularFile() const`

**Сигнатура**

```cpp
bool isRegularFile() const;
```

**Краткое описание**
Возвращает true, если путь указывает на обычный файл.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если путь существует и указывает на обычный файл; иначе `false`.

**Подробно**

Эта функция отличает обычные файлы данных (например, текстовые файлы, бинарники) от каталогов или специальных типов. Если путь не существует, возвращается `false`.

Используйте её, когда нужно убедиться, что вы имеете дело с файлом перед чтением или записью его содержимого.

**Пример**

```cpp
Path candidate("C:\\data\\input.txt");
if (candidate.isRegularFile()) {
  String contents = candidate.readToString();
}
```

*Этот пример читает файл только если путь указывает на обычный файл.*

---

#### `bool isDirectory() const`

**Сигнатура**

```cpp
bool isDirectory() const;
```

**Краткое описание**
Возвращает true, если путь указывает на каталог.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если путь существует и является каталогом; иначе `false`.

**Подробно**

`isDirectory()` проверяет, указывает ли путь на каталог (папку). Каталоги можно перечислять с помощью `listChildren()` и создавать через `makeDirectory()`.

**Пример**

```cpp
Path folder("C:\\data");
if (!folder.isDirectory()) {
  folder.makeDirectory(true);
}
```

*Этот пример рекурсивно создаёт каталог, если он ещё не существует как каталог.*

---

#### `bool isNamedPipe() const`

**Сигнатура**

```cpp
bool isNamedPipe() const;
```

**Краткое описание**
Возвращает true, если путь является именованным каналом.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если путь существует и идентифицирован как именованный канал; иначе `false`.

**Подробно**

Именованные каналы используются для межпроцессного взаимодействия. Эта проверка полезна в специализированных сценариях, когда путь может ссылаться либо на файл, либо на канал.

**Пример**

```cpp
Path p("\\\\.\\pipe\\myapp");
bool pipeExists = p.isNamedPipe();
```

*Этот пример проверяет, существует ли конкретный именованный канал.*

---

#### `bool isSymbolicLink() const`

**Сигнатура**

```cpp
bool isSymbolicLink() const;
```

**Краткое описание**
Возвращает true, если путь является символической ссылкой.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если путь существует и является символической ссылкой; иначе `false`.

**Подробно**

Символические ссылки (symlink) — это записи, указывающие на другие пути. Они могут ссылаться на файлы или каталоги. Используйте `getSymbolicLinkTarget()` для получения целевого пути.

**Пример**

```cpp
Path p("C:\\shortcut.lnk");
if (p.isSymbolicLink()) {
  Path target = p.getSymbolicLinkTarget();
}
```

*Этот пример обнаруживает символическую ссылку и затем получает её целевой путь.*

---

#### `bool isOther() const`

**Сигнатура**

```cpp
bool isOther() const;
```

**Краткое описание**
Возвращает true, если путь относится к устройству или другому специальному файлу.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если путь ссылается на объект файловой системы, который не является ни обычным файлом, ни каталогом, ни именованным каналом, ни символической ссылкой; иначе `false`.

**Подробно**

Эта функция обрабатывает оставшиеся типы объектов файловой системы, такие как устройства или другие специфические для платформы записи. Для большинства прикладных сценариев вы в основном будете использовать `isRegularFile()` и `isDirectory()`.

**Пример**

```cpp
Path p("C:\\Device\\SomeSpecialObject");
bool special = p.isOther();
```

*Этот пример проверяет, относится ли путь к специальному объекту файловой системы.*

---

#### `long long getSize() const`

**Сигнатура**

```cpp
long long getSize() const;
```

**Краткое описание**
Возвращает размер файла в байтах (0, если недоступно).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Размер в байтах, если доступен; `0`, если размер не может быть определён (например, путь не существует или не является обычным файлом).

**Подробно**

`getSize()` имеет смысл прежде всего для обычных файлов. Для каталогов или специальных файлов размер может быть бессмысленным или возвращаться как `0`.

Чтобы избежать неоднозначности, сначала вызывайте `isRegularFile()`, когда вам нужен размер файла.

**Пример**

```cpp
Path filePath("C:\\data\\report.pdf");
if (filePath.isRegularFile()) {
  long long bytes = filePath.getSize();
}
```

*Этот пример получает размер обычного файла, если он существует.*

---

#### `DateTime getCreatedOn() const`

**Сигнатура**

```cpp
DateTime getCreatedOn() const;
```

**Краткое описание**
Возвращает время создания.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `DateTime`, представляющий момент создания объекта файловой системы.

**Подробно**

Возвращённый `DateTime` отражает представление файловой системы о времени создания. Если путь не существует или метаданные не могут быть получены, результат будет соответствовать определённому реализацией значению по умолчанию; лучшая практика — сначала вызывать `exists()`.

**Пример**

```cpp
Path p("C:\\data\\file.txt");
if (p.exists()) {
  DateTime created = p.getCreatedOn();
  String iso = created.toString();
}
```

*Этот пример получает и форматирует время создания файла.*

---

#### `DateTime getModifiedOn() const`

**Сигнатура**

```cpp
DateTime getModifiedOn() const;
```

**Краткое описание**
Возвращает время последнего изменения.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `DateTime`, указывающий последний момент изменения содержимого файла или каталога.

**Подробно**

Эта временная метка обычно обновляется при изменении данных файла или записей каталога. Как и с другими метаданными, сначала вызывайте `exists()`, чтобы не полагаться на неопределённые результаты.

**Пример**

```cpp
Path p("C:\\data\\log.txt");
if (p.exists()) {
  DateTime lastModified = p.getModifiedOn();
}
```

*Этот пример получает время последнего изменения файла.*

---

#### `DateTime getAccessedOn() const`

**Сигнатура**

```cpp
DateTime getAccessedOn() const;
```

**Краткое описание**
Возвращает время последнего доступа.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `DateTime`, представляющий момент последнего доступа к файлу или каталогу.

**Подробно**

Эта временная метка может указывать, когда файл в последний раз был открыт или прочитан, хотя некоторые системы или настройки могут отключать или задерживать обновление времени доступа для повышения производительности.

**Пример**

```cpp
Path p("C:\\data\\file.txt");
if (p.exists()) {
  DateTime lastAccessed = p.getAccessedOn();
}
```

*Этот пример читает время последнего доступа к файлу, если оно доступно.*

---

#### `bool isReadOnly() const`

**Сигнатура**

```cpp
bool isReadOnly() const;
```

**Краткое описание**
Возвращает true, если файл помечен как только для чтения.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если у файла или каталога установлен атрибут «только для чтения»; иначе `false`.

**Подробно**

Атрибут «только для чтения» — один из нескольких атрибутов файла в Windows. Когда `isReadOnly()` возвращает `true`, попытки изменить или удалить файл могут завершиться неудачей, если атрибут не снят или не используются соответствующие привилегии.

Для путей, которые не существуют, эта функция обычно возвращает `false`.

**Пример**

```cpp
Path p("C:\\data\\config.ini");
if (p.isReadOnly()) {
  // Decide how to handle this before writing.
}
```

*Этот пример проверяет, помечен ли файл конфигурации как только для чтения.*

---

#### `bool setReadOnly(bool isReadOnly = true) const`

**Сигнатура**

```cpp
bool setReadOnly(bool isReadOnly = true) const;
```

**Краткое описание**
Устанавливает атрибут «только для чтения». Возвращает true при успехе.

**Параметры**

* `isReadOnly` – Если `true`, включает атрибут «только для чтения»; если `false`, снимает его.

**Возвращаемое значение**

* `true`, если атрибут был успешно изменён; `false`, если операция не удалась (например, из‑за отсутствия файла или недостатка прав).

**Подробно**

Эта функция изменяет атрибут «только для чтения» объекта файловой системы, на который указывает путь. Сам объект `Path` при этом остаётся неизменным.

Используйте её, когда нужно защитить файл от случайного изменения или временно снять атрибут «только для чтения» перед записью.

**Пример**

```cpp
Path p("C:\\data\\config.ini");

// Make the configuration file writable.
if (p.isReadOnly()) {
  p.setReadOnly(false);
}
```

*Этот пример обеспечивает возможность записи в файл, сняв атрибут «только для чтения», если это необходимо.*

---

#### `bool isHidden() const`

**Сигнатура**

```cpp
bool isHidden() const;
```

**Краткое описание**
Возвращает true, если файл скрыт.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если объект файловой системы имеет атрибут «скрытый»; иначе `false`.

**Подробно**

Скрытые файлы и каталоги обычно не отображаются по умолчанию в проводниках. Эта функция позволяет обнаруживать такие записи.

Для несуществующих путей результат обычно `false`.

**Пример**

```cpp
Path p("C:\\data\\secret.txt");
bool hidden = p.isHidden();
```

*Этот пример проверяет, помечен ли файл как скрытый.*

---

#### `bool setHidden(bool isHidden = true) const`

**Сигнатура**

```cpp
bool setHidden(bool isHidden = true) const;
```

**Краткое описание**
Устанавливает атрибут «скрытый». Возвращает true при успехе.

**Параметры**

* `isHidden` – Если `true`, устанавливает атрибут «скрытый»; если `false`, снимает его.

**Возвращаемое значение**

* `true`, если атрибут был успешно изменён; иначе `false`.

**Подробно**

Эта функция изменяет атрибут «скрытый» у реального объекта файловой системы. Используйте её, когда хотите скрыть вспомогательные файлы, кэш‑каталоги или внутренние данные от обычных списков каталога.

**Пример**

```cpp
Path cacheDir("C:\\myapp\\cache");
cacheDir.makeDirectory(true);
cacheDir.setHidden(true);
```

*Этот пример создаёт каталог кэша и помечает его как скрытый.*

---

#### `bool moveTo(const Path &dest) const`

**Сигнатура**

```cpp
bool moveTo(const Path &dest) const;
```

**Краткое описание**
Перемещает этот путь в место назначения. Возвращает true при успехе.

**Параметры**

* `dest` – Целевой путь, в который следует переместить или переименовать файл или каталог.

**Возвращаемое значение**

* `true`, если операция перемещения/переименования на уровне ОС прошла успешно; иначе `false`.

**Подробно**

`moveTo()` запрашивает у операционной системы перемещение или переименование записи файловой системы, на которую указывает этот `Path`, в `dest`. Типичные причины неудачи включают:

* Исходный объект не существует.
* Невозможно создать целевой объект (например, отсутствует родительский каталог).
* Отказано в доступе.
* Целевой объект уже существует, в зависимости от поведения ОС.

Сам объект `Path` при этом не изменяется; после успешного перемещения `Path` по-прежнему ссылается на старое местоположение, которое обычно больше не существует.

**Пример**

```cpp
Path oldPath("C:\\data\\old\\file.txt");
Path newPath("C:\\data\\new\\file.txt");

if (oldPath.moveTo(newPath)) {
  // The file now lives at newPath.
}
```

*Этот пример перемещает файл из одного каталога в другой.*

---

#### `bool copyTo(const Path &dest) const`

**Сигнатура**

```cpp
bool copyTo(const Path &dest) const;
```

**Краткое описание**
Копирует этот путь в место назначения. Возвращает true при успехе.

**Параметры**

* `dest` – Целевой путь, в который должен быть скопирован файл или каталог.

**Возвращаемое значение**

* `true`, если копирование прошло успешно; иначе `false`.

**Подробно**

`copyTo()` дублирует содержимое исходного пути в целевой:

* Для файлов копируются данные файла.
* Для каталогов поведение может зависеть от реализации (например, рекурсивное копирование каталога или отказ).

Как и в случае с `moveTo()`, экземпляры `Path` остаются неизменными; операция затрагивает только файловую систему.

**Пример**

```cpp
Path source("C:\\data\\report.txt");
Path backup("C:\\backup\\report.txt");

bool ok = source.copyTo(backup);
```

*Этот пример создаёт резервную копию файла.*

---

#### `bool deleteFile() const`

**Сигнатура**

```cpp
bool deleteFile() const;
```

**Краткое описание**
Удаляет файл. Возвращает true при успехе.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если файл был успешно удалён; иначе `false`.

**Подробно**

`deleteFile()` пытается удалить обычный файл по этому пути. Если путь указывает на каталог или специальный объект, операция обычно завершается неудачей. Частые причины неудачи включают:

* Файл не существует.
* Файл открыт в другом процессе.
* Недостаточно прав.

Используйте `exists()` или `isRegularFile()` сначала, если вам нужно различать «файла нет» и другие ошибки.

**Пример**

```cpp
Path tempFile("C:\\temp\\session.tmp");
if (tempFile.exists()) {
  tempFile.deleteFile();
}
```

*Этот пример удаляет временный файл, если он существует.*

---

#### `bool removeDirectory(bool deleteIfNotEmpty = false) const`

**Сигнатура**

```cpp
bool removeDirectory(bool deleteIfNotEmpty = false) const;
```

**Краткое описание**
Удаляет каталог. Возвращает true при успехе.

**Параметры**

* `deleteIfNotEmpty` – Если `false`, удаление обычно успешно только когда каталог пуст. Если `true`, реализация может удалять содержимое по мере необходимости.

**Возвращаемое значение**

* `true`, если каталог был удалён; иначе `false`.

**Подробно**

Эта функция удаляет каталог по этому пути. Когда `deleteIfNotEmpty` установлено в `false` (по умолчанию), удаление обычно удаётся только если каталог пуст. При `true` реализация может рекурсивно удалить содержимое, в зависимости от того, как реализована библиотека.

Как всегда, объект `Path` продолжает представлять ту же текстовую форму пути, даже после удаления каталога.

**Пример**

```cpp
Path tempDir("C:\\temp\\myapp");
tempDir.removeDirectory(true);  // try to delete the directory and its contents
```

*Этот пример пытается удалить временный каталог и всё его содержимое.*

---

#### `bool makeDirectory(bool createParents = true) const`

**Сигнатура**

```cpp
bool makeDirectory(bool createParents = true) const;
```

**Краткое описание**
Создаёт каталог. Возвращает true при успехе.

**Параметры**

* `createParents` – Если `true`, родительские каталоги могут быть созданы по необходимости (аналогично `mkdir -p`). Если `false`, операция обычно требует, чтобы родительский каталог уже существовал.

**Возвращаемое значение**

* `true`, если каталог был успешно создан или уже существует как каталог; иначе `false`.

**Подробно**

Используйте `makeDirectory()`, чтобы гарантировать существование каталога по этому пути. Это часто выполняется при запуске приложения для создания каталогов конфигурации, журналов или кэша.

`createParents = true` удобно для вложенных каталогов, таких как `"C:\\data\\myapp\\logs"`.

**Пример**

```cpp
Path logsDir("C:\\myapp\\logs");
bool ok = logsDir.makeDirectory(true);
```

*Этот пример создаёт вложенный каталог логов, создавая при необходимости отсутствующие родительские папки.*

---

#### `Path getSymbolicLinkTarget() const`

**Сигнатура**

```cpp
Path getSymbolicLinkTarget() const;
```

**Краткое описание**
Возвращает цель символической ссылки или пустой путь, если это не ссылка.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Path`, представляющий цель символической ссылки, или «пустой» `Path`, если этот путь не является символической ссылкой или цель не может быть определена.

**Подробно**

Если `isSymbolicLink()` возвращает `true`, эта функция возвращает путь, на который указывает ссылка. Если путь не является symlink (или разрешение не удалось), возвращаемый `Path` считается пустым (его строковая форма — пустая строка).

**Пример**

```cpp
Path link("C:\\data\\shortcut.lnk");
Path target = link.getSymbolicLinkTarget();

if (!target.toString().isEmpty()) {
  // target refers to the symlink's destination
}
```

*Этот пример разрешает символическую ссылку в её целевой путь, если это возможно.*

---

#### `bool setSymbolicLinkTarget(const Path &target) const`

**Сигнатура**

```cpp
bool setSymbolicLinkTarget(const Path &target) const;
```

**Краткое описание**
Создаёт или обновляет символическую ссылку на указанную цель. Возвращает true при успехе.

**Параметры**

* `target` – Путь, на который должна ссылаться эта символьная ссылка.

**Возвращаемое значение**

* `true`, если символическая ссылка была успешно создана или обновлена; иначе `false`.

**Подробно**

Эта функция настраивает текущий `Path` как символическую ссылку, указывающую на `target`. В зависимости от ОС и конфигурации создание symlink может требовать повышенных привилегий.

Если по этому пути уже существует символическая ссылка, реализация может обновить её так, чтобы она указывала на новую цель.

**Пример**

```cpp
Path linkPath("C:\\data\\shortcut.lnk");
Path targetPath("C:\\data\\realfile.txt");

bool ok = linkPath.setSymbolicLinkTarget(targetPath);
```

*Этот пример создаёт или обновляет символическую ссылку, чтобы она указывала на реальный файл.*

---

#### `String getName() const`

**Сигнатура**

```cpp
String getName() const;
```

**Краткое описание**
Возвращает имя файла (последний компонент пути).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащий последний компонент пути (например, `"file.txt"` или `"folder"`).

**Подробно**

`getName()` возвращает базовое имя пути без родительских директорий. Например:

* `"C:\\folder\\file.txt"` → `"file.txt"`
* `"C:\\folder\\"` → `"folder"` (в зависимости от точной реализации и конечных разделителей)

Используйте `getName()`, когда вам нужно только имя файла или каталога для отображения или логирования.

**Пример**

```cpp
Path p("C:\\data\\report.txt");
String name = p.getName();  // "report.txt"
```

*Этот пример извлекает имя файла из полного пути.*

---

#### `Path getParentDirectory() const`

**Сигнатура**

```cpp
Path getParentDirectory() const;
```

**Краткое описание**
Возвращает путь родительского каталога.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Path`, представляющий каталог, содержащий этот путь.

**Подробно**

`getParentDirectory()` удаляет последний компонент пути, чтобы получить родительский каталог. Точное поведение для корневых путей (например, `"C:\\"`) зависит от реализации; обычно корень считается своим собственным родителем.

**Пример**

```cpp
Path p("C:\\data\\report.txt");
Path parent = p.getParentDirectory();  // "C:\\data"
```

*Этот пример получает родительский каталог для пути к файлу.*

---

#### `String getExtension() const`

**Сигнатура**

```cpp
String getExtension() const;
```

**Краткое описание**
Возвращает расширение файла без точки (например, "txt").

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащий расширение последнего компонента без ведущей точки. Если расширения нет, возвращается пустая строка.

**Подробно**

`getExtension()` рассматривает последний компонент пути и возвращает часть после последней точки. Примеры:

* `"report.txt"` → `"txt"`
* `"archive.tar.gz"` → `"gz"`
* `"README"` → `""` (без расширения)

**Пример**

```cpp
Path p("C:\\data\\report.txt");
String ext = p.getExtension();  // "txt"
```

*Этот пример получает расширение файла.*

---

#### `String getStem() const`

**Сигнатура**

```cpp
String getStem() const;
```

**Краткое описание**
Возвращает имя файла без расширения.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащий последний компонент с удалённым расширением.

**Подробно**

`getStem()` является противоположностью `getExtension()`. Для тех же примеров:

* `"report.txt"` → `"report"`
* `"archive.tar.gz"` → `"archive.tar"`
* `"README"` → `"README"`

Это полезно для генерации вариантов имён файлов (например, из `report.txt` в `report.bak`).

**Пример**

```cpp
Path p("C:\\data\\report.txt");
String stem = p.getStem();  // "report"
```

*Этот пример получает базовое имя файла без расширения.*

---

#### `bool hasExtension(const String &ext) const`

**Сигнатура**

```cpp
bool hasExtension(const String &ext) const;
```

**Краткое описание**
Возвращает true, если файл имеет указанное расширение (без учёта регистра).

**Параметры**

* `ext` – Расширение для проверки, обычно без точки (например, `"txt"`).

**Возвращаемое значение**

* `true`, если расширение последнего компонента совпадает с `ext`, игнорируя регистр; иначе `false`.

**Подробно**

Этот помощник упрощает проверки расширения. Сравнение нечувствительно к регистру, поэтому `"TXT"` и `"txt"` рассматриваются одинаково.

**Пример**

```cpp
Path p("C:\\data\\report.TXT");
bool isTxt = p.hasExtension("txt");  // true
```

*Этот пример проверяет расширение файла без учёта регистра.*

---

#### `String toString() const`

**Сигнатура**

```cpp
String toString() const;
```

**Краткое описание**
Возвращает путь в виде строки.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащий текстовое представление пути.

**Подробно**

`toString()` предоставляет доступ к внутренней строке пути, которую затем можно логировать, отображать или обрабатывать с помощью операций `String`. Формат обычно соответствует стилю путей Windows.

**Пример**

```cpp
Path p("C:\\data\\file.txt");
String text = p.toString();  // "C:\\data\\file.txt"
```

*Этот пример конвертирует `Path` в `String` для отображения или логирования.*

---

#### `bool equals(const Path &other) const`

**Сигнатура**

```cpp
bool equals(const Path &other) const;
```

**Краткое описание**
Возвращает true, если этот путь равен другому (без учёта регистра).

**Параметры**

* `other` – Путь для сравнения.

**Возвращаемое значение**

* `true`, если два пути считаются равными; иначе `false`.

**Подробно**

`equals()` сравнивает пути в нечувствительной к регистру манере, подходящей для файловых систем Windows. Обычно сравнивается нормализованное текстовое представление обоих путей, хотя точные правила нормализации зависят от реализации.

Используйте это, когда хотите явно сравнить пути, не используя операторов.

**Пример**

```cpp
Path a("C:\\DATA\\file.txt");
Path b("c:\\data\\file.txt");

bool same = a.equals(b);  // true on case-insensitive comparison
```

*Этот пример сравнивает два пути, отличающиеся только регистром букв.*

---

#### `bool operator==(const Path &other) const`

**Сигнатура**

```cpp
bool operator==(const Path &other) const;
```

**Краткое описание**
Возвращает true, если этот путь равен другому (без учёта регистра).

**Параметры**

* `other` – Путь для сравнения.

**Возвращаемое значение**

* `true`, если оба пути равны; иначе `false`.

**Подробно**

Этот оператор является идиоматическим сокращением для `equals(other)`. Он позволяет выражения вида:

```cpp
if (a == b) { ... }
```

Поскольку сравнение нечувствительно к регистру, `"C:\\DATA\\file.txt"` и `"c:\\data\\FILE.txt"` считаются равными.

**Пример**

```cpp
Path a("C:\\data\\file.txt");
Path b("C:\\DATA\\FILE.TXT");

if (a == b) {
  // These refer to the same path, ignoring case.
}
```

*Этот пример использует оператор равенства для сравнения двух путей.*

---

#### `bool operator!=(const Path &other) const`

**Сигнатура**

```cpp
bool operator!=(const Path &other) const;
```

**Краткое описание**
Возвращает true, если этот путь не равен другому.

**Параметры**

* `other` – Путь для сравнения.

**Возвращаемое значение**

* `true`, если пути различаются; `false`, если они считаются равными.

**Подробно**

Это просто логическое отрицание `operator==`. Используйте его, когда хотите ветвить по неравенству.

**Пример**

```cpp
Path a("C:\\data\\file.txt");
Path b("C:\\data\\other.txt");

if (a != b) {
  // The two paths are different.
}
```

*Этот пример выполняет ветвление, когда два пути указывают на разные местоположения.*

---

#### `bool isWithin(const Path &dir) const`

**Сигнатура**

```cpp
bool isWithin(const Path &dir) const;
```

**Краткое описание**
Возвращает true, если этот путь находится внутри заданного каталога.

**Параметры**

* `dir` – Каталог, для которого проверяется вхождение.

**Возвращаемое значение**

* `true`, если этот путь логически располагается внутри `dir` (например, как потомок); иначе `false`.

**Подробно**

`isWithin()` полезен для обеспечения того, что файл находится в пределах определённого корневого каталога, например папки данных приложения. Проверка вхождения обычно учитывает иерархию путей, а не простое префиксное сравнение строк (например, `"C:\\root\\file.txt"` находится внутри `"C:\\root"`, но `"C:\\rootdir\\file.txt"` — нет).

Точные правила нормализации (например, обработка сегментов `..` и завершающих слэшей) зависят от реализации, поэтому рассматривайте эту проверку как высокоуровневую меру безопасности.

**Пример**

```cpp
Path root("C:\\myapp\\data");
Path file("C:\\myapp\\data\\logs\\today.log");

bool inside = file.isWithin(root);  // true
```

*Этот пример проверяет, что путь файла находится внутри указанного каталога данных.*

---

#### `List listChildren(bool recursive = false) const`

**Сигнатура**

```cpp
List listChildren(bool recursive = false) const;
```

**Краткое описание**
Возвращает список строк путей дочерних элементов.

**Параметры**

* `recursive` – Если `false`, возвращаются только прямые дочерние элементы. Если `true`, возвращаются потомки рекурсивно.

**Возвращаемое значение**

* `List` значений `String`, каждое представляющее путь дочернего элемента.

**Подробно**

`listChildren()` перечисляет файлы и каталоги, содержащиеся в этом пути, если он является каталогом:

* Когда `recursive` равно `false`, перечисляются только непосредственные записи.
* Когда `recursive` равно `true`, также включаются записи из подкаталогов, обычно с их полными путями.

Каждый элемент результата — это `String`, содержащий путь, а не объект `Path`. При необходимости вы можете обернуть его в `Path`.

Если путь не является каталогом или не существует, результат обычно представляет собой пустой список.

**Пример**

```cpp
Path dir("C:\\myapp\\logs");
List entries = dir.listChildren(false);

int count = entries.length();
// entries[i] contains the path of each child as a String
```

*Этот пример перечисляет непосредственных потомков каталога логов.*

---

#### `String readToString() const`

**Сигнатура**

```cpp
String readToString() const;
```

**Краткое описание**
Считывает весь файл как строку.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащий содержимое файла в UTF-8. Если чтение не удалось, возвращаемая строка обычно пустая.

**Подробно**

`readToString()` открывает файл по этому пути, читает все байты и конвертирует их в `String`. Это идеально для файлов конфигурации, JSON, небольших журналов или любого текстового содержимого.

Для очень больших файлов это загрузит всё содержимое в память; рассматривайте возможность использования `File` для потоковой обработки.

Рекомендуется проверять `isRegularFile()` или `exists()` перед чтением, чтобы избежать неожиданных результатов.

**Пример**

```cpp
Path config("C:\\myapp\\config.json");
if (config.isRegularFile()) {
  String json = config.readToString();
}
```

*Этот пример считывает файл конфигурации в `String`.*

---

#### `Buffer readToBuffer() const`

**Сигнатура**

```cpp
Buffer readToBuffer() const;
```

**Краткое описание**
Считывает весь файл в буфер.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Buffer`, содержащий сырые байты файла. Если чтение не удалось, буфер обычно пустой.

**Подробно**

`readToBuffer()` аналогичен `readToString()`, но возвращает `Buffer`, что лучше подходит для бинарных данных, таких как изображения, архивы или шифрованное содержимое. Байты не интерпретируются как текст.

**Пример**

```cpp
Path binaryFile("C:\\data\\image.bin");
Buffer data = binaryFile.readToBuffer();
```

*Этот пример считывает все байты бинарного файла в `Buffer`.*

---

#### `bool writeFromString(const String &str) const`

**Сигнатура**

```cpp
bool writeFromString(const String &str) const;
```

**Краткое описание**
Записывает строку в файл. Возвращает true при успехе.

**Параметры**

* `str` – Текстовое содержимое для записи.

**Возвращаемое значение**

* `true`, если файл успешно записан; иначе `false`.

**Подробно**

`writeFromString()` перезаписывает файл по этому пути байтами `str` в кодировке UTF-8. Типичное поведение включает:

* Создание файла, если он не существует (если это возможно).
* Усечение существующего содержимого.

Проблемы с каталогами или правами доступа могут привести к неудаче, в этом случае возвращается `false`.

**Пример**

```cpp
Path log("C:\\myapp\\log.txt");
bool ok = log.writeFromString("Application started.\n");
```

*Этот пример записывает сообщение в лог, заменяя любое существующее содержимое.*

---

#### `bool writeFromBuffer(const Buffer &buf) const`

**Сигнатура**

```cpp
bool writeFromBuffer(const Buffer &buf) const;
```

**Краткое описание**
Записывает буфер в файл. Возвращает true при успехе.

**Параметры**

* `buf` – `Buffer`, содержащий байты для записи.

**Возвращаемое значение**

* `true` при успехе; `false` при неудаче.

**Подробно**

`writeFromBuffer()` записывает сырые байты в файл. Используйте его для бинарных данных, когда не требуется текстовая интерпретация.

Как и `writeFromString()`, операция может создавать или усекать файл.

**Пример**

```cpp
Buffer data;
// data.append(...);  // populate the buffer

Path out("C:\\data\\output.bin");
bool ok = out.writeFromBuffer(data);
```

*Этот пример записывает бинарные данные из буфера в файл.*

---

#### `bool appendFromString(const String &str) const`

**Сигнатура**

```cpp
bool appendFromString(const String &str) const;
```

**Краткое описание**
Добавляет строку в конец файла. Возвращает true при успехе.

**Параметры**

* `str` – Текст для добавления в конец существующего файла.

**Возвращаемое значение**

* `true`, если операция добавления прошла успешно; иначе `false`.

**Подробно**

`appendFromString()` открывает файл в режиме добавления и добавляет UTF-8 байты `str` в конец. Если файл не существует, реализация может создать его (поведение зависит от ОС и дизайна библиотеки).

Это идеально подходит для файлов журналов и инкрементального текстового вывода.

**Пример**

```cpp
Path log("C:\\myapp\\log.txt");
log.appendFromString("Next event...\n");
```

*Этот пример добавляет новую строку в существующий файл журнала.*

---

#### `bool appendFromBuffer(const Buffer &buf) const`

**Сигнатура**

```cpp
bool appendFromBuffer(const Buffer &buf) const;
```

**Краткое описание**
Добавляет буфер в конец файла. Возвращает true при успехе.

**Параметры**

* `buf` – `Buffer`, байты которого следует добавить в файл.

**Возвращаемое значение**

* `true` при успехе; `false` при неудаче.

**Подробно**

Эта функция добавляет сырые байты в конец файла. Поведение похоже на `appendFromString()`, но для бинарных данных.

**Пример**

```cpp
Path out("C:\\data\\binary.log");
Buffer chunk;
// chunk.append(...);  // fill buffer

out.appendFromBuffer(chunk);
```

*Этот пример добавляет бинарные данные в существующий файл.*

---

#### `static bool ChangeCurrentDirectory(const Path &path)`

**Сигнатура**

```cpp
static bool ChangeCurrentDirectory(const Path &path);
```

**Краткое описание**
Изменяет текущий рабочий каталог. Возвращает true при успехе.

**Параметры**

* `path` – `Path`, представляющий каталог, который нужно сделать текущим рабочим каталогом.

**Возвращаемое значение**

* `true`, если текущий рабочий каталог был изменён; иначе `false`.

**Подробно**

Текущий рабочий каталог влияет на то, как интерпретируются относительные пути. Его изменение может упростить код, использующий множество относительных путей, но также повлияет на все последующие операции с относительными путями в процессе.

Используйте это осторожно, особенно в библиотеках или больших приложениях, где другие компоненты могут полагаться на рабочий каталог.

**Пример**

```cpp
Path dataDir("C:\\myapp\\data");
if (Path::ChangeCurrentDirectory(dataDir)) {
  Path relative("config.json");
  String contents = relative.readToString();
}
```

*Этот пример меняет рабочий каталог и затем читает файл с помощью относительного пути.*

---

#### `static List ListVolumes()`

**Сигнатура**

```cpp
static List ListVolumes();
```

**Краткое описание**
Возвращает список букв томов (например, "C:", "D:").

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `List` значений `String`, каждое представляющее том (например, `"C:"`, `"D:"`).

**Подробно**

`ListVolumes()` запрашивает у системы доступные тома/диски. Это может быть полезно при показе меню выбора диска или сканировании всех дисков в поисках определённых файлов.

**Пример**

```cpp
List volumes = Path::ListVolumes();
int count = volumes.length();
// volumes[i] contains drive names like "C:" or "D:"
```

*Этот пример получает список всех обнаруженных томов.*

---

#### `static Path CreateTemporaryFile(const String &prefix = String(), const String &suffix = String())`

**Сигнатура**

```cpp
static Path CreateTemporaryFile(const String &prefix = String(),
                                const String &suffix = String());
```

**Краткое описание**
Создаёт временный файл и возвращает его путь.

**Параметры**

* `prefix` – Необязательный префикс для имени файла (например, `"myapp_"`).
* `suffix` – Необязательное окончание или расширение (например, `".tmp"`).

**Возвращаемое значение**

* `Path` к вновь созданному временному файлу.

**Подробно**

Эта функция создаёт уникальный временный файл в подходящем системном каталоге (обычно в каталоге временных файлов) и возвращает путь к нему. Файл должен существовать к моменту возврата и быть готовым для записи данных.

Вы несёте ответственность за удаление файла, когда он больше не нужен (с помощью `deleteFile()`).

**Пример**

```cpp
Path temp = Path::CreateTemporaryFile("myapp_", ".log");
temp.writeFromString("Temporary log content.\n");
// Later: temp.deleteFile();
```

*Этот пример создаёт временный лог-файл, записывает в него и позже может удалить его.*

---

#### `static Path CreateTemporaryDirectory(const String &prefix = String())`

**Сигнатура**

```cpp
static Path CreateTemporaryDirectory(const String &prefix = String());
```

**Краткое описание**
Создаёт временный каталог и возвращает его путь.

**Параметры**

* `prefix` – Необязательный префикс для имени каталога.

**Возвращаемое значение**

* `Path` к вновь созданному временному каталогу.

**Подробно**

Эта функция создаёт уникальный каталог в системной временной области. Он полезен для промежуточного хранения файлов, распаковки архивов или размещения промежуточных результатов, которые затем можно удалить.

Вы несёте ответственность за удаление каталога (например, с помощью `removeDirectory(true)`, если он может содержать файлы).

**Пример**

```cpp
Path tempDir = Path::CreateTemporaryDirectory("myapp_");
Path tempFile = Path(tempDir.toString() + "\\data.bin");

tempFile.writeFromBuffer(Buffer());
// When done:
tempDir.removeDirectory(true);
```

*Этот пример создаёт временный каталог, использует его для хранения файла и затем удаляет всё дерево каталога.*

---

#### `static Path GetHomeDirectory()`

**Сигнатура**

```cpp
static Path GetHomeDirectory();
```

**Краткое описание**
Возвращает путь к домашнему каталогу пользователя.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Path`, представляющий профильный/домашний каталог текущего пользователя.

**Подробно**

В Windows это обычно каталог профиля пользователя (например, `C:\\Users\\Alice`). Это распространённая база для данных приложения, конфигураций или документов.

**Пример**

```cpp
Path home = Path::GetHomeDirectory();
String homeStr = home.toString();
```

*Этот пример получает путь домашнего каталога и преобразует его в строку.*

---

#### `static Path GetDocumentsDirectory()`

**Сигнатура**

```cpp
static Path GetDocumentsDirectory();
```

**Краткое описание**
Возвращает путь к каталогу «Документы» пользователя.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Path`, представляющий папку «Documents» пользователя.

**Подробно**

Это удобный способ найти место, где обычно хранятся документы, доступные пользователю (например, `C:\\Users\\Alice\\Documents`).

**Пример**

```cpp
Path docs = Path::GetDocumentsDirectory();
Path report(docs.toString() + "\\myapp_report.txt");
```

*Этот пример строит путь к файлу в каталоге «Документы» пользователя.*

---

#### `static Path GetRoamingAppDirectory()`

**Сигнатура**

```cpp
static Path GetRoamingAppDirectory();
```

**Краткое описание**
Возвращает путь к каталогу роуминговых данных приложений.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Path`, представляющий папку роуминговых данных приложений.

**Подробно**

Каталог роуминговых данных используется для настроек, которые должны «путешествовать» за пользователем между машинами в доменной среде (например, `C:\\Users\\Alice\\AppData\\Roaming` на многих системах).

Приложения часто создают здесь собственный подкаталог для своих данных.

**Пример**

```cpp
Path roaming = Path::GetRoamingAppDirectory();
Path appDir(roaming.toString() + "\\MyApp");
appDir.makeDirectory(true);
```

*Этот пример создаёт папку приложения в каталоге роуминговых данных.*

---

#### `static Path GetLocalAppDirectory()`

**Сигнатура**

```cpp
static Path GetLocalAppDirectory();
```

**Краткое описание**
Возвращает путь к каталогу локальных данных приложения.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Path`, представляющий локальную (не роуминговую) папку данных приложения.

**Подробно**

Каталог локальных данных обычно используется для машинно‑специфичных данных, таких как кэши или большие ресурсы, которые не нужно переносить вместе с пользователем (например, `C:\\Users\\Alice\\AppData\\Local`).

**Пример**

```cpp
Path local = Path::GetLocalAppDirectory();
Path cacheDir(local.toString() + "\\MyApp\\Cache");
cacheDir.makeDirectory(true);
```

*Этот пример создаёт каталог кэша в локальной папке данных приложения.*

---

#### `static Path GetWorkingDirectory()`

**Сигнатура**

```cpp
static Path GetWorkingDirectory();
```

**Краткое описание**
Возвращает путь текущего рабочего каталога.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Path`, представляющий текущий рабочий каталог процесса.

**Подробно**

Эта функция получает каталог, который операционная система использует как базу для относительных путей. Она является противоположностью `ChangeCurrentDirectory()`.

**Пример**

```cpp
Path current = Path::GetWorkingDirectory();
String currentStr = current.toString();
```

*Этот пример получает текущий рабочий каталог для логирования или диагностики.*

---

#### `static Path GetCurrentExecutable()`

**Сигнатура**

```cpp
static Path GetCurrentExecutable();
```

**Краткое описание**
Возвращает путь к текущему исполняемому файлу.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Path`, представляющий полный путь к запускаемому исполняемому файлу.

**Подробно**

Это особенно полезно, когда приложению нужно найти ресурсы относительно своей собственной директории установки. Вы можете вызвать `getParentDirectory()` у этого пути, чтобы найти каталог исполняемого файла.

**Пример**

```cpp
Path exe = Path::GetCurrentExecutable();
Path exeDir = exe.getParentDirectory();

Path config(exeDir.toString() + "\\config.json");
```

*Этот пример находит конфигурационный файл, расположенный рядом с исполняемым файлом.*