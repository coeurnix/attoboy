# Conversation

## Обзор

Класс `attoboy::Conversation` представляет собой **состоянийный многократный диалог** с моделью ИИ, управляемый через `attoboy::AI`. Вместо отправки отдельных подсказок вы используете `Conversation`, чтобы:

* Поддерживать **текущую историю** сообщений.
* Задавать последующие вопросы, которые автоматически включают предыдущий контекст.
* Просматривать, изменять или ветвить историю для продвинутых сценариев.
* Отслеживать приблизительное **использование токенов** для разговора.

`Conversation` создаётся экземпляром `AI` следующим образом:

```cpp
using namespace attoboy;

AI ai("https://example-base-url", "YOUR_API_KEY", "your-model");
Conversation convo = ai.createConversation();
```

С этого момента все вызовы `convo.ask(...)` используют одно и то же состояние разговора, которое включает:

* Системную подсказку, настроенную в `AI` (если есть).
* Чередующуюся последовательность сообщений пользователя и ассистента.
* Статистику использования токенов для этого разговора.

### Многотуровые разговоры и история

В большинстве API для больших языковых моделей (LLM) каждый запрос содержит не только последнее сообщение пользователя, но и **историю** всего разговора до текущего момента. Это позволяет модели:

* Ссылаться на предыдущие сообщения.
* Поддерживать непрерывность и стиль.
* Естественно отвечать на последующие вопросы.

`Conversation` абстрагирует этот паттерн:

* Каждый вызов `ask()` добавляет **сообщение пользователя** во внутреннюю историю.
* Ответ модели добавляется как **сообщение ассистента**.
* Вы можете получить полную историю через `getConversationList()` или заменить её с помощью `setConversationList()`.

История хранится как `List` значений типа `String`:

* **Чётные индексы (0, 2, 4, …)** — сообщения пользователя.
* **Нечётные индексы (1, 3, 5, …)** — сообщения ассистента.

Такая структура упрощает просмотр или преобразование разговора при необходимости.

### Токены и отслеживание использования

Большинство LLM тарифицируются и ограничиваются по количеству **токенов** — это небольшие фрагменты текста (в среднем короче слова). Использование токенов — важная концепция, поскольку оно влияет на производительность, стоимость и иногда задержку.

`Conversation` предоставляет три счётчика:

* `getPromptTokensUsed()` — токены, использованные для подсказок (включая прошлые ходы разговора).
* `getResponseTokensUsed()` — токены, сгенерированные моделью как ответы.
* `getTotalTokensUsed()` — сумма токенов подсказок и ответов.

Эти счётчики позволяют вам:

* Мониторить приблизительное использование для аналитики или ограничения по частоте.
* Реализовывать простые правила безопасности, например «предупредить, если разговор стал слишком длинным».

### Копирование и ветвление

Экземпляры `Conversation` — это **хэндлы** на базовое состояние разговора:

* Конструктор копирования и присваивание **разделяют** одно и то же базовое состояние разговора.
* `duplicate()` создаёт **ветвь** разговора, так что новые сообщения в дубликате не влияют на оригинал.

Это полезно, когда вы хотите исследовать несколько возможных «будущих» сценариев, начиная с одной и той же истории:

* Оригинальный `Conversation` продолжается по одному пути.
* Дубликат исследует другие вопросы или системные подсказки (через связанный `AI`).

### Создание и время жизни

Вы не создаёте `Conversation` напрямую. Конструктор по умолчанию приватный. Вместо этого:

* Вызовите `AI::createConversation()` для получения нового `Conversation`.
* Экземпляр `AI` управляет конфигурацией (модель, базовый URL, ключ, системная подсказка и т. д.).
* `Conversation` хранит ссылку на связанный `AI` через `getAI()`.

Как и другие типы attoboy, управление ресурсами использует RAII:

* Деструктор освобождает основные ресурсы разговора, когда объект выходит из области видимости.
* Копирование и присваивание дешево разделяют ссылки, без копирования всей истории.

---

## Справочник

Каждый член `attoboy::Conversation` документирован ниже: сигнатура, краткое описание, параметры, возвращаемые значения, подробное поведение и короткий пример.

> Все примеры предполагают `using namespace attoboy;`.

---

#### `Conversation(const Conversation &other)`

**Сигнатура**

```cpp
Conversation(const Conversation &other);
```

**Краткое описание**
Создаёт копию (разделяет базовое состояние разговора).

**Параметры**

* `other` – существующий `Conversation`, с которым будет разделено базовое состояние.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Конструктор копирования создаёт новый объект `Conversation`, который **ссылается на то же базовое состояние разговора**, что и `other`. Это означает:

* Оба объекта видят одну и ту же историю сообщений.
* Вызов `ask()` на любом из объектов добавляет сообщение в один и тот же разговор.
* Счётчики токенов разделяются.

Такое поведение намеренно и эффективно: `Conversation` — лёгкий хэндл, который можно передавать по значению без копирования всей истории.

Если вам нужен отдельный ответвлённый разговор (например, чтобы независимо исследовать два разных последующих вопроса), используйте `duplicate()`.

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");
Conversation original = ai.createConversation();

Conversation shared(original);  // shares history with 'original'

String reply1 = original.ask("Hello!");
String reply2 = shared.ask("What did I just say?");
```

*В этом примере показаны два хэндла, разделяющие одно и то же состояние разговора; оба вызова `ask()` работают с одной историей.*

---

#### `~Conversation()`

**Сигнатура**

```cpp
~Conversation();
```

**Краткое описание**
Уничтожает разговор и освобождает ресурсы.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробно**

Когда объект `Conversation` уничтожается, он снимает свою ссылку с базового состояния разговора. Если ни один другой `Conversation` не разделяет это состояние, библиотека освобождает связанные ресурсы.

Вам не нужно вызывать какие-либо явные функции завершения. Дайте `Conversation` выйти из области видимости или перезапишите переменную — RAII обеспечит очистку.

**Пример**

```cpp
{
  AI ai("https://example-base-url", "KEY", "model");
  Conversation convo = ai.createConversation();
  String reply = convo.ask("Temporary question");
} // convo уничтожается здесь; связанные ресурсы освобождаются
```

*В этом примере разговор создаётся и автоматически очищается при выходе из блока.*

---

#### `Conversation &operator=(const Conversation &other)`

**Сигнатура**

```cpp
Conversation &operator=(const Conversation &other);
```

**Краткое описание**
Присваивает другой разговор (разделяет базовое состояние).

**Параметры**

* `other` – `Conversation`, состояние которого должно быть разделено после присваивания.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочечное присваивание.

**Подробно**

Оператор присваивания заставляет левый операнд `Conversation` разделять одно и то же базовое состояние разговора, что и `other`. Любое ранее связанное состояние освобождается.

После присваивания:

* Обе переменные ссылаются на одну и ту же историю.
* Вызовы `ask()` на любой из переменных влияют на один и тот же разговор.

Если ранее в `*this` был уникальный разговор, он больше не будет ссылаться и может быть освобождён.

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");

Conversation convo1 = ai.createConversation();
Conversation convo2 = ai.createConversation();

convo2 = convo1;  // now both share the same conversation
```

*В этом примере один `Conversation` присваивается другому, в результате чего они начинают разделять состояние.*

---

#### `String ask(const String &prompt, int timeout = -1)`

**Сигнатура**

```cpp
String ask(const String &prompt, int timeout = -1);
```

**Краткое описание**
Отправляет сообщение и возвращает ответ. В случае ошибки проверяйте isEmpty().

**Параметры**

* `prompt` – сообщение пользователя, которое будет добавлено в историю разговора и отправлено модели ИИ.
* `timeout` – необязательный тайм-аут для запроса в миллисекундах. Значение `-1` использует поведение по умолчанию библиотеки (обычно неограниченно или зависит от модели).

**Возвращаемое значение**

* `String`, содержащая ответ ассистента.
* В случае ошибки (например, сетевой сбой или ошибка API) возвращаемая строка **пустая**; следует вызвать `isEmpty()` для проверки.

**Подробно**

`ask()` — основной способ взаимодействия с ИИ через `Conversation`:

1. `prompt` добавляется в историю разговора как **сообщение пользователя**.
2. Полная история (сообщения пользователя и ассистента) отправляется на бэкенд ИИ.
3. Ответ ИИ добавляется как **сообщение ассистента**.
4. Ответ возвращается как `String`.

Счётчики использования токенов (`getPromptTokensUsed()`, `getResponseTokensUsed()`, `getTotalTokensUsed()`) обновляются соответствующим образом.

Обработка ошибок явная:

* В случае ошибки возвращаемая `String` пустая (то есть `reply.isEmpty()` возвращает `true`).
* Существующая история разговора может быть обновлена или нет в зависимости от ошибки; вы можете просмотреть или сбросить её с помощью `getConversationList()` и `setConversationList()` при необходимости.

Параметр `timeout` контролирует, как долго вызов может блокировать ожидание ответа. Используйте его, если нужно предотвратить длительные блокирующие вызовы в вашем приложении.

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");
Conversation convo = ai.createConversation();

String reply = convo.ask("Hello, who are you?");

if (!reply.isEmpty()) {
  // Use the reply, and optionally ask follow-up questions.
  String followUp = convo.ask("Can you summarize your abilities?");
}
```

*В этом примере начинается разговор, отправляется вопрос, проверяется отсутствие ошибок через `isEmpty()`, а затем задаётся последующий вопрос с использованием того же контекста разговора.*

---

#### `List getConversationList() const`

**Сигнатура**

```cpp
List getConversationList() const;
```

**Краткое описание**
Возвращает историю разговора (чётные=user, нечётные=assistant).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `List` объектов типа `String`, представляющих историю разговора.

  * **Чётные индексы (0, 2, 4, …)** — сообщения пользователя.
  * **Нечётные индексы (1, 3, 5, …)** — сообщения ассистента.

**Подробно**

`getConversationList()` даёт доступ к внутренней истории в простом, универсальном формате:

* Список представляет собой плоскую последовательность сообщений.
* Паритет индекса (чётный/нечётный) указывает, кто говорил.
* Сообщения хранятся как значения `String`.

Типичные случаи использования:

* Логирование или отладка разговора.
* Реализация кастомных представлений разговора или сохранение истории на диск.
* Копирование истории для инициализации нового разговора (через `setConversationList()`).

Поскольку возвращённый `List` является отдельным объектом, его изменение **не** меняет базовый разговор автоматически. Чтобы применить изменения, вызовите `setConversationList()` с модифицированным списком.

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");
Conversation convo = ai.createConversation();

convo.ask("Hello!");
convo.ask("What can you do?");

List history = convo.getConversationList();
int count = history.length();

// Example: get the last user message, if any.
if (count >= 1 && (count - 1) % 2 == 0) {
  String lastUser = history.at<String>(count - 1);
}
```

*В этом примере извлекается история и демонстрируется, как найти последнее сообщение пользователя с помощью паритета индекса.*

---

#### `bool setConversationList(const List &list)`

**Сигнатура**

```cpp
bool setConversationList(const List &list);
```

**Краткое описание**
Заменяет историю разговора. Возвращает true при успехе.

**Параметры**

* `list` – `List` объектов типа `String`, который будет использован как новая история разговора. Принятая конвенция:

  * Чётные индексы — сообщения пользователя.
  * Нечётные индексы — сообщения ассистента.

**Возвращаемое значение**

* `true`, если история успешно заменена.
* `false`, если список не может быть применён (например, если он некорректен или слишком велик для реализации).

**Подробно**

`setConversationList()` позволяет **перезаписать** внутреннюю историю разговора. Распространённые сценарии:

* Восстановление сохранённого разговора с диска.
* Начало с заранее заданного «сценария» сообщений.
* Удаление чувствительных сообщений перед продолжением.

При вызове этой функции:

* Существующая история полностью заменяется.
* Последующие вызовы `ask()` продолжаются от новой истории.
* Счётчики токенов могут быть сброшены или пересчитаны в зависимости от реализации; не полагайтесь на их сохранность, если вы не управляете ими вручную.

Вы несёте ответственность за корректное построение `list` (с использованием чётных/нечётных индексов для пользователя/ассистента). Функция не интерпретирует сообщения повторно; она предполагает, что вы соблюдаете документированную конвенцию.

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");
Conversation convo = ai.createConversation();

// Build a scripted conversation history.
List scripted;
scripted.append("User: Please always answer very briefly.");
scripted.append("Assistant: Understood. I will answer briefly.");
scripted.append("User: What is 2+2?");

// Apply it to the conversation.
bool ok = convo.setConversationList(scripted);

if (ok) {
  String reply = convo.ask("And what is 3+3?");
}
```

*В этом примере беседа инициализируется заранее заданной историей, после чего продолжается новый вопрос.*

---

#### `Conversation duplicate() const`

**Сигнатура**

```cpp
Conversation duplicate() const;
```

**Краткое описание**
Создаёт копию этого разговора для ветвления.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Новый `Conversation`, который начинается с той же истории, что и оригинал, но далее развивается независимо.

**Подробно**

В отличие от конструктора копирования и оператора присваивания (которые разделяют базовое состояние разговора), `duplicate()` создаёт **ветвь** разговора:

* Новый `Conversation` начинается с той же истории сообщений.
* Дальнейшие вызовы `ask()` на оригинале и дубликате изменяют **разные** истории.
* Отслеживание токенов для каждой ветви независимо.

Используйте `duplicate()`, когда хотите исследовать альтернативные продолжения, исходя из одного и того же начального контекста.

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");
Conversation base = ai.createConversation();

base.ask("Explain recursion in simple terms.");

Conversation branch1 = base.duplicate();
Conversation branch2 = base.duplicate();

String reply1 = branch1.ask("Give me a very short example.");
String reply2 = branch2.ask("Give me a detailed, step-by-step example.");
```

*В этом примере создаются две ветви из общей начальной беседы и задаются разные уточняющие вопросы в каждой ветви.*

---

#### `AI getAI() const`

**Сигнатура**

```cpp
AI getAI() const;
```

**Краткое описание**
Возвращает экземпляр AI, управляющий этим разговором.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Объект `AI`, разделяющий базовую конфигурацию с исходным `AI`, создавшим `Conversation`.

**Подробно**

`getAI()` даёт доступ к экземпляру `AI`, связанному с `Conversation`. Это полезно, когда нужно:

* Просмотреть конфигурацию (имя модели, базовый URL, системную подсказку).
* Изменить настройки (например, `setMaxTokens()` или `setJsonMode()`).
* Создать дополнительные разговоры с той же конфигурацией AI.

Возвращённый `AI` разделяет базовую конфигурацию с оригинальным `AI`, который создал разговор. Изменения, сделанные через этот экземпляр `AI`, отражаются в разговорах, которые его разделяют.

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");
Conversation convo = ai.createConversation();

// Retrieve the AI from the conversation.
AI associated = convo.getAI();

// Change configuration (for example, set JSON mode).
associated.setJsonMode(true);

String reply = convo.ask("Respond with JSON describing a cat.");
```

*В этом примере из разговора извлекается управляющий `AI`, его конфигурация обновляется, а затем отправляется вопрос.*

---

#### `int getPromptTokensUsed() const`

**Сигнатура**

```cpp
int getPromptTokensUsed() const;
```

**Краткое описание**
Возвращает количество использованных токенов подсказок.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Целое число — количество токенов, использованных в подсказках для этого разговора (по данным реализации).

**Подробно**

Этот счётчик отображает накопленное число токенов, отправленных модели в качестве **входных данных**:

* Включает системную подсказку (если есть).
* Включает все сообщения пользователя и ассистента, которые входили в запросы.

Используйте это для:

* Мониторинга использования по разговору.
* Реализации простых ограничений (например, завершить или сбросить разговор при достижении порога токенов).

Точная методика подсчёта зависит от используемой модели и API; рассматривайте это как приближение, а не строгую биллинговую величину.

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");
Conversation convo = ai.createConversation();

convo.ask("Hello!");
convo.ask("Tell me a story.");

int promptTokens = convo.getPromptTokensUsed();
```

*В этом примере после нескольких ходов получения определяется число использованных токенов подсказок.*

---

#### `int getResponseTokensUsed() const`

**Сигнатура**

```cpp
int getResponseTokensUsed() const;
```

**Краткое описание**
Возвращает количество токенов, использованных в ответах.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Целое число — количество токенов, сгенерированных моделью как **ответы** в этом разговоре.

**Подробно**

Этот счётчик отслеживает, сколько токенов модель сгенерировала в виде вывода по всем вызовам `ask()` в этом разговоре.

Он помогает:

* Оценить, насколько «многословен» был ассистент.
* Реализовать политики, основанные на суммарном объёме сгенерированного контента.

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");
Conversation convo = ai.createConversation();

convo.ask("Explain tokens.");
convo.ask("Summarize your explanation in one sentence.");

int responseTokens = convo.getResponseTokensUsed();
```

*В этом примере проверяется, сколько выходных токенов было сгенерировано до этого момента.*

---

#### `int getTotalTokensUsed() const`

**Сигнатура**

```cpp
int getTotalTokensUsed() const;
```

**Краткое описание**
Возвращает общее количество использованных токенов.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Целое число, равное `getPromptTokensUsed() + getResponseTokensUsed()`.

**Подробно**

Это **общее использование токенов** в разговоре, объединяющее токены подсказок и ответов. Это наиболее удобное одно число для:

* Планирования бюджета использования по разговору.
* Решения, когда сокращать или сбрасывать длинные истории.
* Простых панелей мониторинга.

Соотношение:

```cpp
getTotalTokensUsed() == getPromptTokensUsed() + getResponseTokensUsed();
```

**Пример**

```cpp
AI ai("https://example-base-url", "KEY", "model");
Conversation convo = ai.createConversation();

convo.ask("Hello!");
convo.ask("What can you do?");
convo.ask("Give me three bullet points.");

int total = convo.getTotalTokensUsed();

if (total > 4000) {
  // Consider truncating or resetting the conversation.
}
```

*В этом примере общее число токенов используется для принятия решения о том, не разросся ли разговор слишком сильно.*