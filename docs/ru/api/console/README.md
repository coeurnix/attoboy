# Console

## Обзор

Класс `attoboy::Console` — это высокоуровневый интерфейс для создания богатых интерактивных командных приложений в Windows. Он объединяет:

* Цветной вывод текста.
* Автоматический перенос слов и выравнивание.
* Позиционирование курсора и управление экраном.
* Интерактивный ввод построчно с историей и автодополнением по Tab.
* Событийный ввод (клавиатура и мышь).
* Анимированные индикаторы выполнения.
* Интерактивные меню.
* Неблокирующие глобальные хоткеи.

Класс использует принцип RAII (Resource Acquisition Is Initialization) для управления состоянием консоли:

* При создании объекта `Console` он настраивает терминал для интерактивного режима (UTF-8 вывод, обработка мыши, изменение размера и т. д.).
* При его уничтожении исходные настройки консоли восстанавливаются.

В любой момент времени должен существовать только один экземпляр `Console`. Поскольку `Console` не копируем, это легко обеспечить в вашем коде.

### Понятия консоли

Если вы новичок в программировании для консоли, несколько ключевых концепций будут полезны.

#### Координаты консоли

Экран консоли — это сетка символов. Можно представить её как двумерный массив:

* Горизонтальная ось — это **координата X** (столбцы).
* Вертикальная ось — это **координата Y** (строки).
* Координаты **с нуля**, поэтому верхний левый угол имеет значение `(0, 0)`.

Функции `Console::width()` и `Console::height()` сообщают текущий размер этой сетки.

#### Цвета и атрибуты

Консоль поддерживает **16 цветов**, определённых в перечислении `ConsoleColor`:

* Например: `CON_RED`, `CON_GREEN`, `CON_WHITE`, `CON_BLACK` и т.д.

При выводе текста через `Console::print()` или `Console::println()` можно указать **цвет переднего плана** и **фон**:

* Передний план (`fg`) управляет цветом текста.
* Фон (`bg`) управляет цветом фона.

Значения по умолчанию:

* `fg = CON_WHITE`
* `bg = CON_BLACK`

#### Выравнивание текста и перенос

Перечисление `ConsoleAlign` определяет, как позиционируется текст:

* `CON_ALIGN_LEFT` (по умолчанию)
* `CON_ALIGN_CENTER`
* `CON_ALIGN_RIGHT`
* `CON_ALIGN_JUSTIFY`

`Console::printAligned()` и `Console::printWrapped()` используют эти настройки выравнивания и доступную ширину для разметки текста.

Также есть статические вспомогательные функции:

* `Console::Align()` — возвращает строку с паддингом/выравниванием.
* `Console::Wrap()` — возвращает многострочную строку с переносом слов.

Они не рисуют ничего сами; они просто возвращают значения типа `String`, которые вы можете напечатать или обработать.

#### Интерактивный ввод и события

`Console::input()` предоставляет построчный интерактивный ввод с дополнительными возможностями, управляемыми структурой `ConsoleInput`:

* Автодополнение по Tab.
* История ввода.
* Режим пароля (маскированный ввод).
* Многострочный ввод.

`Console::readEvent()` опускается на более низкий уровень и возвращает **события**, такие как нажатия клавиш и действия мыши, в виде человекочитаемых строк, например `"Enter"`, `"Ctrl+C"` или `"MouseLeft@10,5"`.

#### Индикаторы выполнения и меню

Консоль может показывать постоянный **индикатор выполнения** внизу экрана. Обновлять его можно через `Console::progress()`, а скрыть — через `Console::progressHide()`.

Метод `Console::menu()` позволяет отобразить интерактивное меню, перемещаться по нему с помощью клавиатуры или мыши и вернуть индекс выбранного пункта.

#### Глобальные хоткеи

Вы можете зарегистрировать **глобальные хоткеи** через `Console::onHotkey()`:

* Например: `"Ctrl+Q"` или `"Shift+F1"`.
* При нажатии вызывается коллбек-функция асинхронно.
* Хоткей можно отменить через `Console::offHotkey()`.

Это позволяет создавать отзывчивые интерфейсы, где определённые сочетания клавиш выполняют действия, даже если вы в данный момент ожидаете ввода или обновляете экран.

---

## Справочник

В этом разделе перечислены все публичные конструкторы, деструкторы, методы-члены, статические функции и операторы класса `Console`. Для каждого символа приведено:

* **Сигнатура** — точное объявление из заголовочного файла.
* **Краткое описание** — исходная однострочная документация Doxygen.
* **Параметры** — описание каждого аргумента.
* **Возвращаемое значение** — описание возвращаемого значения (если применимо).
* **Развернуто** — детальное поведение, примечания по использованию и оговорки.
* Небольшой **пример** с краткой подписью.

> Во всех примерах предполагается `using namespace attoboy;`.

---

#### `Console::Console()`

**Сигнатура**

```cpp
Console();
```

**Краткое описание**
Инициализирует консоль для интерактивного использования.
Включает ввод мыши, настраивает обработку изменения размера и конфигурирует вывод UTF-8.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Развернуто**

При создании объекта `Console`:

* Терминал переводится в режим, подходящий для интерактивного UI:

  * Вывод в UTF-8.
  * Отчёт о событиях мыши.
  * Обработка изменения размера консоли, чтобы элементы UI могли перерасполагаться.
* Сохраняется **предыдущее состояние консоли**, чтобы восстановить его в деструкторе.

Поскольку в любой момент времени должен существовать только один экземпляр `Console`, лучше создать его один раз в начале интерактивной части программы и держать до тех пор, пока консольный UI не потребуется больше.

**Пример**

```cpp
Console console;
console.println("Interactive console initialized.");
```

*Этот пример создаёт `Console` и выводит сообщение подтверждения.*

---

#### `Console::~Console()`

**Сигнатура**

```cpp
~Console();
```

**Краткое описание**
Восстанавливает исходное состояние консоли и настройки.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Развернуто**

Когда объект `Console` уничтожается:

* Любые изменения конфигурации консоли (режимы цвета, обработка ввода и т. п.) отменяются.
* Консоль возвращается в исходное состояние, чтобы другие инструменты или оболочки не были затронуты.

Это реализация паттерна RAII: ресурсы захватываются в конструкторе и освобождаются в деструкторе.

**Пример**

```cpp
{
  Console console;
  console.println("This UI uses custom console settings.");
}
// After this block, the console state is restored automatically.
```

*Этот пример показывает, как настройки консоли автоматически восстанавливаются при выходе объекта из области видимости.*

---

#### `Console::Console(const Console &) = delete`

**Сигнатура**

```cpp
Console(const Console &) = delete;
```

**Краткое описание**
Консоль нельзя копировать.

**Параметры**

* *(нет; эта функция удалена и не может быть вызвана)*

**Возвращаемое значение**

* *(неприменимо; удалённая функция)*

**Развернуто**

Конструктор копирования **удалён**, что означает, что вы не можете копировать `Console`:

* Нельзя делать `Console other = console;`
* Нельзя передавать или возвращать `Console` по значению.

Это предотвращает наличие нескольких объектов `Console`, пытающихся управлять одним и тем же состоянием консоли, что могло бы привести к ошибкам.

Если нужно совместное использование `Console`, передавайте его по ссылке или указателю.

**Пример**

```cpp
Console console;

// The following line is NOT allowed and will not compile:
// Console copy = console;  // error: Console copy constructor is deleted
```

*Этот пример иллюстрирует, что копирование экземпляра `Console` не разрешено.*

---

#### `Console &Console::operator=(const Console &) = delete`

**Сигнатура**

```cpp
Console &operator=(const Console &) = delete;
```

**Краткое описание**
Присваивание `Console` запрещено.

**Параметры**

* *(нет; этот оператор удалён и не может быть вызван)*

**Возвращаемое значение**

* *(неприменимо; удалённая функция)*

**Развернуто**

Оператор присваивания копированием также **удалён**, поэтому нельзя присвоить один `Console` другому. Это согласуется с дизайном некопируемого объекта.

Если вам хочется присваивать консоли, это обычно означает, что следует перестроить код, чтобы хранить один объект `Console` и передавать ссылки по мере необходимости.

**Пример**

```cpp
Console a;
Console b;

// The following line is NOT allowed and will not compile:
// b = a;  // error: Console assignment operator is deleted
```

*Этот пример показывает, что нельзя присваивать один экземпляр `Console` другому.*

---

#### `int Console::width() const`

**Сигнатура**

```cpp
int width() const;
```

**Краткое описание**
Возвращает ширину консоли в символах.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Текущая ширина консоли (число столбцов в символах).

**Развернуто**

`width()` сообщает, сколько символов помещается в одной строке окна консоли. Поскольку пользователь может изменять размер окна, это значение может меняться со временем. Если вам важно расположение, вызывайте `width()` в момент рендеринга.

Типичные применения:

* Центрирование или выравнивание текста по правому краю.
* Проектирование сеток макета.
* Выбор ширины для переноса текста.

**Пример**

```cpp
Console console;
int w = console.width();

String msg("Console width: ");
console.println(msg + String(w));
```

*Этот пример считывает ширину консоли и выводит её как часть сообщения.*

---

#### `int Console::height() const`

**Сигнатура**

```cpp
int height() const;
```

**Краткое описание**
Возвращает высоту консоли в символах.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Текущая высота консоли (число строк в символах).

**Развернуто**

`height()` сообщает, сколько текстовых строк помещается в окне консоли. Как и `width()`, это значение может измениться при изменении размера окна.

Это полезно при:

* Проектировании полноэкранных интерфейсов.
* Размещении меню или строк состояния относительно нижней части экрана.
* Избежании ненужной прокрутки вывода.

**Пример**

```cpp
Console console;
int h = console.height();

console.println("Console height: " + String(h));
```

*Этот пример выводит текущую высоту консоли в строках.*

---

#### `Console &Console::print(const String &text, ConsoleColor fg = CON_WHITE, ConsoleColor bg = CON_BLACK)`

**Сигнатура**

```cpp
Console &print(const String &text, ConsoleColor fg = CON_WHITE,
               ConsoleColor bg = CON_BLACK);
```

**Краткое описание**
Выводит текст с необязательными цветами переднего и заднего плана.

**Параметры**

* `text` – Текст для вывода в текущей позиции курсора.
* `fg` – Цвет переднего плана (по умолчанию `CON_WHITE`).
* `bg` – Цвет фона (по умолчанию `CON_BLACK`).

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочку вызовов.

**Развернуто**

`print()` записывает текст в консоль без добавления перевода строки в конце. Курсор смещается на количество напечатанных символов.

Поведение цвета:

* Цвет применяется к напечатанному тексту.
* После печати консоль может оставаться в новом цветовом состоянии. Если хотите вернуть значения по умолчанию, явно выводите текст с нужными цветами.

Можно объединять вызовы:

```cpp
console.print("Label: ").print("value", CON_GREEN);
```

**Пример**

```cpp
Console console;

console.print("OK ", CON_GREEN);
console.print("ERROR ", CON_RED);
console.print("DEFAULT");
```

*Этот пример печатает три слова разными цветами с помощью цепочки вызовов.*

---

#### `Console &Console::println(const String &text = "", ConsoleColor fg = CON_WHITE, ConsoleColor bg = CON_BLACK)`

**Сигнатура**

```cpp
Console &println(const String &text = "", ConsoleColor fg = CON_WHITE,
                 ConsoleColor bg = CON_BLACK);
```

**Краткое описание**
Выводит текст с последующим переводом строки.

**Параметры**

* `text` – Текст для вывода (может быть пустым).
* `fg` – Цвет переднего плана (по умолчанию `CON_WHITE`).
* `bg` – Цвет фона (по умолчанию `CON_BLACK`).

**Возвращаемое значение**

* Ссылка на `*this`, позволяющая цепочку вызовов.

**Развернуто**

`println()` выводит переданный текст и затем перемещает курсор в начало следующей строки. Если `text` пустой (по умолчанию), выводится просто пустая строка.

Можно использовать для типичного построчного вывода журналов:

```cpp
console.println("Starting application...");
```

**Пример**

```cpp
Console console;

console.println("Normal line");
console.println("Highlighted line", CON_BLACK, CON_YELLOW);
console.println();  // blank line
console.println("Done.");
```

*Этот пример выводит несколько строк, включая выделенную строку и пустую строку.*

---

#### `Console &Console::clear()`

**Сигнатура**

```cpp
Console &clear();
```

**Краткое описание**
Очищает весь экран консоли.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

`clear()` стирает всё видимое содержимое и обычно перемещает курсор в верхний левый угол `(0, 0)`. Используйте её для:

* Начала нового кадра для интерфейса в полноэкранном режиме.
* Удаления захламлённого вывода перед рендерингом нового макета.

**Пример**

```cpp
Console console;

console.println("This will disappear...");
console.clear();
console.println("Screen cleared.");
```

*Этот пример очищает экран и выводит новое сообщение после этого.*

---

#### `Console &Console::printAligned(const String &text, int width, ConsoleAlign align = CON_ALIGN_LEFT, ConsoleColor fg = CON_WHITE, ConsoleColor bg = CON_BLACK)`

**Сигнатура**

```cpp
Console &printAligned(const String &text, int width,
                      ConsoleAlign align = CON_ALIGN_LEFT,
                      ConsoleColor fg = CON_WHITE,
                      ConsoleColor bg = CON_BLACK);
```

**Краткое описание**
Выводит текст, выровненный в пределах указанной ширины.
Если width равен -1, используется текущая ширина консоли.

**Параметры**

* `text` – Текст для вывода.
* `width` – Ширина поля в символах, или `-1` для использования ширины консоли.
* `align` – Режим выравнивания (`CON_ALIGN_LEFT`, `CON_ALIGN_CENTER`, `CON_ALIGN_RIGHT`, `CON_ALIGN_JUSTIFY`).
* `fg` – Цвет переднего плана (по умолчанию `CON_WHITE`).
* `bg` – Цвет фона (по умолчанию `CON_BLACK`).

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

`printAligned()` выполняет как выравнивание, так и добавление отступов:

* Если `width` положительный, текст выравнивается в пределах указанного числа столбцов.
* Если `width == -1`, функция использует текущую ширину консоли.
* При необходимости добавляется заполнение; слишком длинный текст может быть усечён или перенесён в зависимости от реализации.

Типичные применения:

* Панели заголовков или шапки.
* Макеты на основе колонок.
* Центрированные баннеры.

**Пример**

```cpp
Console console;
int w = console.width();

String title("My Application");
console.printAligned(title, w, CON_ALIGN_CENTER, CON_YELLOW);
console.println();
```

*Этот пример центрирует заголовок по ширине консоли, используя яркий цвет.*

---

#### `Console &Console::printWrapped(const String &text, int width = -1, ConsoleColor fg = CON_WHITE, ConsoleColor bg = CON_BLACK)`

**Сигнатура**

```cpp
Console &printWrapped(const String &text, int width = -1,
                      ConsoleColor fg = CON_WHITE,
                      ConsoleColor bg = CON_BLACK);
```

**Краткое описание**
Выводит текст с автоматическим переносом слов.
Если width равен -1, используется текущая ширина консоли.

**Параметры**

* `text` – Текст для вывода; может содержать существующие переводы строк.
* `width` – Ширина для переноса в символах, или `-1` для использования ширины консоли.
* `fg` – Цвет переднего плана (по умолчанию `CON_WHITE`).
* `bg` – Цвет фона (по умолчанию `CON_BLACK`).

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

`printWrapped()`:

* Переносит строки по границам слов, чтобы не разрывать слова посередине.
* Учитывает существующие переводы строк (например, уже разделённые абзацы).
* Использует `width` для определения места переноса каждой строки.

Если `width == -1`, функция берёт `Console::width()` в момент печати. Это полезно, когда пользователь изменяет размер консоли; каждый вызов адаптируется к текущему размеру.

**Пример**

```cpp
Console console;

String paragraph(
  "This is a long paragraph that will be automatically wrapped "
  "to fit the console width without breaking words in the middle."
);

console.printWrapped(paragraph);
console.println();
```

*Этот пример выводит абзац, который автоматически переносится по ширине консоли.*

---

#### `Console &Console::setCursor(int x, int y)`

**Сигнатура**

```cpp
Console &setCursor(int x, int y);
```

**Краткое описание**
Перемещает курсор в указанную позицию (координаты с нуля).

**Параметры**

* `x` – Позиция по столбцу (0 = самый левый).
* `y` – Позиция по строке (0 = самая верхняя).

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

`setCursor()` пересылает текстовый курсор. Следующий напечатанный символ появится в точке `(x, y)`.

Убедитесь, что:

* `0 <= x < width()`
* `0 <= y < height()`

Координаты вне диапазона могут быть проигнорированы или ограничены API.

Часто используется для:

* Перерисовки только части экрана.
* Реализации строк состояния или индикаторов прогресса в фиксированных позициях.

**Пример**

```cpp
Console console;

console.clear();
console.setCursor(0, 0).println("Top left");
console.setCursor(10, 5).println("At (10,5)");
```

*Этот пример перемещает курсор в разные позиции и выводит текст там.*

---

#### `Console &Console::showCursor()`

**Сигнатура**

```cpp
Console &showCursor();
```

**Краткое описание**
Показывает текстовый курсор.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

`showCursor()` делает видимым мигающий текстовый курсор. Это уместно, когда:

* Ожидается ввод пользователя в текущей позиции.
* Навигация по формам или полям ввода.

**Пример**

```cpp
Console console;

console.hideCursor();
console.println("Working...");
console.showCursor();
console.println("Ready for input.");
```

*Этот пример скрывает курсор во время работы, затем показывает его снова, когда готов к вводу.*

---

#### `Console &Console::hideCursor()`

**Сигнатура**

```cpp
Console &hideCursor();
```

**Краткое описание**
Скрывает текстовый курсор.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

`hideCursor()` убирает видимый курсор, что полезно при:

* Отображении полноэкранных панелей или анимаций.
* Демонстрации меню, где позиция курсора не имеет смысла.

Не забудьте вызвать `showCursor()` перед завершением программы или при возврате к стандартному приглашению ввода, чтобы пользователь не остался без видимого курсора.

**Пример**

```cpp
Console console;

console.hideCursor();
console.println("Rendering a full-screen interface without a blinking cursor...");
```

*Этот пример скрывает курсор во время рендеринга интерфейса.*

---

### Структура конфигурации `ConsoleInput`

#### Обзор

Структура `ConsoleInput` настраивает поведение `Console::input()`. Это простой контейнер данных с четырьмя полями и стандартными семантиками значений (конструктор, копирование, присваивание, деструктор).

Вы используете `ConsoleInput`, когда хотите выйти за пределы базового однострочного приглашения и включить такие возможности, как:

* **Автодополнение по Tab** на основе списка кандидатов.
* Постоянная **история команд** с навигацией стрелками вверх/вниз.
* **Ввод пароля** с маскированием символов.
* **Многострочный ввод** с собственным приглашением для продолжения.

---

#### Справочник

##### Поля

Каждое поле публичное и может быть задано напрямую.

---

###### `List ConsoleInput::completions`

**Сигнатура**

```cpp
List completions;
```

**Краткое описание**
Кандидаты для автодополнения по Tab (пустой список — без автодополнения).

**Назначение**

* `List` возможных строк-дополнений.
* Если пусто, автодополнение отключено.

**Развернуто**

Когда `completions` непустой, `Console::input()` может предлагать автодополнение, используя значения из списка. Обычное поведение:

* Нажатие **Tab** циклично перебирает или предлагает дополнения.
* Точный пользовательский интерфейс (замена inline, подсказки и т. п.) зависит от реализации библиотеки.

**Пример**

```cpp
Console console;
ConsoleInput opts;

// Prepare completion candidates:
opts.completions.append("start").append("status").append("stop");

String cmd = console.input("> ", opts);
console.println("Command: " + cmd);
```

*Этот пример включает простое автодополнение для трёх команд: `start`, `status` и `stop`.*

---

###### `List ConsoleInput::history`

**Сигнатура**

```cpp
List history;
```

**Краткое описание**
Буфер истории команд (чтение/запись, пустой список — без истории).
История автоматически обновляется после каждого ввода.

**Назначение**

* `List`, хранящий предыдущие строки ввода.
* Если пустой, история не ведётся и стрелки вверх/вниз не перемещаются по предыдущим командам.

**Развернуто**

Когда `history` непустой:

* `Console::input()` трактует список как и **вход**, и **выход**:

  * Читает существующие записи, чтобы обеспечить навигацию по истории с помощью клавиш **Up/Down**.
  * Автоматически добавляет каждую успешно введённую строку в список.
* Можно предварительно заполнить историю перед вызовом `input()`:

  * Например, дефолтными командами или ранее сохранённой историей.

**Пример**

```cpp
Console console;
ConsoleInput opts;

console.println("Type commands; Up/Down to navigate history, blank to quit.");

while (true) {
  String line = console.input("> ", opts);
  if (line.trim().isEmpty()) {
    break;
  }
  console.println("You entered: " + line);
}

// opts.history now contains all entered lines
```

*Этот пример включает постоянную историю между вызовами `input()`, с навигацией стрелками вверх/вниз.*

---

###### `bool ConsoleInput::password`

**Сигнатура**

```cpp
bool password;
```

**Краткое описание**
Маскирует ввод символами для ввода пароля.

**Назначение**

* Если `true`, `Console::input()` маскирует вводимые символы (например, символом `*`).
* Если `false`, ввод отображается нормально.

**Развернуто**

Режим пароля полезен для:

* Запроса аутентификации.
* Секретных токенов или ключей API.

Примечания по поведению:

* Возвращаемая строка содержит реальные символы.
* Только **отображение** в консоли маскируется.
* Сочетание `password = true` с непустой `history` обычно плохая идея:

  * Пароли будут сохранены в списке истории.
  * Если включаете `password`, обычно устанавливайте `history = nullptr`.

**Пример**

```cpp
Console console;
ConsoleInput opts;

opts.password = true;   // mask typed characters
opts.history = nullptr; // avoid storing passwords in history

String pwd = console.input("Enter password: ", &opts);
console.println("Password length: " + String(pwd.length()));
```

*Этот пример читает пароль с маскировкой ввода и избегает сохранения его в истории.*

---

###### `bool ConsoleInput::multiline`

**Сигнатура**

```cpp
bool multiline;
```

**Краткое описание**
Разрешает многострочный ввод (Shift+Enter или Ctrl+Enter вставляют перевод строки).

**Назначение**

* Если `true`, `Console::input()` позволяет пользователю вставлять разрывы строк.
* Если `false`, нажатие Enter немедленно завершает ввод строки.

**Развернуто**

В режиме многострочности:

* Пользователь может вводить многострочный текст, например:

  * Блоки конфигурации.
  * Фрагменты сценариев.
  * Длинные сообщения или заметки.
* Специальные сочетания клавиш (например, **Shift+Enter** или **Ctrl+Enter**) вставляют перевод строки вместо завершения ввода.
* Строка `continuation` используется как приглашение для строк продолжения.

Итоговое возвращаемое значение из `Console::input()` — это одна `String`, которая может содержать символы `'\n'`.

**Пример**

```cpp
Console console;
ConsoleInput opts;

opts.multiline = true;
opts.continuation = String("... ");  // prompt for continuation lines

console.println("Enter a multi-line message (finish with plain Enter on an empty line).");
String text = console.input("> ", &opts);

console.println("You entered:");
console.println(text);
```

*Этот пример включает многострочный ввод с пользовательским приглашением для строк продолжения.*

---

###### `String ConsoleInput::continuation`

**Сигнатура**

```cpp
String continuation;
```

**Краткое описание**
Приглашение, отображаемое для строк продолжения в многострочном режиме.

**Назначение**

* Текст, используемый как приглашение, когда `multiline` равно `true` и пользователь продолжает ввод на следующей строке.
* Игнорируется, когда `multiline` равно `false`.

**Развернуто**

При использовании многострочного ввода:

* Первая строка использует параметр `prompt`, который вы передаёте в `Console::input()`.
* Каждая последующая строка использует `options->continuation`, что позволяет визуально отличать строки продолжения от начального приглашения.

Некоторые советы по дизайну:

* Выбирайте короткую строку продолжения, например `"… "` или `"  > "`.
* Избегайте длинных или многострочных приглашений; они могут мешать переносу текста.

Если оставить `continuation` по умолчанию `String()`, библиотека будет использовать пустое или встроенное приглашение для строк продолжения (зависит от реализации).

**Пример**

```cpp
Console console;
ConsoleInput opts;

opts.multiline = true;
opts.continuation = String("... ");

String text = console.input("> ", &opts);
// Additional lines the user enters will start with "... "
```

*Этот пример задаёт пользовательское приглашение для многострочного ввода, делая последующие строки визуально отличимыми.*

---

##### Методы-члены

---

###### `ConsoleInput::ConsoleInput()`

**Сигнатура**

```cpp
ConsoleInput();
```

**Краткое описание**
Создаёт параметры ввода по умолчанию (без автодополнения, без истории, однострочный, видимый).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Развернуто**

Конструктор по умолчанию инициализирует все поля в разумные значения по умолчанию:

* `completions = List()` – без автодополнения.
* `history = List()` – без истории команд.
* `password = false` – ввод видим.
* `multiline = false` – только однострочный ввод.
* `continuation = String()` – пустое приглашение для продолжения.

Можно создать `ConsoleInput` и затем настроить только те поля, которые вам нужны.

**Пример**

```cpp
ConsoleInput opts;  // all defaults: plain single-line input

opts.password = true;  // enable password masking only
```

*Этот пример создаёт параметры по умолчанию и затем изменяет только одно поле.*

---

###### `ConsoleInput::ConsoleInput(const ConsoleInput &other)`

**Сигнатура**

```cpp
ConsoleInput(const ConsoleInput &other);
```

**Краткое описание**
Создаёт копию другого `ConsoleInput`.

**Параметры**

* `other` – Существующий `ConsoleInput` для копирования.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Развернуто**

Конструктор копирования дублирует все поля конфигурации:

* Поля типа `List` (`completions`, `history`) копируются глубоко:
  * У оригинала и копии будут собственные отдельные копии всех элементов.
* Поля-значения (`password`, `multiline`, `continuation`) копируются по значению.

Используйте это, когда хотите начать с существующей конфигурации и изменить её немного.

**Пример**

```cpp
ConsoleInput base;
base.multiline = true;

ConsoleInput derived(base);
derived.password = true;  // separate configuration for another prompt
```

*Этот пример копирует базовую конфигурацию и затем меняет один флаг в копии.*

---

###### `ConsoleInput::~ConsoleInput()`

**Сигнатура**

```cpp
~ConsoleInput();
```

**Краткое описание**
Уничтожает `ConsoleInput`.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Развернуто**

Деструктор освобождает внутренние ресурсы, принадлежащие `ConsoleInput` (в основном поле `String continuation`). Он **не** освобождает экземпляры `List`, на которые могут ссылаться `completions` или `history`; это остаётся вашей ответственностью.

Это делает `ConsoleInput` дешёвым для создания и уничтожения и безопасным для хранения в стеке.

**Пример**

```cpp
{
  ConsoleInput opts;
  opts.password = true;
  // use opts...
}
// opts is destroyed here; continuation is cleaned up automatically
```

*Этот пример показывает использование `ConsoleInput` в локальной области видимости.*

---

###### `ConsoleInput &ConsoleInput::operator=(const ConsoleInput &other)`

**Сигнатура**

```cpp
ConsoleInput &operator=(const ConsoleInput &other);
```

**Краткое описание**
Присваивает этому объекту конфигурацию из другого `ConsoleInput`.

**Параметры**

* `other` – Исходная конфигурация для копирования.

**Возвращаемое значение**

* Ссылка на `*this`, позволяющая цепочку присваиваний.

**Развернуто**

Оператор присваивания заменяет текущую конфигурацию содержимым `other`:

* Поля типа `List` теперь указывают на копии тех же экземпляров `List`, что и у `other`.
* Булевы поля и `continuation` копируются по значению.

Самоприсваивание безопасно.

**Пример**

```cpp
ConsoleInput a;
ConsoleInput b;

a.password = true;
a.multiline = true;

b = a;  // b now has the same configuration as a
```

*Этот пример копирует конфигурацию из одного `ConsoleInput` в другой с помощью оператора присваивания.*

---
---

#### `String Console::input(const String &prompt = "", const ConsoleInput &options = ConsoleInput())`

**Сигнатура**

```cpp
String input(const String &prompt = "",
             const ConsoleInput &options = ConsoleInput());
```

**Краткое описание**
Считывает строку ввода с необязательным приглашением и продвинутыми опциями.
Поддерживает историю стрелками вверх/вниз, автодополнение по Tab с подсказками и т.д.
Возвращает пустую строку, если ввод отменён (Ctrl+C).

**Параметры**

* `prompt` – Текст, отображаемый перед областью ввода (например `"> "`).
* `options` – Структура конфигурации `ConsoleInput`. По умолчанию используется объект, созданный конструктором по умолчанию, если не указан.

**Возвращаемое значение**

* `String`, содержащая введённую пользователем строку, или пустая `String`, если ввод был отменён (например, через `Ctrl+C`).

**Развернуто**

`input()` — это высокоуровневая функция ввода, которая поддерживает:

* Текст приглашения (например `"> "`).
* Необязательную **историю**, если задано `options.history`:

  * Стрелки вверх/вниз для навигации по предыдущим командам.
* Необязательное **автодополнение по Tab**, если указано `options.completions`:

  * Подсказки на основе списка кандидатных строк.
* **Режим пароля**, когда `options.password` равно `true`:

  * Вводимые символы маскируются (например `'*'`).
* **Многострочный режим**, когда `options.multiline` равно `true`:

  * `Shift+Enter` или `Ctrl+Enter` вставляют перевод строки.
  * Строка `ConsoleInput::continuation` используется как приглашение для последующих строк.

Когда `options` создаётся конструктором по умолчанию, функция использует разумные значения по умолчанию:

* Без истории.
* Без автодополнения по Tab.
* Однострочный, видимый ввод.

Проверяйте пустой результат, чтобы определить отмену ввода.

**Пример**

```cpp
Console console;
ConsoleInput opts;

// Enable simple history:
List history;
opts.history = &history;

// Prompt for a command:
String line = console.input("> ", opts);

if (!line.isEmpty()) {
  console.println("You typed: " + line);
}
```

*Этот пример считывает строку с поддержкой истории и выводит её обратно.*

---

#### `String Console::readEvent()`

**Сигнатура**

```cpp
String readEvent();
```

**Краткое описание**
Считывает одно нажатие клавиши или событие мыши (блокирующе).
Возвращает описательную строку: "A", "Enter", "Space", "Ctrl+C", "Alt+X",
"F1", "MouseLeft@x,y", "MouseRight@x,y", "MouseMove@x,y" и т.д.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, описывающая событие в удобочитаемом формате.

**Развернуто**

`readEvent()` предоставляет низкоуровневый событийный ввод:

* Блокирует выполнение, пока не произойдёт событие клавиши или мыши.
* Возвращаемая строка описывает событие:

  * `"A"`, `"b"`, `"Enter"`, `"Space"`.
  * `"Ctrl+C"`, `"Alt+X"`, `"Shift+F1"`.
  * События мыши вроде `"MouseLeft@10,5"` или `"MouseMove@20,3"`.

Это полезно для:

* Собственных циклов обработки ввода.
* Интерактивных меню или игр.
* Обработки кликов мыши в конкретных областях экрана.

Вы можете разобрать возвращаемую строку для определения типа события и координат.

**Пример**

```cpp
Console console;

console.println("Press any key or click the mouse. Press Esc to quit.");

while (true) {
  String event = console.readEvent();
  console.println("Event: " + event);

  if (event == "Escape") {
    break;
  }
}
```

*Этот пример выводит каждое событие (клавиша или мышь) до тех пор, пока пользователь не нажмёт Escape.*

---

#### `Console &Console::progress(float percent, const String &label = "")`

**Сигнатура**

```cpp
Console &progress(float percent, const String &label = "");
```

**Краткое описание**
Показывает или обновляет анимированный индикатор выполнения внизу консоли.
percent: от 0.0 до 1.0 для детерминированного режима, или -1.0 для индикаторной спиннерной анимации.
Полоса плавно анимируется между значениями и подстраивается под изменение размера консоли.

**Параметры**

* `percent` – Значение прогресса:

  * Между `0.0` и `1.0` для детерминированного прогресса.
  * `-1.0` для недетерминированного спиннера (неизвестная длительность).
* `label` – Необязательный текстовый ярлык, отображаемый рядом с полосой.

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

`progress()` управляет постоянной полосой внизу консоли:

* Она резервирует место и обновляет только область полосы, сохраняя ваш основной UI нетронутым.
* Когда `percent` увеличивается между вызовами, полоса анимируется плавно.
* При изменении размера консоли макет полосы подстраивается под новую ширину.
* Используйте `percent == -1.0f`, когда длительность неизвестна и нужен просто индикатор активности.

Можно вызывать `progress()` многократно по мере продвижения задачи.

**Пример**

```cpp
Console console;

for (int i = 0; i <= 100; ++i) {
  float p = i / 100.0f;
  console.progress(p, "Processing...");
}
console.progressHide();
console.println("Done.");
```

*Этот пример симулирует выполнение задачи и обновляет полосу прогресса соответствующим образом.*

---

#### `Console &Console::progressHide()`

**Сигнатура**

```cpp
Console &progressHide();
```

**Краткое описание**
Скрывает полосу прогресса и восстанавливает линию.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

После одного или нескольких вызовов `progress()` используйте `progressHide()`, чтобы:

* Убрать полосу прогресса с экрана.
* Восстановить любое подлежащие содержимое или освободить строку для дальнейшего вывода.

Хорошая практика — вызывать эту функцию, когда операция завершена или отменена.

**Пример**

```cpp
Console console;

console.progress(-1.0f, "Working...");
// ... do some work ...
console.progressHide();
console.println("Operation finished.");
```

*Этот пример показывает недетерминированный индикатор и затем скрывает его.*

---

#### `int Console::menu(const List &options, const String &title = "")`

**Сигнатура**

```cpp
int menu(const List &options, const String &title = "");
```

**Краткое описание**
Показывает интерактивное меню и возвращает индекс выбранного пункта (с нуля).
Возвращает -1 при отмене (клавиша Escape).
Поддерживает стрелки, цифровые клавиши (1-9), наведение/клик мышью и прыжок по первой букве.

**Параметры**

* `options` – `List` пунктов меню; каждый элемент приводится к `String`.
* `title` – Необязательный заголовок, отображаемый над меню.

**Возвращаемое значение**

* Индекс выбранного варианта (с нуля), или `-1`, если пользователь отменил выбор (например, нажав Escape).

**Развернуто**

`menu()` управляет всей интерактивностью:

* Рендерит меню с подсветкой.
* Поддерживает различные методы ввода:

  * Стрелки для перемещения вверх/вниз.
  * Цифровые клавиши (`1`–`9`) для прямого перехода к пунктам.
  * Наведение и клик мышью для выбора.
  * Прыжок по первой букве: нажатие буквы переходит к следующему элементу, начинающемуся с этой буквы.
* Возвращает управление, когда пользователь выбирает элемент или отменяет меню.

Можно вызывать несколько раз для показа разных меню последовательно.

**Пример**

```cpp
Console console;

List options;
options.append("Start").append("Settings").append("Quit");

int choice = console.menu(options, "Main Menu");

if (choice == 0) {
  console.println("Starting...");
} else if (choice == 1) {
  console.println("Opening settings...");
} else if (choice == 2) {
  console.println("Quitting...");
} else {
  console.println("Menu cancelled.");
}
```

*Этот пример отображает простое главное меню и обрабатывает выбор пользователя.*

---

#### `Console &Console::onHotkey(const String &key, void (*callback)(void *), void *arg = nullptr)`

**Сигнатура**

```cpp
Console &onHotkey(const String &key, void (*callback)(void *),
                  void *arg = nullptr);
```

**Краткое описание**
Регистрирует неблокирующий глобальный хоткей.
Формат ключа: "Ctrl+Q", "Alt+X", "Shift+F1", "F12", "Ctrl+Shift+S".
Коллбек вызывается асинхронно при нажатии соответствующей клавиши.

**Параметры**

* `key` – Строка описания хоткея, например `"Ctrl+Q"` или `"F12"`.
* `callback` – Указатель на функцию-обработчик, принимающую `void *` аргумент.
* `arg` – Необязательный указатель на пользовательские данные, передаваемый в коллбек.

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

`onHotkey()` позволяет зарегистрировать **глобальные хоткеи**, которые:

* Мониторятся в фоновом режиме.
* Триггерят коллбек при нажатии комбинации клавиш.
* Не блокируют основной поток или цикл UI.

Это полезно для:

* Клавиш экстренного выхода (`"Ctrl+Q"`).
* Переключения представлений.
* Паузы/возобновления операций.

Важные замечания:

* Коллбеки выполняются асинхронно; избегайте длительных или блокирующих операций внутри них.
* Если вы изменяете общий ресурс из коллбека, обеспечьте синхронизацию (например, с помощью `Mutex` из библиотеки).

**Пример**

```cpp
void QuitCallback(void *arg) {
  Console *console = (Console *)arg;
  console->println("Quit hotkey pressed.");
  // You might set a global flag here to stop the main loop.
}

Console console;

console.onHotkey("Ctrl+Q", QuitCallback, &console);
console.println("Press Ctrl+Q to trigger the hotkey (and then exit).");

// In a real program, you would now run some loop or UI logic.
```

*Этот пример регистрирует хоткей Ctrl+Q, который печатает сообщение при срабатывании.*

---

#### `Console &Console::offHotkey(const String &key)`

**Сигнатура**

```cpp
Console &offHotkey(const String &key);
```

**Краткое описание**
Отменяет ранее зарегистрированный хоткей.

**Параметры**

* `key` – Строка описания хоткея, точно такая же, как использовалась в `onHotkey()`.

**Возвращаемое значение**

* Ссылка на `*this`.

**Развернуто**

`offHotkey()` отключает хоткей, чтобы он больше не вызывал свой коллбек. Используйте это:

* До уничтожения `Console`, если хотите прекратить прослушивание событий.
* Когда фича или режим, использующий хоткей, отключается.

Если ключ не зарегистрирован, вызов обычно ничего не делает.

**Пример**

```cpp
Console console;

console.onHotkey("Ctrl+Q", nullptr);  // Example registration (callback omitted)
console.offHotkey("Ctrl+Q");          // Disable the hotkey again
```

*Этот пример показывает, как отменить хоткей по имени ключа.*

---

#### `static String Console::Align(const String &text, int width, ConsoleAlign align = CON_ALIGN_LEFT)`

**Сигнатура**

```cpp
static String Align(const String &text, int width,
                    ConsoleAlign align = CON_ALIGN_LEFT);
```

**Краткое описание**
Возвращает текст с добавленным заполнением и выровненный по указанной ширине.
Полезно для формирования отформатированного вывода или таблиц.

**Параметры**

* `text` – Текст для выравнивания.
* `width` – Целевая ширина в символах.
* `align` – Режим выравнивания (`CON_ALIGN_LEFT`, `CON_ALIGN_CENTER`, `CON_ALIGN_RIGHT`, `CON_ALIGN_JUSTIFY`).

**Возвращаемое значение**

* `String`, содержащая выровненный и дополненный текст.

**Развернуто**

`Align()` — это **чистый помощник форматирования**:

* Он **не** печатает в консоль.
* Возвращает одну строку с добавленным заполнением по необходимости.
* Если текст длиннее `width`, он может быть усечён (в зависимости от реализации) или оставлен как есть; проектируйте ширины соответственно.

Это полезно для формирования выровненных колонок или форматирования текста перед выводом или логированием.

**Пример**

```cpp
Console console;

String label = Console::Align("Name", 10, CON_ALIGN_LEFT);
String value = Console::Align("Alice", 10, CON_ALIGN_RIGHT);

console.println(label + value);
// e.g., "Name          Alice"
```

*Этот пример строит отформатированную строку с левым выравниванием метки и правым выравниванием значения.*

---

#### `static String Console::Wrap(const String &text, int width)`

**Сигнатура**

```cpp
static String Wrap(const String &text, int width);
```

**Краткое описание**
Возвращает текст, перенесённый по словам, чтобы соответствовать указанной ширине.
Сохраняет существующие переводы строк и переносит по границам слов.

**Параметры**

* `text` – Исходный абзац(ы) для переноса.
* `width` – Максимальная ширина строки в символах.

**Возвращаемое значение**

* `String` с вставленными символами новой строки, чтобы каждая строка помещалась в `width`.

**Развернуто**

`Wrap()` принимает длинную строку и возвращает версию, в которой:

* Между словами вставлены переводы строк, чтобы длина каждой строки не превышала `width`.
* Сохраняются существующие переводы строк, поэтому можно обрабатывать многоабзацный текст.

Поскольку функция возвращает `String`, вы можете:

* Печатать её напрямую с помощью `println()` или `printWrapped()`.
* Дополнительно разбивать её с `lines()` или `split()`.

**Пример**

```cpp
Console console;

String text(
  "This is some long text that we want to wrap to a fixed width "
  "before printing it."
);

String wrapped = Console::Wrap(text, 40);
console.println(wrapped);
```

*Этот пример использует `Console::Wrap()` для форматирования абзаца по заданной ширине перед выводом.*