# Embedding

## Обзор

Класс `attoboy::Embedding` представляет собой **высокоразмерный числовой вектор**, создаваемый моделью ИИ и обычно используемый для задач **семантического сравнения**. Вместо прямой генерации текста модель эмбеддингов отображает фрагмент текста (например, предложение, абзац или документ) в вектор значений типа `float`. Векторы для семантически похожих текстов оказываются «близко друг к другу» в этом высокоразмерном пространстве.

В библиотеке attoboy:

* Эмбеддинги создаются классом `AI` через `AI::createEmbedding`.
* Объекты `Embedding` являются **только для чтения** и предоставляют вид на эти векторы.
* Вы можете:

  * Вычислять **косинусное сходство** между двумя эмбеддингами с помощью `compare`.
  * Просматривать количество измерений через `getDimensions`.
  * Получать доступ к сырым данным `float` через `getRawArray`, когда требуется ручная обработка.

Вы никогда не создаёте `Embedding` напрямую через `new` или публичный конструктор; вместо этого вы запрашиваете его у экземпляра `AI`.

### Что такое вектор эмбеддинга?

Эмбеддинг — это вектор:

* **Вектор** в данном контексте — это просто упорядоченный список чисел: [v₀, v₁, …, vₙ₋₁].
* Каждый `Embedding` предоставляет:

  * `getDimensions()` — сколько чисел он содержит.
  * `getRawArray()` — указатель на первый элемент подлежащего массива `float`.

Точное значение каждой размерности зависит от модели и является непрозрачным. Вы рассматриваете вектор как **представление признаков**, которое захватывает семантические свойства исходного текста.

### Косинусное сходство

Основная операция над эмбеддингами — это **косинусное сходство**, реализованное методом `Embedding::compare`:

* Косинусное сходство измеряет косинус угла между двумя векторами в высокоразмерном пространстве.
* Результат лежит в диапазоне **[-1, 1]**:

  * `1.0` → векторы направлены в точности в одну сторону (максимально похожи).
  * `0.0` → векторы ортогональны (нет линейной корреляции).
  * `-1.0` → векторы направлены в противоположные стороны (максимально различны в определённом смысле).

На практике, для текстовых эмбеддингов современных моделей ИИ:

* Значения обычно находятся между `0.0` и `1.0`.
* Более высокие значения указывают на более похожие тексты.
* Очень низкие значения указывают на несвязанный контент.

### Типичный рабочий процесс

Обычный сценарий работы с эмбеддингами в attoboy выглядит так:

1. Настроить клиент `AI`.
2. Вызвать `AI::createEmbedding(text)`, чтобы получить `Embedding`.
3. Сохранить эмбеддинг (или его сырые float-значения) для последующего использования.
4. Сравнивать эмбеддинги при помощи `Embedding::compare` для измерения похожести.

Например, вы можете:

* Построить **семантический поисковый индекс**, эмбеддя все документы и сравнивая эмбеддинг запроса пользователя с сохранёнными.
* Кластеризовать похожие тексты, сравнивая попарные значения сходства.
* Реализовать систему рекомендаций, которая находит «похожие элементы» на основе их текстовых описаний.

### Неизменяемость и время жизни

Объекты `Embedding` концептуально **неизменяемы**:

* После создания вы не можете изменить подлежащий вектор через публичный API.
* Копирование или присваивание `Embedding` разделяет подлежащие данные, не дублируя их.

Время жизни и владение:

* Объект `Embedding` управляет своей подлежащей памятью через RAII.
* Когда последний `Embedding`, ссылающийся на конкретный вектор, уничтожается, память освобождается.
* Указатели, возвращаемые `getRawArray()`, остаются действительны только пока жив объект `Embedding`.

Если `AI::createEmbedding` завершается неудачей, он возвращает `Embedding` с `getDimensions() == 0`. Всегда проверяйте количество измерений перед использованием эмбеддинга.

---

## Справочная информация

Каждый пункт ниже описывает публичный конструктор, метод или оператор `attoboy::Embedding`. Для каждого вы найдёте:

* **Сигнатура** — точное объявление из заголовка.
* **Краткое описание** — оригинальный однострочный комментарий Doxygen.
* Описания **параметров** и **возвращаемого значения**.
* **Подробно** — детали поведения, оговорки и пример использования.

> Все примеры предполагают `using namespace attoboy;`.

---

#### `Embedding(const Embedding &other)`

**Сигнатура**

```cpp
Embedding(const Embedding &other);
```

**Краткое описание**
Создаёт копию (разделяет подлежащие данные).

**Параметры**

* `other` – Существующий экземпляр `Embedding` для копирования.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Конструктор копирования создаёт новый объект `Embedding`, который **делит** подлежащие данные вектора с `other`:

* Новый вектор не выделяется; существующий вектор либо подсчитывается по ссылкам, либо иным образом разделяется во внутренней реализации.
* Оба объекта `Embedding` просматривают одни и те же данные.
* Уничтожение одного не инвалидирует другой, пока существует хотя бы один `Embedding`, ссылающийся на данные.

Такое поверхностное разделение делает копирование объектов `Embedding` эффективным, что полезно при:

* Передаче их по значению между функциями.
* Хранении их в коллекциях, управляемых вашим кодом (например, `List` эмбеддингов attoboy, представленных косвенно, например индексами или внешним хранилищем).

Помните, что вы не конструируете эмбеддинги напрямую; вы получаете их через `AI::createEmbedding` и затем копируете по необходимости.

**Пример**

```cpp
using namespace attoboy;

AI ai(String("https://api.openai.com/v1"),
      String("sk-123456"),
      String("text-embedding-3-small"));

Embedding original = ai.createEmbedding("Hello world", -1, 1536);

if (original.getDimensions() > 0) {
  // Create another handle to the same underlying embedding vector.
  Embedding copy(original);

  float similarity = original.compare(copy);  // Should be very close to 1.0
}
```

*Этот пример создаёт эмбеддинг с помощью `AI::createEmbedding` и затем копирует его с помощью конструктора копирования; оба дескриптора разделяют один и тот же подлежащий вектор.*

---

#### `~Embedding()`

**Сигнатура**

```cpp
~Embedding();
```

**Краткое описание**
Уничтожает эмбеддинг и освобождает ресурсы.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробно**

Деструктор освобождает дескриптор `Embedding` на подлежащие данные:

* Если это последний `Embedding`, ссылающийся на вектор, данные освобождаются.
* Любые указатели, ранее полученные от `getRawArray()`, становятся недействительными после уничтожения.

Поскольку `Embedding` использует RAII, вам не нужно вручную освобождать память или выполнять очистку. Применяются обычные правила времени жизни в C++: когда `Embedding` выходит из области видимости, вызывается его деструктор.

**Пример**

```cpp
using namespace attoboy;

Embedding storedEmbedding = /* ... obtained from AI::createEmbedding ... */;

// When `storedEmbedding` goes out of scope, its destructor is called and
// its resources are released when no other references remain.
```

*Этот пример показывает эмбеддинг, ресурсы которого автоматически освобождаются при выходе из области видимости.*

---

#### `Embedding &operator=(const Embedding &other)`

**Сигнатура**

```cpp
Embedding &operator=(const Embedding &other);
```

**Краткое описание**
Присваивает другой эмбеддинг (разделяет подлежащие данные).

**Параметры**

* `other` – Существующий `Embedding` для присваивания.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочку присваиваний.

**Подробно**

Оператор присваивания делает так, что `*this` ссылается на **тот же подлежащий вектор**, что и `other`:

* Любая предыдущая связь `*this` снимается; если это была последняя ссылка на те данные, они освобождаются.
* После присваивания `*this` и `other` разделяют одни и те же значения эмбеддинга.
* Оба могут использоваться независимо как дескрипторы к одному и тому же вектору только для чтения.

Самоприсваивание безопасно и обрабатывается реализацией.

Это поведение согласуется с конструктором копирования: и копирование, и присваивание разделяют подлежащие данные, а не выполняют глубокое копирование.

**Пример**

```cpp
using namespace attoboy;

Embedding e1 = /* ... */;
Embedding e2 = /* ... */;

// Now e2 will share the same vector as e1.
e2 = e1;

float sim = e1.compare(e2);  // Should be near 1.0
```

*В этом примере один эмбеддинг присваивается другому, в результате чего получаются два дескриптора на один и тот же подлежащий вектор.*

---

#### `float compare(const Embedding &other) const`

**Сигнатура**

```cpp
float compare(const Embedding &other) const;
```

**Краткое описание**
Вычисляет косинусное сходство с другим эмбеддингом. Возвращает значение в диапазоне [-1, 1].

**Параметры**

* `other` – Другой `Embedding` для сравнения с `*this`.

**Возвращаемое значение**

* `float`, представляющий косинусное сходство между двумя эмбеддингами:

  * Диапазон: **[-1.0, 1.0]**.
  * Более высокие значения означают более похожие векторы.

**Подробно**

`compare` вычисляет **косинусное сходство** между двумя эмбеддингами:

* Концептуально это измеряет угол между двумя векторами:

  * `1.0` → векторы идентичны по направлению.
  * `0.0` → векторы ортогональны (нет линейной корреляции).
  * `-1.0` → векторы направлены в противоположные стороны.

Практические рекомендации:

* Для типичных текстовых эмбеддингов современных моделей:

  * Значения близкие к `1.0` означают очень похожие тексты.
  * Значения около `0.5`–`0.8` часто указывают на связанные, но не идентичные концепции.
  * Значения около `0.0` или отрицательные указывают на несвязанный или существенно отличающийся контент.

Вы должны сравнивать только эмбеддинги, которые:

* Получены от **одной и той же модели** (или моделей, которые намеренно разделяют пространство эмбеддингов).
* Имеют **одинаковую размерность** (возвращаемое `getDimensions()` значение одинаково).

Сравнение эмбеддингов с разной размерностью или от неродственных моделей не даст осмысленных результатов сходства.

Краевые случаи:

* Если у одного или обоих эмбеддингов `getDimensions() == 0`, результат для вас неопределёнен; рассматривайте это как ошибочный случай и избегайте вызова `compare`, пока не проверите размерности.
* Если внутренняя реализация обнаружит несовместимые эмбеддинги, она может вернуть значение по умолчанию (например, `0.0`); всегда обеспечивайте совместимость эмбеддингов на этапе их создания, а не полагайтесь на возвращаемое значение.

**Пример**

```cpp
using namespace attoboy;

AI ai(String("https://api.openai.com/v1"),
      String("sk-123456"),
      String("text-embedding-3-small"));

Embedding eQuery  = ai.createEmbedding("best pizza in New York", -1, 1536);
Embedding eDoc1   = ai.createEmbedding("A guide to New York pizza slices", -1, 1536);
Embedding eDoc2   = ai.createEmbedding("How to care for indoor plants", -1, 1536);

if (eQuery.getDimensions() > 0 &&
    eDoc1.getDimensions()   > 0 &&
    eDoc2.getDimensions()   > 0) {

  float sim1 = eQuery.compare(eDoc1);
  float sim2 = eQuery.compare(eDoc2);

  // sim1 should be significantly higher than sim2, indicating that
  // the pizza article is more relevant to the query than the plants article.
}
```

*В этом примере эмбеддинг запроса сравнивается с двумя эмбеддингами документов, и косинусное сходство используется для определения, какой документ более релевантен.*

---

#### `const float *getRawArray() const`

**Сигнатура**

```cpp
const float *getRawArray() const;
```

**Краткое описание**
Возвращает указатель на сырой массив float.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Указатель на первый элемент внутреннего массива `float`, представляющего вектор эмбеддинга.
* Может быть `nullptr`, если эмбеддинг недействителен (например, `getDimensions() == 0`).

**Подробно**

`getRawArray()` предоставляет низкоуровневый доступ к подлежащим данным эмбеддинга:

* Массив содержит ровно `getDimensions()` элементов.
* Данные **только для чтения**; вы не должны изменять их через этот указатель.
* Указатель остаётся действителен, пока живёт объект `Embedding` (и любые его разделяемые копии).

Типичные сценарии использования:

* Реализация собственных метрик похожести или расстояния помимо косинусного сходства.
* Экспорт вектора в другую систему (например, запись в файл, отправка по сети или передача в другую библиотеку).
* Преобразование эмбеддинга в другое представление (например, квантизация в целые числа) для хранения.

Всегда проверяйте `getDimensions()` перед использованием указателя. Если эмбеддинг недействителен (размерность `0`), не разыменовывайте указатель.

**Пример**

```cpp
using namespace attoboy;

AI ai(String("https://api.openai.com/v1"),
      String("sk-123456"),
      String("text-embedding-3-small"));

Embedding emb = ai.createEmbedding("example text", -1, 1536);

int dims = emb.getDimensions();
if (dims > 0) {
  const float *data = emb.getRawArray();

  // For demonstration: compute the sum of all components.
  float sum = 0.0f;
  for (int i = 0; i < dims; ++i) {
    sum = sum + data[i];
  }

  // `sum` now holds the simple aggregate of the embedding components.
}
```

*Этот пример получает доступ к сырому массиву float и вычисляет простую агрегированную сумму по всем измерениям.*

---

#### `int getDimensions() const`

**Сигнатура**

```cpp
int getDimensions() const;
```

**Краткое описание**
Возвращает количество измерений.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Количество компонентов `float` в векторе эмбеддинга.
* `0`, если эмбеддинг недействителен или неинициализирован.

**Подробно**

`getDimensions()` сообщает, сколько значений содержит эмбеддинг. Это важно для:

* Проверки успешности создания эмбеддинга:

  * `> 0` → эмбеддинг действителен.
  * `0` → ошибка или неинициализированный эмбеддинг (например, `AI::createEmbedding` завершился неудачей).
* Убеждения в том, что два эмбеддинга можно осмысленно сравнивать или обрабатывать вместе.
* Определения границ цикла при итерации по сырому массиву из `getRawArray()`.

Как отмечено в документации класса `AI`, типичный контракт таков:

* Если `AI::createEmbedding` завершается неудачей, он возвращает `Embedding`, для которого `getDimensions() == 0`.

Всегда проверяйте это значение перед выполнением операций, предполагающих непустой вектор.

**Пример**

```cpp
using namespace attoboy;

AI ai(String("https://api.openai.com/v1"),
      String("sk-123456"),
      String("text-embedding-3-small"));

Embedding emb = ai.createEmbedding("hello world", -1, 1536);

int dims = emb.getDimensions();
if (dims <= 0) {
  // Embedding creation failed; handle the error.
} else {
  // Safe to use the embedding: dims components are available.
}
```

*В этом примере проверяется число измерений, чтобы определить, успешно ли создан эмбеддинг, прежде чем его использовать.*