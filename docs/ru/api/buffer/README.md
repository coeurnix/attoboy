# Buffer

## Обзор

Класс `attoboy::Buffer` — это основной контейнер для **двоичных данных** в библиотеке attoboy. Если `String` предназначен для человеко-читаемого текста, то `Buffer` предназначен для **сырых байтов**: содержимого файлов, сетевых пакетов, зашифрованных полезных нагрузок, сжатых данных и любой другой не-текстовой информации.

Ключевые характеристики:

* **Изменяемый**: операции вроде `append`, `prepend`, `insert`, `remove` и `reverse` изменяют буфер на месте и возвращают `*this` для цепочек вызовов.
* **Ориентирован на байты**: все индексы и длины выражены в байтах, а не в символах.
* **Богатый функционал**: поддерживает сжатие LZ4, шифрование ChaCha20, кодирование Base64 и преобразование в/из `String`.
* **Основан на RAII**: память для буфера управляется автоматически; вам не нужно вручную вызывать `free()`.

В общих чертах `Buffer` можно рассматривать как небольшую, специализированную замену комбинации `std::vector<unsigned char>` и различных вспомогательных библиотек для сжатия, шифрования и кодирования — реализованную в компактной, дружественной к двоичным данным форме.

### Байты и двоичные данные

В отличие от `String`, который работает с **Unicode-символами**, `Buffer` работает с **байтами**:

* Каждый элемент — это `unsigned char` (0–255).
* Все индексации ведутся по смещению в байтах от начала (с нуля).
* Не предпринимается попыток интерпретировать байты как текст, если вы явно не вызовете `toString()` или не создадите `Buffer` из `String`.

Типичные применения включают:

* Чтение и запись файлов через `File` и `Path`.
* Обработку бинарных ответов от `WebRequest` через `WebResponse::asBuffer()`.
* Управление сжатыми или зашифрованными данными.

### Изменяемость и цепочки вызовов

Большинство изменяющих операций над `Buffer`:

* Изменяют буфер **на месте**.
* Возвращают `Buffer &`, чтобы вы могли состыковывать вызовы:

```cpp
using namespace attoboy;

Buffer buf;
buf.append("header")
   .append("payload")
   .reverse()
   .trim();
```

Это отличается от `String`, который неизменяем и всегда возвращает новые значения.

### Сжатие (LZ4) и кодирование (Base64)

`Buffer` поддерживает две распространённые операции над двоичными данными:

* **Сжатие LZ4** (`compress()` / `decompress()`):

  * LZ4 — быстрый, безпотерьный алгоритм сжатия.
  * Используйте `compress()`, чтобы уменьшить объём хранилища или трафика для данных, поддающихся сжатию (например, текст, JSON, логи).
  * Используйте `decompress()`, чтобы обратить операцию над данными, ранее полученными с `compress()`.

* **Кодирование Base64** (`toBase64()` / `fromBase64()`):

  * Base64 преобразует произвольные байты в `String`, использующий только ASCII-символы.
  * Это полезно, когда нужно отправить двоичные данные через тексто-ограниченные каналы (например, JSON, некоторые API, логи).

### Шифрование ChaCha20

`Buffer::crypt()` предоставляет симметричное шифрование/дешифрование с использованием **ChaCha20**, современного потокового шифра:

* **Симметричное** означает, что для шифрования и расшифровки используется одна и та же функция и ключ.
* Вы должны предоставить:

  * **ключ** не менее 32 байт.
  * **nonce** (иногда называемый вектором инициализации) не менее 12 байт.

Важное свойство:

```cpp
encrypted = plain.crypt(key, nonce);
decrypted = encrypted.crypt(key, nonce); // same key+nonce
// decrypted contains the original bytes
```

Это упрощает защиту чувствительных данных в файлах, конфигурациях или сетевых сообщениях.

### Взаимодействие с `String` и другими типами attoboy

`Buffer` органично интегрируется с остальной частью библиотеки:

* Создавайте `Buffer` из байтов `String` и обратно через `toString()`.
* Используйте `File` для чтения и записи объектов `Buffer` на диск или сокеты.
* Используйте `WebResponse::asBuffer()` для получения сырого тела HTTP-ответов.
* Используйте `Buffer::toBase64()` и `Buffer::fromBase64()` для перехода между двоичным и текстовым представлениями.

---

## Справочник

Каждый элемент ниже описывает один публичный конструктор, метод, статическую функцию или оператор `attoboy::Buffer`. Для каждого вы найдёте:

* **Сигнатура** – точное объявление из заголовочного файла.
* **Кратко** – исходная однострочная Doxygen-пометка.
* **Параметры** и **Возвращаемое значение**.
* **Подробно** – детали, оговорки и короткий пример использования.

> **Примечание:** Все примеры предполагают `using namespace attoboy;`.

---

#### `Buffer()`

**Сигнатура**

```cpp
Buffer();
```

**Кратко**
Создаёт пустой буфер.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Конструктор по умолчанию создаёт буфер со следующими свойствами:

* Длина `0`.
* Нет выделенного содержимого (или минимальное внутреннее представление).
* `isEmpty()` возвращает `true`.

Обычно вы начинаете с пустого буфера и затем наращиваете его при помощи `append`, `prepend` или `insert`.

**Пример**

```cpp
Buffer buf;
bool empty = buf.isEmpty();  // true
```

*Этот пример создаёт пустой буфер и проверяет, что он не содержит байтов.*

---

#### `Buffer(int capacity)`

**Сигнатура**

```cpp
Buffer(int capacity);
```

**Кратко**
Создаёт пустой буфер с зарезервированной вместимостью.

**Параметры**

* `capacity` – Количество байтов для внутреннего резервирования.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот конструктор выделяет внутреннее хранилище как минимум для `capacity` байтов, но сохраняет **длину** равной нулю. Полезен, когда вы заранее примерно знаете, сколько байтов будете добавлять, и хотите минимизировать реаллокации.

Даже при зарезервированной вместимости:

* `length()` равен `0`.
* `isEmpty()` возвращает `true`.

**Пример**

```cpp
Buffer buf(1024);  // reserve space for ~1 KB
buf.append("header");
```

*Этот пример резервирует место для эффективного роста перед добавлением данных.*

---

#### `Buffer(const String &str)`

**Сигнатура**

```cpp
Buffer(const String &str);
```

**Кратко**
Создаёт буфер, копируя байты строки.

**Параметры**

* `str` – `String`, байты UTF-8 которого будут скопированы в буфер.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот конструктор копирует сырые UTF-8-байты из `str` (как возвращаемые `str.c_str()` и `str.byteLength()`) в буфер. Длина буфера становится равной числу байтов в строке, и в конце не добавляется нуль-терминатор сверх хранимой длины.

Используйте это, когда вам нужна двоичная репрезентация текста для хеширования, шифрования или других бинарных протоколов.

**Пример**

```cpp
String text("Hello, world");
Buffer buf(text);  // contains the UTF-8 bytes of the string
int len = buf.length();  // equal to text.byteLength()
```

*Этот пример конвертирует `String` в двоичный буфер с теми же UTF-8-байтами.*

---

#### `Buffer(const unsigned char *ptr, int size)`

**Сигнатура**

```cpp
Buffer(const unsigned char *ptr, int size);
```

**Кратко**
Создаёт буфер, копируя байты из указателя.

**Параметры**

* `ptr` – Указатель на последовательность байтов.
* `size` – Число байтов для копирования из `ptr`.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот конструктор — низкоуровневый мост от сырой памяти к `Buffer`. Он копирует ровно `size` байтов из `ptr` в буфер. Байты считаются непрозрачными; никакой интерпретации как текста не выполняется.

Подходит, когда:

* Вы получаете байты от внешнего API.
* У вас есть массив фиксированного размера или структура, которую вы хотите сохранить «как есть».

**Пример**

```cpp
unsigned char raw[4] = {0x01, 0x02, 0x03, 0x04};
Buffer buf(raw, 4);
int len = buf.length();  // 4
```

*Этот пример создаёт буфер из небольшого массива байтов в памяти.*

---

#### `Buffer(const Buffer &other)`

**Сигнатура**

```cpp
Buffer(const Buffer &other);
```

**Кратко**
Создаёт копию другого буфера.

**Параметры**

* `other` – Существующий `Buffer` для копирования.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Конструктор копирования создаёт новый `Buffer` с тем же содержимым, что и `other`. Поскольку `Buffer` изменяем, последующие изменения одного буфера не затрагивают другой.

**Пример**

```cpp
Buffer original;
original.append("data");

Buffer copy(original);
// copy now has the same bytes as original
```

*Этот пример дублирует содержимое существующего буфера.*

---

#### `~Buffer()`

**Сигнатура**

```cpp
~Buffer();
```

**Кратко**
Уничтожает буфер и освобождает память.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробно**

Когда `Buffer` выходит из области видимости, его деструктор освобождает любую внутренне выделенную память. Это реализовано через семантику RAII; вам не нужно вручную вызывать free или delete.

**Пример**

```cpp
{
  Buffer temp;
  temp.append("temporary");
} // temp is destroyed here; memory is freed
```

*Этот пример показывает автоматическую очистку буфера при выходе из области видимости.*

---

#### `Buffer &operator=(const Buffer &other)`

**Сигнатура**

```cpp
Buffer &operator=(const Buffer &other);
```

**Кратко**
Присваивает этому буферу содержимое другого буфера.

**Параметры**

* `other` – Буфер, содержимое которого должно быть скопировано в `*this`.

**Возвращаемое значение**

* Ссылка на `*this` для цепочек присваивания.

**Подробно**

Оператор присваивания заменяет содержимое левой части копией `other`. Любые прежние байты в буфере отбрасываются. Самоприсваивание безопасно.

**Пример**

```cpp
Buffer a;
a.append("first");

Buffer b;
b.append("second");

a = b;  // a now contains "second"
```

*Этот пример присваивает содержимое одного буфера другому.*

---

#### `int length() const`

**Сигнатура**

```cpp
int length() const;
```

**Кратко**
Возвращает количество байтов в буфере.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Текущая длина буфера в байтах.

**Подробно**

`length()` — это основной способ узнать, сколько данных в буфере. Она не включает дополнительную внутреннюю резервированную ёмкость.

Используйте её при итерации по байтам, проверке ограничений по размеру или подготовке буфера к записи в файл или сокет.

**Пример**

```cpp
Buffer buf;
buf.append("ABC");
int n = buf.length();  // 3
```

*Этот пример проверяет, сколько байтов хранится в буфере.*

---

#### `bool isEmpty() const`

**Сигнатура**

```cpp
bool isEmpty() const;
```

**Кратко**
Возвращает true, если буфер пуст.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если `length()` равно `0`; иначе `false`.

**Подробно**

`isEmpty()` — удобная функция, эквивалентная проверке `length() == 0`. Полезна для раннего выхода или защиты операций, требующих наличия данных.

**Пример**

```cpp
Buffer buf;
if (buf.isEmpty()) {
  buf.append("default");
}
```

*Этот пример добавляет значение по умолчанию, когда буфер пуст.*

---

#### `const unsigned char *c_ptr(int *len) const`

**Сигнатура**

```cpp
const unsigned char *c_ptr(int *len) const;
```

**Кратко**
Возвращает указатель на данные и записывает в len размер.

**Параметры**

* `len` – Указатель на `int`, который будет установлен в текущее значение `length()`.

**Возвращаемое значение**

* Указатель на внутренний массив байтов для чтения, или `nullptr`, если буфер пуст (в зависимости от реализации).

**Подробно**

`c_ptr()` предоставляет низкоуровневый доступ к содержимому буфера:

* Устанавливает `*len` в число валидных байтов.
* Возвращаемый указатель остаётся действительным до тех пор, пока:

  * `Buffer` существует, и
  * вы не вызываете изменяющие операции, которые могут перераспределить память (например, `append`, `insert` или `remove`).

Нельзя изменять память через этот указатель.

**Пример**

```cpp
Buffer buf;
buf.append("ABC");

int len = 0;
const unsigned char *ptr = buf.c_ptr(&len);
// len == 3; ptr points to bytes 'A', 'B', 'C'
```

*Этот пример получает сырой указатель и длину для взаимодействия с низкоуровневыми API.*

(Комментарий в коде переведен: // len == 3; ptr указывает на байты 'A', 'B', 'C')

---

#### `Buffer &clear()`

**Сигнатура**

```cpp
Buffer &clear();
```

**Кратко**
Удаляет все байты. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`, позволяющая составлять цепочки вызовов.

**Подробно**

`clear()` сбрасывает буфер в пустое состояние (`length() == 0`). Он может сохранить зарезервированную вместимость для повторного использования при последующих `append`, но логическое содержимое удаляется.

**Пример**

```cpp
Buffer buf;
buf.append("data");
buf.clear();  // buf is now empty
```

*Этот пример удаляет все байты из буфера для повторного использования.*

(Комментарий в коде переведен: // buf теперь пуст)

---

#### `Buffer &append(const String &str)`

**Сигнатура**

```cpp
Buffer &append(const String &str);
```

**Кратко**
Добавляет байты строки в конец. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `str` – `String`, байты UTF-8 которого будут добавлены в буфер.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

Этот метод:

* Берёт сырые байты `str` (через его UTF-8 представление).
* Дописывает их в конец текущего содержимого буфера.
* Увеличивает `length()` соответственно.

Он не добавляет никаких дополнительных терминаторов или разделителей.

**Пример**

```cpp
Buffer buf;
buf.append("header")
   .append("payload");
// buffer now contains "headerpayload" bytes
```

*Этот пример добавляет байты двух строк, формируя одну последовательность байтов.*

(Комментарий в коде переведен: // буфер теперь содержит байты "headerpayload")

---

#### `Buffer &append(const Buffer &other)`

**Сигнатура**

```cpp
Buffer &append(const Buffer &other);
```

**Кратко**
Добавляет байты другого буфера. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `other` – `Buffer`, байты которого будут добавлены.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

Этот метод копирует все байты из `other` в конец текущего буфера. Эквивалентно:

```cpp
int len = 0;
const unsigned char *ptr = other.c_ptr(&len);
append(ptr, len);
```

**Пример**

```cpp
Buffer a;
a.append("ABC");

Buffer b;
b.append("DEF");

a.append(b);  // a now contains "ABCDEF"
```

*Этот пример конкатенирует два буфера, добавляя второй к первому.*

(Комментарий в коде переведен: // a теперь содержит "ABCDEF")

---

#### `Buffer &append(const unsigned char *ptr, int size)`

**Сигнатура**

```cpp
Buffer &append(const unsigned char *ptr, int size);
```

**Кратко**
Добавляет байты из указателя. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `ptr` – Указатель на байты для добавления.
* `size` – Количество байтов для добавления.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

Это низкоуровневая операция добавления для сырой памяти:

* Копирует `size` байтов начиная с `ptr`.
* Не инспектирует и не модифицирует их.
* Вы отвечаете за то, чтобы `ptr` указывал на как минимум `size` валидных байтов.

**Пример**

```cpp
unsigned char footer[2] = {0x0D, 0x0A};  // CR LF
Buffer buf;
buf.append("line").append(footer, 2);
// buf now has "line\r\n"
```

*Этот пример добавляет двухбайтовую последовательность в существующие данные.*

(Комментарий в коде переведен: // buf теперь содержит "line\r\n")

---

#### `Buffer &prepend(const String &str)`

**Сигнатура**

```cpp
Buffer &prepend(const String &str);
```

**Кратко**
Вставляет байты строки в начало. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `str` – `String`, байты которого будут вставлены в начало.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`prepend()` вставляет байты `str` в начало буфера, сдвигая существующие байты к большим индексам.

**Пример**

```cpp
Buffer buf;
buf.append("body");
buf.prepend("header");
// buffer contains "headerbody"
```

*Этот пример вставляет заголовок перед существующими данными.*

(Комментарий в коде переведен: // буфер содержит "headerbody")

---

#### `Buffer &prepend(const Buffer &other)`

**Сигнатура**

```cpp
Buffer &prepend(const Buffer &other);
```

**Кратко**
Вставляет байты другого буфера в начало. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `other` – Буфер, байты которого будут вставлены в начало.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

Этот метод копирует все байты из `other` в начало текущего буфера, перед любыми уже существующими данными.

**Пример**

```cpp
Buffer header;
header.append("HDR");

Buffer payload;
payload.append("DATA");

payload.prepend(header);  // payload now "HDRDATA"
```

*Этот пример вставляет заголовок перед полезной нагрузкой.*

(Комментарий в коде переведен: // payload теперь "HDRDATA")

---

#### `Buffer &prepend(const unsigned char *ptr, int size)`

**Сигнатура**

```cpp
Buffer &prepend(const unsigned char *ptr, int size);
```

**Кратко**
Вставляет байты из указателя в начало. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `ptr` – Указатель на байты для вставки.
* `size` – Количество байтов для вставки.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

Это вариант `prepend` для сырой памяти. Он вставляет указанные байты по индексу `0`. Существующее содержимое сдвигается, чтобы освободить место.

**Пример**

```cpp
unsigned char magic[2] = {0xAB, 0xCD};
Buffer buf;
buf.append("DATA");
buf.prepend(magic, 2);
// buffer starts with magic bytes followed by "DATA"
```

*Этот пример добавляет бинарный префикс перед данными.*

(Комментарий в коде переведен: // буфер начинается с магических байтов, затем "DATA")

---

#### `Buffer &insert(int index, const String &str)`

**Сигнатура**

```cpp
Buffer &insert(int index, const String &str);
```

**Кратко**
Вставляет байты строки по индексу. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `index` – Байтовый индекс, по которому вставляются байты (0-based).
* `str` – `String`, байты которого будут вставлены.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

Этот метод:

* Интерпретирует `index` как позицию в байтах между `0` и `length()`.
* Вставляет UTF-8-байты `str` в указанную позицию.
* Сдвигает существующие байты от `index` и дальше в конец.

Убедитесь, что `0 <= index <= length()`; значения за пределами этой области имеют поведение, определяемое реализацией.

**Пример**

```cpp
Buffer buf;
buf.append("Hello world");
buf.insert(5, ",");  // insert comma after "Hello"
// buffer bytes now represent "Hello, world"
```

*Этот пример вставляет байты строки в середину существующих данных.*

(Комментарий в коде переведен: // байты буфера теперь представляют "Hello, world")

---

#### `Buffer &insert(int index, const Buffer &other)`

**Сигнатура**

```cpp
Buffer &insert(int index, const Buffer &other);
```

**Кратко**
Вставляет байты другого буфера по индексу. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `index` – Байтовый индекс, по которому вставляются байты.
* `other` – Буфер, байты которого будут вставлены.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

Этот вариант вставляет все байты из `other` в указанную позицию. По сути это сплайсинг содержимого `other` в этот буфер.

**Пример**

```cpp
Buffer buf;
buf.append("Hello world");

Buffer comma;
comma.append(",");

buf.insert(5, comma);
// same result as using the string variant
```

*Этот пример вставляет один буфер в другой по определённому байтовому индексу.*

(Комментарий в коде переведен: // тот же результат, что и при использовании варианта со строкой)

---

#### `Buffer &insert(int index, const unsigned char *ptr, int size)`

**Сигнатура**

```cpp
Buffer &insert(int index, const unsigned char *ptr, int size);
```

**Кратко**
Вставляет байты из указателя по индексу. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `index` – Байтовый индекс, где начинается вставка.
* `ptr` – Указатель на байты для вставки.
* `size` – Количество байтов для вставки.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

Это низкоуровневый вариант `insert`. Используйте его, когда у вас есть байты в массиве или внешнем буфере, которые нужно врезать в этот `Buffer`.

**Пример**

```cpp
unsigned char marker[3] = {0x01, 0x02, 0x03};
Buffer buf;
buf.append("DATA");
buf.insert(0, marker, 3);
// buf begins with three marker bytes, followed by "DATA"
```

*Этот пример вставляет маркерную последовательность в начало буфера.*

(Комментарий в коде переведен: // buf начинается с трёх маркерных байтов, затем "DATA")

---

#### `Buffer &remove(int start, int end = -1)`

**Сигнатура**

```cpp
Buffer &remove(int start, int end = -1);
```

**Кратко**
Удаляет байты от start до end. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* `start` – Байтовый индекс первого удаляемого байта.
* `end` – Байтовый индекс **после** последнего удаляемого байта (исключительно). Если `end` == `-1`, удаление продолжается до конца буфера.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`remove()` удаляет непрерывный диапазон байтов. После удаления более поздние байты сдвигаются, чтобы заполнить разрыв, и `length()` уменьшается.

Типичные паттерны:

* `remove(0, n)` — удалить первые `n` байтов.
* `remove(offset, -1)` — удалить все байты от `offset` до конца.

Индексы должны указывать на допустимые позиции в диапазоне `[0, length()]`; в противном случае поведение не определено.

**Пример**

```cpp
Buffer buf;
buf.append("Hello, world");
buf.remove(5, 6);  // remove the comma
// buffer now represents "Hello world"
```

*Этот пример удаляет один байт из буфера, указав диапазон start/end.*

(Комментарий в коде переведен: // удалить запятую; // буфер теперь представляет "Hello world")

---

#### `Buffer &reverse()`

**Сигнатура**

```cpp
Buffer &reverse();
```

**Кратко**
Инвертирует порядок байтов на месте. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`reverse()` меняет порядок байтов на противоположный:

* Байт на индексе `0` меняется местами с байтом на индексе `length() - 1` и т.д.

Это чисто побайтовая операция. Если буфер содержит многобайтовые структуры (например, UTF-8 текст или многобайтовые целые), их внутренний порядок не сохраняется и может стать недействительным.

**Пример**

```cpp
Buffer buf;
buf.append("ABC");
buf.reverse();
// buffer now contains "CBA"
```

*Этот пример инвертирует порядок байтов в буфере.*

(Комментарий в коде переведен: // буфер теперь содержит "CBA")

---

#### `Buffer &trim()`

**Сигнатура**

```cpp
Buffer &trim();
```

**Кратко**
Уменьшает вместимость до соответствия длине. Возвращает этот буфер для цепочек вызовов.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`trim()` уменьшает внутреннюю ёмкость буфера до текущей `length()`. Это может:

* Освободить неиспользуемую память, когда вы знаете, что дальнейший рост не планируется.
* Сделать буфер компактнее перед сериализацией или длительным хранением.

Содержимое и `length()` при этом не меняются.

**Пример**

```cpp
Buffer buf(1024);  // initially reserved
buf.append("small");
buf.trim();        // capacity shrinks to a small size
```

*Этот пример резервирует дополнительное место, затем уменьшает его после финализации содержимого.*

(Комментарий в коде переведен: // изначально зарезервировано; // ёмкость сжимается до малого размера)

---

#### `Buffer slice(int start, int end = -1) const`

**Сигнатура**

```cpp
Buffer slice(int start, int end = -1) const;
```

**Кратко**
Возвращает новый буфер с байтами от start до end.

**Параметры**

* `start` – Байтовый индекс первого включаемого байта.
* `end` – Байтовый индекс **после** последнего включаемого байта (исключительно). Если `end` == `-1`, срез продолжается до конца буфера.

**Возвращаемое значение**

* Новый `Buffer`, содержащий байты из указанного диапазона.

**Подробно**

`slice()` — неизменяющий аналог `remove()`. Он создаёт новый буфер из выбранной части без изменения оригинала.

Используйте его для извлечения сегментов, таких как заголовки, полезные нагрузки или отдельные записи из большего буфера.

**Пример**

```cpp
Buffer buf;
buf.append("HEADERPAYLOAD");

Buffer header = buf.slice(0, 6);  // "HEADER"
Buffer payload = buf.slice(6);    // "PAYLOAD"
```

*Этот пример разделяет буфер на заголовок и полезную нагрузку с помощью `slice()`.*

(Комментарий в коде переведен: // "HEADER" и // "PAYLOAD")

---

#### `Buffer compress() const`

**Сигнатура**

```cpp
Buffer compress() const;
```

**Кратко**
Возвращает LZ4-сжатую версию этого буфера.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Новый `Buffer`, содержащий сжатые данные.

**Подробно**

`compress()` применяет LZ4-сжатие к текущим байтам:

* Результат может быть меньше оригинала для сжимаемых данных (текст, JSON).
* Для уже сжатых или случайных данных результат может быть сопоставим по размеру или немного больше.

Вы должны вызывать `decompress()` только для данных, ранее полученных с `compress()` (или совместимых LZ4-кодеров).

**Пример**

```cpp
Buffer original;
original.append("Lots of repetitive text... Lots of repetitive text...");

Buffer compressed = original.compress();
```

*Этот пример сжимает буфер, содержащий хорошо сжимаемый текст.*

---

#### `Buffer decompress() const`

**Сигнатура**

```cpp
Buffer decompress() const;
```

**Кратко**
Возвращает декомпрессированную версию этого буфера.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Новый `Buffer`, содержащий восстановленные данные.

**Подробно**

`decompress()` обращает LZ4-сжатие над данными, ранее полученными с `compress()`. Если содержимое буфера не является корректными сжатыми данными, поведение зависит от реализации (обычно ошибка или пустой результат).

Вы должны:

* Убедиться, что буфер действительно сжат перед вызовом `decompress()`.
* Использовать простые соглашения (расширения файлов или маркеры в заголовке), чтобы отслеживать статус сжатия в приложении.

**Пример**

```cpp
Buffer original;
original.append("Text to compress");

Buffer compressed = original.compress();
Buffer restored   = compressed.decompress();
// restored should contain the same bytes as original
```

*Этот пример показывает сжатие и последующую декомпрессию буфера для восстановления исходных байтов.*

(Комментарий в коде переведен: // restored должен содержать те же байты, что original)

---

#### `Buffer crypt(const String &key, const String &nonce) const`

**Сигнатура**

```cpp
Buffer crypt(const String &key, const String &nonce) const;
```

**Кратко**
Шифрует/дешифрует с ChaCha20 (симметрично). Ключ ≥32 байт, nonce ≥12 байт.

**Параметры**

* `key` – `String`, байты которого используются как ключ шифрования (не менее 32 байт).
* `nonce` – `String`, байты которого используются как nonce (не менее 12 байт).

**Возвращаемое значение**

* Новый `Buffer`, содержащий зашифрованные или расшифрованные байты.

**Подробно**

Этот оверлоад использует и ключ, и nonce, переданные как `String`. ChaCha20 — симметричный шифр: применение `crypt()` дважды с тем же ключом и nonce восстанавливает исходные байты.

Примечания:

* Длины ключа и nonce должны соответствовать или превышать указанные пороги.
* Если это не так, или происходят другие низкоуровневые ошибки, поведение определяется реализацией; рассматривайте это как случай ошибки.

**Пример**

```cpp
String key("0123456789abcdef0123456789abcdef");  // 32-byte key
String nonce("unique-nonce-123");               // ≥12 bytes

Buffer plain;
plain.append("secret data");

Buffer encrypted = plain.crypt(key, nonce);
Buffer decrypted = encrypted.crypt(key, nonce);
// decrypted should match plain
```

*Этот пример шифрует, а затем расшифровывает данные, используя ключ и nonce в виде `String`.*

(Комментарий в коде переведен: // 32-байтный ключ; // ≥12 байт; // decrypted должен совпадать с plain)

---

#### `Buffer crypt(const String &key, const Buffer &nonce) const`

**Сигнатура**

```cpp
Buffer crypt(const String &key, const Buffer &nonce) const;
```

**Кратко**
Шифрует/дешифрует с ChaCha20 (симметрично). Ключ ≥32 байт, nonce ≥12 байт.

**Параметры**

* `key` – Ключ шифрования в виде `String` (его байты используются как ключ).
* `nonce` – Nonce в виде `Buffer` (его байты используются как nonce).

**Возвращаемое значение**

* Новый `Buffer`, содержащий зашифрованные или расшифрованные данные.

**Подробно**

Этот вариант полезен, когда nonce естественно бинарный (например, сгенерирован случайным образом), но вы всё ещё хотите управлять ключом как `String`. Семантика идентична другому оверлоаду: для шифрования и расшифровки требуется одна и та же пара key+nonce.

**Пример**

```cpp
String key("0123456789abcdef0123456789abcdef");

Buffer nonce;
nonce.append("nonce-binary");  // binary nonce

Buffer data;
data.append("payload");

Buffer encrypted = data.crypt(key, nonce);
Buffer decrypted = encrypted.crypt(key, nonce);
```

*Этот пример использует строковый ключ с бинарным nonce, хранящимся в буфере.*

(Комментарий в коде переведен: // бинарный nonce)

---

#### `Buffer crypt(const Buffer &key, const String &nonce) const`

**Сигнатура**

```cpp
Buffer crypt(const Buffer &key, const String &nonce) const;
```

**Кратко**
Шифрует/дешифрует с ChaCha20 (симметрично). Ключ ≥32 байт, nonce ≥12 байт.

**Параметры**

* `key` – Ключ шифрования в виде `Buffer`.
* `nonce` – Nonce в виде `String`.

**Возвращаемое значение**

* Новый `Buffer` с зашифрованными или расшифрованными данными.

**Подробно**

Этот оверлоад зеркален предыдущему: ключ как `Buffer`, nonce как `String`. Полезно, если ключовый материал изначально бинарен (например, загружен из файла или сгенерирован случайно), а nonce — текстовый.

**Пример**

```cpp
Buffer key;
key.append("0123456789abcdef0123456789abcdef");

String nonce("nonce-text-123");

Buffer payload;
payload.append("binary payload");

Buffer encrypted = payload.crypt(key, nonce);
Buffer decrypted = encrypted.crypt(key, nonce);
```

*Этот пример использует бинарный ключ и текстовый nonce.*

---

#### `Buffer crypt(const Buffer &key, const Buffer &nonce) const`

**Сигнатура**

```cpp
Buffer crypt(const Buffer &key, const Buffer &nonce) const;
```

**Кратко**
Шифрует/дешифрует с ChaCha20 (симметрично). Ключ ≥32 байт, nonce ≥12 байт.

**Параметры**

* `key` – Ключ шифрования в виде `Buffer`.
* `nonce` – Nonce в виде `Buffer`.

**Возвращаемое значение**

* Новый `Buffer`, содержащий зашифрованные или расшифрованные данные.

**Подробно**

Это наиболее общий оверлоад: и ключ, и nonce — бинарные. Используйте его, когда оба управляются как чистые бинарные данные, например, сгенерированные через безопасный API случайных чисел или хранящиеся в бинарных файлах.

Как всегда:

* Для расшифровки требуется тот же key+nonce.
* Требования по длине должны соблюдаться.

**Пример**

```cpp
Buffer key;
key.append("0123456789abcdef0123456789abcdef");  // ≥32 bytes

Buffer nonce;
nonce.append("0123456789ab");                    // ≥12 bytes

Buffer secret;
secret.append("top secret");

Buffer encrypted = secret.crypt(key, nonce);
Buffer decrypted = encrypted.crypt(key, nonce);
```

*Этот пример шифрует и расшифровывает, используя бинарные ключ и nonce.*

(Комментарий в коде переведен: // ≥32 байта и // ≥12 байт)

---

#### `String toBase64() const`

**Сигнатура**

```cpp
String toBase64() const;
```

**Кратко**
Преобразует буфер в Base64-кодированную строку.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащий Base64-представление байтов буфера.

**Подробно**

Кодирование Base64 отображает произвольные двоичные данные в ограниченный набор ASCII-символов. Используйте это, когда:

* Нужно встроить двоичные данные в JSON или другие текстовые форматы.
* Хотите получить печатное представление буфера для логов или отладки.

Получившийся `String` можно обратно преобразовать в `Buffer` через `fromBase64()`.

**Пример**

```cpp
Buffer data;
data.append("binary data");

String encoded = data.toBase64();
// encoded can safely be placed in JSON or logs
```

*Этот пример кодирует содержимое буфера в Base64-текст.*

(Комментарий в коде переведен: // encoded можно безопасно поместить в JSON или логи)

---

#### `static Buffer fromBase64(const String &base64)`

**Сигнатура**

```cpp
static Buffer fromBase64(const String &base64);
```

**Кратко**
Создаёт буфер из Base64-кодированной строки.

**Параметры**

* `base64` – `String`, содержащий Base64-текст.

**Возвращаемое значение**

* Новый `Buffer`, содержащий декодированные байты.

**Подробно**

`fromBase64()` декодирует Base64-текст обратно в сырые байты:

* Ожидается, что `base64` является валидным Base64.
* При неверном вводе поведение определяется реализацией (скорее всего пустой буфер или частичный результат). Рассматривайте некорректный Base64 как ошибку в вашем приложении.

**Пример**

```cpp
Buffer original;
original.append("binary data");

String encoded = original.toBase64();
Buffer decoded = Buffer::fromBase64(encoded);
// decoded should contain the same bytes as original
```

*Этот пример выполняет круговое преобразование через Base64.*

(Комментарий в коде переведен: // decoded должен содержать те же байты, что original)

---

#### `String toString(const String &encoding = "utf-8") const`

**Сигнатура**

```cpp
String toString(const String &sourceEncoding = "utf-8") const;
```

**Кратко**
Преобразует байты буфера в `String`, исходя из указанной sourceEncoding. По умолчанию encoding = "utf-8".

**Параметры**

* `sourceEncoding` – Название кодировки символов, в которой в данный момент находятся байты буфера. По умолчанию `"utf-8"`. Байты интерпретируются как текст в этой кодировке и конвертируются во внутреннее UTF-8-представление `String`.

**Возвращаемое значение**

* `String`, построенный из байтов буфера, конвертированный в UTF-8 из указанной кодировки.

**Подробно**

`toString()` рассматривает содержимое буфера как **текст**, который закодирован в `sourceEncoding`, и конвертирует его в UTF-8 `String`. Концептуально:

* Буфер содержит сырые байты, прочитанные из файла, сокета или другого бинарного источника.
* Эти байты предполагается, что представляют текст в указанной кодировке (например, UTF-8, ANSI/Windows-1252 или другой кодовой странице).
* `toString()` декодирует эти байты и возвращает `String`, внутренне хранящий текст в UTF-8.

С параметром по умолчанию `"utf-8"` байты считаются уже в UTF-8 и оборачиваются (или проверяются и оборачиваются) в `String`. При передаче имени другой кодировки функция пытается **конвертировать из этой кодировки в UTF-8**.

Если байты невалидны для указанной кодировки, результат зависит от реализации механизма конвертации. Распространённые поведения:

* Замена некорректных последовательностей на символ-заполнитель.
* Получение частичного или пустого результата.
* Возврат пустой строки.

Вы должны вызывать `toString()` только когда уверены, что буфер содержит текстовые данные в указанной кодировке (например, лог-файл, сохранённый как ANSI, или ответ от устаревшего сервиса). Для сжатых, зашифрованных или произвольных бинарных данных продолжайте использовать `Buffer` и избегайте конвертаций в `String`.

**Пример**

```cpp
Buffer buf;
// ... read raw bytes from a file or socket encoded in ANSI (Windows-1252) into buf ...

// Interpret the stored bytes as Windows-1252 ("ANSI") and convert them to UTF-8 String
String text = buf.toString("ansi");

// For data already stored as UTF-8, you can rely on the default:
Buffer utf8Buf;
// ... fill utf8Buf with UTF-8 text bytes ...
String utf8Text = utf8Buf.toString();  // same as utf8Buf.toString("utf-8")
```

*Этот пример конвертирует байты, сохранённые в ANSI-кодировке, в UTF-8 `String`, и показывает путь по умолчанию для данных, уже в UTF-8.*

(Комментарий в коде переведен: // интерпретировать как Windows-1252 и конвертировать; // путь по умолчанию)

---

#### `bool compare(const Buffer &other) const`

**Сигнатура**

```cpp
bool compare(const Buffer &other) const;
```

**Кратко**
Возвращает true, если этот буфер равен другому.

**Параметры**

* `other` – Буфер для сравнения.

**Возвращаемое значение**

* `true`, если оба буфера полностью совпадают по байтам; иначе `false`.

**Подробно**

`compare()` проверяет точное побайтовое равенство, включая длину. Эквивалентно поведению `operator==`, но представлен как именованный метод.

**Пример**

```cpp
Buffer a;
a.append("DATA");

Buffer b;
b.append("DATA");

bool same = a.compare(b);  // true
```

*Этот пример сравнивает два буфера на полное равенство.*

(Комментарий в коде переведен: // true)

---

#### `int hash() const`

**Сигнатура**

```cpp
int hash() const;
```

**Кратко**
Возвращает хеш-код для этого буфера.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Целочисленный хеш-код, полученный из байтов буфера.

**Подробно**

Хеш пригоден для организации буферов в пользовательских хеш-структурах данных. Алгоритм не специфицирован и может меняться между версиями, поэтому не следует сохранять хеш-коды или полагаться на их стабильность между запусками.

**Пример**

```cpp
Buffer key;
key.append("binary-key");

int h = key.hash();
// use h in a custom hash table or map
```

*Этот пример вычисляет хеш-код из содержимого буфера.*

(Комментарий в коде переведен: // используйте h в пользовательской хеш-таблице или map)

---

#### `bool operator==(const Buffer &other) const`

**Сигнатура**

```cpp
bool operator==(const Buffer &other) const;
```

**Кратко**
Возвращает true, если этот буфер равен другому.

**Параметры**

* `other` – Буфер для сравнения.

**Возвращаемое значение**

* `true`, если буферы равны; иначе `false`.

**Подробно**

Оператор выполняет побайтовое сравнение двух буферов. Это более идиоматичный способ записи проверки равенства, чем `compare()`.

**Пример**

```cpp
Buffer a;
a.append("X");

Buffer b;
b.append("X");

bool equal = (a == b);  // true
```

*Этот пример использует оператор равенства для сравнения двух буферов.*

(Комментарий в коде переведен: // true)

---

#### `bool operator!=(const Buffer &other) const`

**Сигнатура**

```cpp
bool operator!=(const Buffer &other) const;
```

**Кратко**
Возвращает true, если этот буфер не равен другому.

**Параметры**

* `other` – Буфер для сравнения.

**Возвращаемое значение**

* `true`, если буферы различаются; `false`, если они равны.

**Подробно**

Это просто отрицание `operator==`. Позволяет выразить проверку неравенства естественным образом.

**Пример**

```cpp
Buffer a;
a.append("A");

Buffer b;
b.append("B");

if (a != b) {
  // buffers are different
}
```

*Этот пример выполняет ветвление, когда два буфера содержат разные байты.*

(Комментарий в коде переведен: // буферы различаются)

---

#### `Buffer operator+(const String &str) const`

**Сигнатура**

```cpp
Buffer operator+(const String &str) const;
```

**Кратко**
Возвращает новый буфер с добавленными байтами строки.

**Параметры**

* `str` – `String`, байты которого следует дописать к этому буферу.

**Возвращаемое значение**

* Новый `Buffer`, содержащий исходные байты, за которыми следуют байты строки.

**Подробно**

Этот оператор предоставляет удобный способ сформировать новый буфер путём добавления `String` к существующему буферу без изменения обоих операндов. Поведение эквивалентно:

```cpp
Buffer result(*this);
result.append(str);
return result;
```

**Пример**

```cpp
Buffer prefix;
prefix.append("HDR");

Buffer combined = prefix + String("BODY");
// combined contains bytes for "HDRBODY"
// prefix is unchanged
```

*Этот пример использует `operator+` для построения нового буфера из существующего буфера и строки.*

(Комментарий в коде переведен: // combined содержит "HDRBODY"; // prefix остаётся неизменным)

---

#### `Buffer operator+(const Buffer &other) const`

**Сигнатура**

```cpp
Buffer operator+(const Buffer &other) const;
```

**Кратко**
Возвращает новый буфер с добавленными байтами другого буфера.

**Параметры**

* `other` – Буфер, байты которого следует дописать к этому буферу.

**Возвращаемое значение**

* Новый `Buffer`, содержащий байты этого буфера, за которыми следуют байты `other`.

**Подробно**

Этот оператор — неизменяющий аналог `append(other)`. Он позволяет объединить два буфера в новый, не изменяя исходные.

**Пример**

```cpp
Buffer a;
a.append("AAA");

Buffer b;
b.append("BBB");

Buffer combined = a + b;
// combined: "AAABBB"
// a and b remain unchanged
```

*Этот пример объединяет два буфера в новый при помощи `operator+`.*

(Комментарий в коде переведен: // combined: "AAABBB"; // a и b остаются неизменными)