# Map

## Обзор

Класс `attoboy::Map` — это **словарь (ключ–значение)** с поддержкой **ключей и значений смешанных типов**. Он разработан как компактная замена стандартным контейнерам отображений, но без зависимости от библиотеки стандартных шаблонов C++. Вместо этого он тесно интегрируется с другими типами attoboy:

* Примитивные ключи и значения: `bool`, `int`, `float`
* Текстовые ключи и значения: `String` и `const char *`
* Вложенные контейнеры в качестве значений: `List`, `Map`, `Set`

В общих чертах, `Map` предоставляет:

* **Уникальные ключи** — каждый ключ встречается не более одного раза.
* **Гибкие типы ключей** — ключи могут быть числами, строками или булевыми значениями.
* **Гибкие типы значений** — значения могут иметь любой поддерживаемый тип, включая вложенные контейнеры.
* **Эффективный поиск** — получение значений по ключу через `get()` или `operator[]`.
* **Инструменты инспекции** — проверка наличия ключа, типа значения и обратный поиск ключа по значению.
* **Интеграция с JSON** — преобразование в JSON и из JSON-строк объектов.

### Отображения ключ–значение и смешанные типы

Концептуально, карта (или словарь) — это коллекция **пар**:

* Каждая пара состоит из **ключа** и **значения**.
* Ключи **уникальны**; вставка нового значения для существующего ключа **перезаписывает** предыдущее значение.
* По ключам можно быстро искать соответствующие им значения.

В `attoboy::Map`:

* Ключи могут быть `bool`, `int`, `float`, `const char *` или `String`.
* Значения могут быть любого поддерживаемого типа: примитивы, `String`, `List`, `Map`, `Set`.
* Map **не гарантирует порядок**; не следует полагаться на порядок вставки при итерации через `keys()` или `values()`.

### Типы и `ValueType`

Поскольку значения могут иметь смешанные типы, вам может понадобиться узнать, **какой тип** хранится по данному ключу, прежде чем читать его. Перечисление `ValueType` (разделяемое с `List` и `Set`) включает:

* `TYPE_BOOL`, `TYPE_INT`, `TYPE_FLOAT`
* `TYPE_STRING`, `TYPE_LIST`, `TYPE_MAP`, `TYPE_SET`
* `TYPE_NULL`, `TYPE_INVALID`, `TYPE_UNKNOWN` для специальных или ошибочных состояний

Вы можете использовать `typeAt()` чтобы проверить тип значения для ключа перед тем, как решить, **в какой C++ тип** вы хотите его прочитать (например, `int`, `float` или `String`) при вызове `get()` или `operator[]`.

### Прокси-значения (`MapValueView`)

`Map` использует внутренний **прокси-тип для значений** (т.е. `MapValueView`) чтобы упростить поиск:

* Функции вроде `get()` и `operator[]` возвращают объект-прокси.
* Этот прокси может **неявно преобразовываться** в тот C++ тип, в который вы его присваиваете.

На практике это значит, что вы можете писать:

```cpp
Map m("name", "Alice", "age", 30);

String name = m.get("name");  // proxy converts to String
int age     = m["age"];       // proxy converts to int
```

Вам почти никогда не нужно явно упоминать `MapValueView`; вы просто:

1. Вызываете `get()` или `operator[]`.
2. Присваиваете результат переменной нужного типа.

Если ключ отсутствует (или хранимый тип несовместим), прокси преобразуется в разумное **«нулевое» значение** для целевого типа (например, `0` для целых чисел, `false` для `bool`, пустая `String` для `String`).

### Изменяемость, RAII и цепочки вызовов

`Map` является **изменяемым**:

* Методы вроде `put()`, `remove()`, `clear()` и `merge()` модифицируют карту на месте.
* Большинство изменяющих методов возвращают `*this`, что позволяет использовать удобный стиль **цепочек**:

  ```cpp
  using namespace attoboy;

  Map config;
  config.put("host", "localhost")
        .put("port", 8080)
        .put("debug", true);
  ```

`Map` также следует принципам **RAII**:

* Конструирование `Map` при необходимости захватывает внутренние ресурсы.
* Деструктор автоматически освобождает эти ресурсы.
* Копирование и присваивание корректно управляют внутренним состоянием; вам не нужно освобождать память вручную.

### JSON и сценарии использования для конфигураций

`Map` особенно полезен для данных, похожих на конфигурации, и для работы с JSON:

* `toJSONString()` преобразует карту в JSON-строку объекта.
* `FromJSONString()` парсит JSON-строку объекта и строит `Map`.

Это облегчает:

* Представление настроек: `"host" -> "example.com"`, `"timeout" -> 5000`.
* Передачу структурированных аргументов в API, которые принимают или возвращают JSON.
* Хранение иерархических данных с использованием вложенных `Map` и `List` значений.

---

## Справочник

Каждый пункт ниже описывает один публичный конструктор, метод, статическую функцию или оператор `attoboy::Map`. Для каждого вы найдёте:

* **Сигнатуру** — точное объявление из заголовочного файла.
* **Краткое описание (Synopsis)** — однострочный комментарий Doxygen.
* Описания **параметров** и **возвращаемого значения**.
* **Подробно (In Depth)** — дополнительные детали, оговорки и короткий пример.

> **Примечание:** Все примеры предполагают `using namespace attoboy;`.

---

**Synopsis (class)**
Отображение ключ–значение со смешанными типами для ключей и значений.
Ключи должны быть уникальными. Порядок не гарантируется.

Это краткое описание относится ко всему классу. Разделы ниже подробно описывают каждый член.

---

#### `Map()`

**Signature**

```cpp
Map();
```

**Synopsis**
Создаёт пустую карту.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот конструктор создаёт карту с:

* Без ключей.
* Без связанных значений.

Непосредственно после создания:

* `length()` возвращает `0`.
* `isEmpty()` возвращает `true`.

Это стандартная отправная точка для постепенного построения коллекции ключ–значение с помощью `put()`.

**Пример**

```cpp
Map settings;
settings.put("debug", true);
settings.put("maxConnections", 100);
```

*Этот пример начинает с пустой карты и добавляет две пары ключ–значение.*

---

#### `Map(int capacity)`

**Signature**

```cpp
Map(int capacity);
```

**Synopsis**
Создаёт пустую карту с резервируемой вместимостью.

**Параметры**

* `capacity` – Подсказка о том, сколько пар ключ–значение вы планируете хранить.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот конструктор позволяет заранее зарезервировать внутреннее хранилище примерно для `capacity` записей. Это может уменьшить внутренние перевыделения, когда вы заранее знаете, что будете хранить много записей.

Карта при этом остаётся пустой: `length() == 0` до тех пор, пока вы не вызовете `put()`.

**Пример**

```cpp
int expectedEntries = 100;
Map cache(expectedEntries);

for (int i = 0; i < expectedEntries; ++i) {
  cache.put(i, String("value"));
}
```

*Этот пример предварительно выделяет место для кэша на 100 записей.*

---

#### `template <typename... Args> Map(const Args &...args)`

**Signature**

```cpp
template <typename... Args> Map(const Args &...args) : Map() {
  variadic_put_pairs(args...);
}
```

**Synopsis**
Создаёт карту с парами ключ–значение: Map("name", "Alice", "age", 30)

**Параметры**

* `args` – Последовательность значений, которые будут интерпретированы как пары ключ–значение:

  * `args` потребляются по порядку: `(key0, value0, key1, value1, ...)`.
  * Ключи должны быть типов, поддерживаемых в качестве ключей (`bool`, `int`, `float`, `const char *`, `String`).
  * Значения должны быть типов, поддерживаемых в качестве значений.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Этот конструктор — удобный инициализатор в стиле литерала:

* Он начинает с пустой карты.
* Рассматривает список аргументов как пары `(key, value)`.
* Для каждой пары вызывает `put(key, value)`.

Если количество аргументов нечётное, последний ключ сочетается с булевым значением по умолчанию `false` (на основании внутреннего поведения `variadic_put_pairs()`), но такое использование обычно не рекомендуется. Для ясности и безопасности всегда передавайте аргументы в полных парах ключ–значение.

Если один и тот же ключ появляется несколько раз, более поздние значения перезаписывают ранние (как при повторных вызовах `put()`).

**Пример**

```cpp
Map user(
  "name", "Alice",
  "age", 30,
  "active", true
);
// user["name"] == "Alice"
// user["age"] == 30
// user["active"] == true
```

*Этот пример создаёт небольшую карту конфигурации с синтаксисом, похожим на литерал.*

---

#### `Map(const Map &other)`

**Signature**

```cpp
Map(const Map &other);
```

**Synopsis**
Создаёт копию другой карты.

**Параметры**

* `other` – Существующая карта для копирования.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробно**

Конструктор копирования создаёт новую карту с теми же парами ключ–значение, что и `other`:

* `length()` одинаково.
* Наличие ключа (`hasKey(key)`) совпадает.
* Значения, получаемые через `get()` или `operator[]`, равны значениям в `other`.

Хотя внутренние реализации могут отличаться, наблюдаемое поведение одинаково.

**Пример**

```cpp
Map original("host", "localhost", "port", 8080);
Map copy(original);
// copy initially has the same key–value pairs as original
```

*Этот пример дублирует карту конфигурации, чтобы изменения в одной не влияли на другую.*

---

#### `~Map()`

**Signature**

```cpp
~Map();
```

**Synopsis**
Уничтожает карту и освобождает память.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробно**

Когда `Map` выходит из области видимости или иным образом уничтожается, его деструктор автоматически:

* Освобождает внутреннее хранилище.
* Очищает любые связанные ресурсы.

Поскольку attoboy следует RAII, вам не нужно явно освобождать карту.

**Пример**

```cpp
{
  Map temp("key", "value");
  // use temp here
}
// temp is destroyed here; its resources are freed
```

*Этот пример иллюстрирует автоматическую очистку при выходе карты из области видимости.*

---

#### `Map &operator=(const Map &other)`

**Signature**

```cpp
Map &operator=(const Map &other);
```

**Synopsis**
Присваивает этой карте содержимое другой карты.

**Параметры**

* `other` – Карта, содержимое которой должно заменить текущее.

**Возвращаемое значение**

* Ссылка на `*this`, позволяющая цепочки присваиваний.

**Подробно**

Оператор присваивания копированием делает так, чтобы `*this` содержала ровно те же пары ключ–значение, что и `other`. Любое предыдущее содержимое отбрасывается.

После присваивания:

* `length()` совпадает с `other.length()`.
* Для любого ключа `k` `get(k, default)` возвращает то же значение в обеих картах.

Самоприсваивание (`map = map`) безопасно.

**Пример**

```cpp
Map a("x", 1);
Map b("y", 2);

a = b;
// a now contains only the pairs that were in b
```

*Этот пример заменяет содержимое одной карты содержимым другой.*

---

#### `int length() const`

**Signature**

```cpp
int length() const;
```

**Synopsis**
Возвращает количество пар ключ–значение.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Количество пар ключ–значение, в настоящее время хранимых в карте.

**Подробно**

`length()` возвращает, сколько **различных ключей** находится в карте. Поскольку каждый ключ уникален:

* `length()` равен числу записей.
* Вставка значения для уже существующего ключа **не** увеличивает `length()`; она заменяет предыдущее значение.

**Пример**

```cpp
Map m;
m.put("a", 1)
 .put("b", 2)
 .put("a", 3);  // overwrites key "a"

int n = m.length();  // 2
```

*Этот пример показывает, что перезапись ключа не увеличивает длину карты.*

---

#### `bool isEmpty() const`

**Signature**

```cpp
bool isEmpty() const;
```

**Synopsis**
Возвращает true, если карта пуста.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если `length() == 0`; иначе `false`.

**Подробно**

`isEmpty()` — это удобный способ более явно выразить намерение, чем проверка `length() == 0`.

**Пример**

```cpp
Map m;
if (m.isEmpty()) {
  m.put("initialized", true);
}
```

*Этот пример использует `isEmpty()` чтобы решить, когда инициализировать карту.*

---

#### `MapValueView get(…) const` (proxy lookup without explicit default)

**Signature**

```cpp
MapValueView get(bool key) const;
MapValueView get(int key) const;
MapValueView get(float key) const;
MapValueView get(const char *key) const;
MapValueView get(const String &key) const;
```

**Synopsis**
Возвращает типизированный вид значения для ключа или прокси-значение null-типа, если не найдено.

**Параметры**

* `key` – Ключ для поиска. Существуют перегрузки для:

  * `bool`
  * `int`
  * `float`
  * `const char *`
  * `String`

**Возвращаемое значение**

* Прокси `MapValueView`, представляющий значение, связанное с `key`, или специальный **прокси null-типа**, если ключ не найден.

**Подробно**

Эти перегрузки предоставляют наиболее распространённый способ **чтения значений без шаблонов**:

```cpp
Map config("timeoutMs", 5000, "debug", true);

int timeout = config.get("timeoutMs");  // proxy → int
bool debug  = config.get("debug");      // proxy → bool
```

Вы обычно **не** работаете с `MapValueView` напрямую. Вместо этого вы присваиваете результат `get()` переменной ожидаемого типа:

* Если ключ **существует** и хранимый тип совместим с вашим целевым типом, прокси преобразуется в этот тип.
* Если ключ **не существует**, прокси преобразуется в **«нулевое» значение** целевого типа:

  * `0` для числовых типов,
  * `false` для `bool`,
  * пустая `String` для `String` и т.д.

Если вам нужно различать «ключ отсутствует» и «существует, но имеет значение, похожее на значение по умолчанию» (например, `0` является допустимым значением), используйте `hasKey()` или `typeAt()` вместе с этим.

**Пример**

```cpp
Map stats("score", 42, "lives", 3);

int score  = stats.get("score");    // 42
int lives  = stats.get("lives");    // 3
int coins  = stats.get("coins");    // 0 (key missing → null int)
bool debug = stats.get("debug");    // false (key missing → null bool)

if (!stats.hasKey("coins")) {
  // Key truly does not exist, even though the proxy converted to 0.
}
```

*Этот пример показывает поиск через прокси без шаблонов и то, как отсутствующие ключи преобразуются в значения по умолчанию.*

---

#### `MapValueView get(…, const DefaultValue &defaultValue) const` (proxy lookup with explicit default)

**Signature**

```cpp
MapValueView get(bool key, const DefaultValue &defaultValue) const;
MapValueView get(int key, const DefaultValue &defaultValue) const;
MapValueView get(float key, const DefaultValue &defaultValue) const;
MapValueView get(const char *key, const DefaultValue &defaultValue) const;
MapValueView get(const String &key, const DefaultValue &defaultValue) const;
MapValueView get(const char *key, const char *defaultValue) const;
```

**Synopsis**
Возвращает типизированный вид значения для ключа или `defaultValue`, если ключ не найден.

**Параметры**

* `key` – Ключ для поиска. Существуют перегрузки для:

  * `bool`
  * `int`
  * `float`
  * `const char *`
  * `String`
* `defaultValue` – Значение по умолчанию, используемое, если `key` отсутствует. Тип параметра выводится из переданного аргумента.

**Возвращаемое значение**

* Прокси `MapValueView`:

  * Если ключ существует, прокси представляет хранимое значение.
  * Если ключ не существует, прокси представляет `defaultValue`.

**Подробно**

Эти перегрузки — это версии `get()` с учётом значения по умолчанию:

* Они позволяют указать **локальное значение по умолчанию** для конкретного вызова без использования шаблонов.
* Возвращаемый прокси всё ещё преобразуется в тип переменной, в которую вы его присваиваете, но при отсутствии ключа он ведёт себя так, как если бы в карте было сохранено `defaultValue`.

Например, если ключ `"retries"` отсутствует:

* `get("retries", 3)` ведёт себя так, как если бы в карте под `"retries"` хранилось значение `3`.

Часто это наиболее читаемый способ задать значения по умолчанию для конфигураций.

**Пример**

```cpp
Map config("timeoutMs", 5000);

int timeout = config.get("timeoutMs", 1000);   // 5000 (stored)
int retries = config.get("retries", 3);        // 3 (fallback)
String host = config.get("host", "localhost"); // "localhost" (fallback)
```

*Этот пример показывает, как задавать явные значения по умолчанию без синтаксиса шаблонов.*

---

#### `MapValueView operator[](…) const` (proxy index access)

**Signature**

```cpp
MapValueView operator[](bool key) const;
MapValueView operator[](int key) const;
MapValueView operator[](float key) const;
MapValueView operator[](const char *key) const;
MapValueView operator[](const String &key) const;
```

**Synopsis**
Возвращает значение для ключа или прокси null-типа, если не найдено.

**Параметры**

* `key` – Ключ для поиска. Существуют перегрузки для:

  * `bool`
  * `int`
  * `float`
  * `const char *`
  * `String`

**Возвращаемое значение**

* Прокси `MapValueView`, представляющий значение для `key`, или прокси null-типа, если ключ отсутствует.

**Подробно**

`operator[]` обеспечивает **краткий, похожий на массив синтаксис** для поиска через прокси:

```cpp
Map user("name", "Alice", "age", 30);

String name = user["name"]; // proxy → String
int age      = user["age"]; // proxy → int
int score    = user["score"]; // proxy → 0 (null int)
```

Поведение совпадает с `get(key)`:

* Если ключ существует, прокси преобразуется в хранимое значение.
* Если ключ не существует, прокси преобразуется в **нулевое значение** для типа, в который вы присваиваете.

Поскольку отсутствующие ключи бесшумно преобразуются в нулевые значения, используйте `hasKey()`, если нужно различать «отсутствует» и «присутствует, но похоже на значение по умолчанию».

**Пример**

```cpp
Map settings("volume", 75, "muted", false);

int  volume = settings["volume"];    // 75
bool muted  = settings["muted"];     // false
bool night  = settings["nightMode"]; // false (missing → null bool)

if (!settings.hasKey("nightMode")) {
  // Feature not configured at all
}
```

*Этот пример показывает поиск через скобки с неявным преобразованием через прокси.*

---

#### `template <typename K, typename V> V get(K key, V defaultValue = V()) const` (advanced typed lookup)

**Signature**

```cpp
template <typename K, typename V> V get(K key, V defaultValue = V()) const;
```

**Synopsis**
Возвращает значение для ключа или `defaultValue`, если ключ не найден.

**Параметры**

* `key` – Ключ для поиска. Обычно `bool`, `int`, `float`, `const char *` или `String`.
* `defaultValue` – Значение, возвращаемое, если `key` отсутствует. По умолчанию — значение по умолчанию, полученное конструктором `V()`.

**Возвращаемое значение**

* Значение, связанное с `key`, преобразованное в тип `V`, если ключ существует; иначе `defaultValue`.

**Подробно**

Эта шаблонная версия `get()` предоставляет **прямой доступ с указанием типа** без использования явного прокси-переменного. Функционально она похожа на:

```cpp
V value = map.get(key, defaultValue);
```

используя перегрузки прокси, но:

* Тип `V` фиксируется как параметр шаблона, а не определяется промежуточной переменной.
* Внутренняя прокси-реализация карты может быть обойдена или специализирована более прямо.

Для большинства кодов нептуже удобнее использовать нефункциональные перегрузки прокси:

```cpp
int timeout = config.get("timeoutMs", 1000);      // preferred
int timeout2 = config.get<String,int>("timeoutMs", 1000); // advanced
```

Используйте форму шаблона, когда вам нужен явный контроль над параметрами шаблона или при взаимодействии с шаблонно-ориентированным кодом.

**Пример**

```cpp
Map config("timeoutMs", 5000);

int timeout = config.get<String,int>("timeoutMs", 1000); // 5000
int retries = config.get<String,int>("retries", 3);      // 3 (default)
```

*Этот пример повторяет поведение прокси-версии `get()` с явными параметрами шаблона.*

---

#### `template <typename K, typename V> V operator[](K key) const` (advanced typed index access)

**Signature**

```cpp
template <typename K, typename V> V operator[](K key) const;
```

**Synopsis**
Возвращает значение для ключа или null-типа, если не найдено.

**Параметры**

* `key` – Ключ для поиска.

**Возвращаемое значение**

* Значение, связанное с `key`, преобразованное в тип `V`, если найдено; иначе значение, созданное конструктором `V()` («null»-тип `V`).

**Подробно**

Этот шаблонный оператор предоставляет **явно типизированный вариант** `operator[]`, где тип результата определяется параметром шаблона `V`:

```cpp
int  score = map.operator[]<String,int>("score");
bool ok    = map.operator[]<int,bool>(42);
```

В большинстве случаев перегрузки на основе прокси более естественны:

```cpp
int  score = map["score"]; // proxy-based
bool ok    = map[42];      // proxy-based
```

Вы всё ещё можете использовать шаблонную форму, когда:

* Хотите явно указать `V`, или
* Работаете в шаблонно-ориентированном коде, где полезны явные параметры шаблона.

Отсутствующие ключи ведут себя так же, как и в прокси-версии `operator[]`:

* Если ключ не найден, оператор возвращает значение по умолчанию, создаваемое `V()`.

**Пример**

```cpp
Map status("ready", true);

bool ready = status.operator[]<String,bool>("ready");  // true
bool error = status.operator[]<String,bool>("error");  // false (default bool)
```

*Этот пример использует шаблонную форму для явного контроля типа результата, повторяя поведение прокси.*

---

#### `template <typename K> bool hasKey(K key) const`

**Signature**

```cpp
template <typename K> bool hasKey(K key) const;
```

**Synopsis**
Возвращает true, если карта содержит ключ.

**Параметры**

* `key` – Ключ для проверки существования.

**Возвращаемое значение**

* `true`, если ключ присутствует; иначе `false`.

**Подробно**

`hasKey()` — основной метод для **проверки существования**:

* Используйте его, когда нужно знать, был ли установлен ключ.
* Он устраняет неопределённость, возникающую при возврате значений по умолчанию через `operator[]`.

Поскольку ключи уникальны, `hasKey()` сообщает, присутствует ли ровно одно значение, связанное с этим ключом.

**Пример**

```cpp
Map config("debug", true);

if (config.hasKey("debug")) {
  bool debugEnabled = config.get<String,bool>("debug", false);
}
```

*Этот пример проверяет существование ключа перед получением его значения.*

---

#### `template <typename K> ValueType typeAt(K key) const`

**Signature**

```cpp
template <typename K> ValueType typeAt(K key) const;
```

**Synopsis**
Возвращает тип значения для ключа или `TYPE_INVALID`, если ключ не найден.

**Параметры**

* `key` – Ключ, тип значения для которого вы хотите узнать.

**Возвращаемое значение**

* Элемент перечисления `ValueType`, описывающий сохранённый тип, или `TYPE_INVALID`, если ключ отсутствует.

**Подробно**

`typeAt()` позволяет **проверить** тип значения, связанного с ключом, перед его получением. Это особенно важно в карте со смешанными типами:

* Используйте `typeAt()` чтобы защитить вызовы `get()` или `operator[]` для конкретного `V`.
* Если возвращается `TYPE_INVALID`, ключ отсутствует.

**Пример**

```cpp
Map data("name", "Alice", "age", 30);

ValueType nameType = data.typeAt("name"); // likely TYPE_STRING
ValueType ageType  = data.typeAt("age");  // likely TYPE_INT
ValueType missing  = data.typeAt("score"); // TYPE_INVALID
```

*Этот пример проверяет типы нескольких ключей, чтобы решить, как читать их значения.*

---

#### `template <typename K, typename V> K findValue(V value) const`

**Signature**

```cpp
template <typename K, typename V> K findValue(V value) const;
```

**Synopsis**
Возвращает первый ключ с заданным значением или ключ null-типа, если не найдено.

**Параметры**

* `value` – Значение для поиска.
* Параметр шаблона `K` – Ожидаемый тип возвращаемого ключа.

**Возвращаемое значение**

* Первый ключ типа `K`, связанный со значением, равным `value`, или ключ, созданный по умолчанию `K()` (ключ null-типа), если совпадений нет.

**Подробно**

`findValue()` выполняет обратный поиск:

* Сканирует карту в поисках записи, значение которой равно `value`.
* Если находит, возвращает соответствующий ключ, приведённый к типу `K`.
* Если не находит, возвращает `K()` (например, `0` для числовых ключей, `false` для `bool`, пустая `String` для `String`).

Важные замечания:

* Поскольку в карте может быть несколько ключей с одинаковым значением, `findValue()` возвращает **первый** подходящий ключ в соответствии с внутренним порядком итерации (который не гарантирован).
* Вы должны выбирать `K`, совпадающий с фактическим типом ключа, использованного для этих записей; иначе результат может быть бессмыслен.

**Пример**

```cpp
Map status(
  "ready", true,
  "connected", true,
  "error", false
);

String key = status.findValue<String,bool>(false);
// key may be "error" (if that is the first entry with value false)
```

*Этот пример находит первый ключ, значение которого — `false`.*

---

#### `List keys() const`

**Signature**

```cpp
List keys() const;
```

**Synopsis**
Возвращает список всех ключей.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `List`, содержащий все ключи в карте. Порядок не гарантируется.

**Подробно**

`keys()` собирает все ключи в `List`:

* Каждый элемент возвращаемого списка — это ключ, чаще всего типа `String`, `int` или `bool`.
* Порядок ключей в списке не определён и может варьироваться между запусками или версиями.

Это полезно для итерации, отладки или экспорта карты.

**Пример**

```cpp
Map user("name", "Alice", "age", 30);
List keyList = user.keys();
// keyList holds all the keys (e.g., ["name", "age"] in some order)
```

*Этот пример получает список ключей для итерации или инспекции.*

---

#### `List values() const`

**Signature**

```cpp
List values() const;
```

**Synopsis**
Возвращает список всех значений.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `List`, содержащий все значения в карте. Порядок соответствует внутреннему порядку ключей и не гарантируется.

**Подробно**

`values()` собирает все значения в `List`:

* Каждый элемент возвращаемого списка — это значение, связанное с некоторым ключом.
* Порядок значений соответствует внутреннему порядку ключей, который не определён.

Возвращаемый список может содержать смешанные типы (`int`, `String`, `bool`, контейнеры и т.д.), и вы можете использовать `typeAt()` на `List`, чтобы их инспектировать.

**Пример**

```cpp
Map user("name", "Alice", "age", 30);
List vals = user.values();
// vals holds ["Alice", 30] (order unspecified but consistent with keys())
```

*Этот пример получает список значений для дальнейшей обработки.*

---

#### `template <typename K, typename V> Map &put(K key, V value)`

**Signature**

```cpp
template <typename K, typename V> Map &put(K key, V value);
```

**Synopsis**
Устанавливает key в value. Возвращает эту карту для цепочек вызовов.

**Параметры**

* `key` – Ключ для вставки или обновления.
* `value` – Значение, которое будет связано с ключом.

**Возвращаемое значение**

* Ссылка на `*this`, чтобы позволять цепочку вызовов.

**Подробно**

`put()` вставляет или обновляет пару ключ–значение:

* Если `key` **не присутствует**, `put()` добавляет новую запись и `length()` увеличивается на единицу.
* Если `key` **уже существует**, `put()` перезаписывает существующее значение для этого ключа; `length()` не меняется.

Учет типов:

* `key` должен быть поддерживаемым типом ключа.
* `value` должен быть поддерживаемым типом значения.

Это основной метод для создания и обновления карт.

**Пример**

```cpp
Map config;
config.put("host", "localhost")
      .put("port", 8080)
      .put("port", 9090); // overwrite previous port
```

*Этот пример устанавливает и затем обновляет значения конфигурации для конкретных ключей.*

---

#### `template <typename K> Map &remove(K key)`

**Signature**

```cpp
template <typename K> Map &remove(K key);
```

**Synopsis**
Удаляет пару ключ–значение. Возвращает эту карту для цепочек вызовов.

**Параметры**

* `key` – Ключ, запись по которому должна быть удалена.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`remove()` удаляет запись по `key`, если она существует:

* После успешного удаления `hasKey(key)` возвращает `false`.
* `length()` уменьшается на единицу.
* Если `key` не был присутствует, карта остаётся без изменений.

Это основной способ удаления записей из карты.

**Пример**

```cpp
Map config("host", "localhost", "port", 8080);
config.remove("port");
// "port" no longer exists in config
```

*Этот пример удаляет пару ключ–значение из карты конфигурации.*

---

#### `Map &clear()`

**Signature**

```cpp
Map &clear();
```

**Synopsis**
Удаляет все пары ключ–значение. Возвращает эту карту для цепочек вызовов.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`clear()` очищает карту:

* `length()` становится `0`.
* `isEmpty()` возвращает `true`.
* Все существующие пары ключ–значение удаляются.

Внутренняя ёмкость может быть сохранена для производительности, но логически карта ведёт себя как вновь созданная.

**Пример**

```cpp
Map cache("a", 1, "b", 2);
cache.clear();
// cache is now empty
```

*Этот пример очищает все записи из кэша.*

---

#### `Map &merge(const Map &other)`

**Signature**

```cpp
Map &merge(const Map &other);
```

**Synopsis**
Сливает другую карту в эту. Возвращает эту карту для цепочек вызовов.

**Параметры**

* `other` – Исходная карта, записи которой будут слиты в `*this`.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробно**

`merge()` объединяет две карты:

* Для каждого ключа в `other`:

  * Если ключ **не присутствует** в `*this`, он добавляется.
  * Если ключ **присутствует**, значение из `other` **перезаписывает** существующее значение в `*this`.

`other` не модифицируется.

Это полезно для наложения конфигураций или применения переопределений.

**Пример**

```cpp
Map defaults("host", "localhost", "port", 8080);
Map overrides("port", 9090, "debug", true);

defaults.merge(overrides);
// defaults now contains:
//   "host"  -> "localhost"
//   "port"  -> 9090      (overridden)
//   "debug" -> true      (added)
```

*Этот пример сливает пользовательские переопределения в набор значений по умолчанию.*

---

#### `Map duplicate() const`

**Signature**

```cpp
Map duplicate() const;
```

**Synopsis**
Возвращает копию этой карты.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Новая `Map`, содержащая те же пары ключ–значение, что и оригинал.

**Подробно**

`duplicate()` предоставляет явный метод-способ копирования карты. Это особенно удобно, когда вы хотите:

* Сохранить оригинальную карту.
* Применять модификации к рабочей копии.

Поведение совпадает с использованием конструктора копирования, но может быть более читабельным при использовании в цепочках:

```cpp
Map modified = original.duplicate().merge(overrides);
```

**Пример**

```cpp
Map base("mode", "production");
Map work = base.duplicate();

work.put("mode", "development");
// base still has "mode" = "production"
// work has "mode" = "development"
```

*Этот пример показывает, как изменить дубликат, не затрагивая оригинал.*

---

#### `String toJSONString() const`

**Signature**

```cpp
String toJSONString() const;
```

**Synopsis**
Преобразует эту карту в JSON-строку объекта.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая JSON-представление объекта карты.

**Подробно**

`toJSONString()` сериализует карту как JSON-объект, например:

```json
{"name":"Alice","age":30,"active":true}
```

Обработка ключей и значений:

* Ключи преобразуются в ключи JSON-объекта (строки). Нестроковые ключи преобразуются в строковое представление (например, числовые ключи становятся десятичной строкой).
* Значения преобразуются в JSON в зависимости от их типа:

  * Числа → JSON-числа.
  * Булевы значения → `true`/`false`.
  * `String` → JSON-строки с корректным экранированием.
  * `List`, `Map`, `Set` → вложенные JSON-массивы или объекты.

Порядок ключей в результирующем JSON не гарантируется.

**Пример**

```cpp
Map user("name", "Alice", "age", 30, "active", true);
String json = user.toJSONString();
// e.g., {"name":"Alice","age":30,"active":true}
```

*Этот пример преобразует карту пользователя в JSON-строку, пригодную для логирования или передачи по сети.*

---

#### `static Map FromJSONString(const String &json)`

**Signature**

```cpp
static Map FromJSONString(const String &json);
```

**Synopsis**
Создаёт карту из JSON-строки объекта.

**Параметры**

* `json` – Текст JSON-объекта для парсинга.

**Возвращаемое значение**

* `Map`, представляющая распарсенный JSON-объект.

**Подробно**

`FromJSONString()` парсит JSON-строку объекта и конструирует `Map`, где:

* Каждый JSON-ключ становится ключом в карте (обычно `String`).
* Каждое JSON-значение становится соответствующим значением attoboy:

  * JSON-числа → числовые значения.
  * Булевы → `bool`.
  * Строки → `String`.
  * Массивы → `List`.
  * Объекты → вложенные `Map`.

Если входная строка не является допустимым JSON-объектом, результирующая карта может быть пустой или отражать состояние ошибки; об этом нужно заботиться в вызывающем коде.

**Пример**

```cpp
String json("{\"name\":\"Alice\",\"age\":30,\"active\":true}");
Map user = Map::FromJSONString(json);

// user.get<String,String>("name", String())  -> "Alice"
// user.get<String,int>("age", 0)             -> 30
// user.get<String,bool>("active", false)     -> true
```

*Этот пример парсит JSON-объект в карту для дальнейшей обработки.*

---

#### `bool compare(const Map &other) const`

**Signature**

```cpp
bool compare(const Map &other) const;
```

**Synopsis**
Возвращает true, если эта карта равна другой карте.

**Параметры**

* `other` – Карта для сравнения.

**Возвращаемое значение**

* `true`, если обе карты содержат точно одинаковые ключи и соответствующие им значения; иначе `false`.

**Подробно**

`compare()` проверяет равенство карт по семантике словаря:

* Обе карты должны иметь одинаковое количество записей.
* Для каждого ключа в одной карте другая карта должна:

  * Содержать этот ключ.
  * Хранить равное значение под этим ключом.

Порядок не имеет значения; важны только ключи и соответствующие им значения.

Этот метод эквивалентен `operator==`.

**Пример**

```cpp
Map a("x", 1, "y", 2);
Map b("y", 2, "x", 1);
Map c("x", 1);

bool ab = a.compare(b);  // true (same key–value pairs)
bool ac = a.compare(c);  // false (c is missing "y")
```

*Этот пример показывает проверки на равенство, игнорирующие порядок, но требующие идентичного содержимого.*

---

#### `bool operator==(const Map &other) const`

**Signature**

```cpp
bool operator==(const Map &other) const;
```

**Synopsis**
Возвращает true, если эта карта равна другой карте.

**Параметры**

* `other` – Карта для сравнения.

**Возвращаемое значение**

* `true`, если карты равны; иначе `false`.

**Подробно**

Этот оператор предоставляет идиоматичный синтаксис равенства:

```cpp
if (a == b) { ... }
```

Он использует те же критерии, что и `compare()`:

* Одинаковый набор ключей.
* Одинаковое значение для каждого ключа.

Порядок не важен.

**Пример**

```cpp
Map a("a", 1, "b", 2);
Map b("b", 2, "a", 1);
Map c("a", 1, "b", 3);

bool same = (a == b); // true
bool diff = (a == c); // false (different value for "b")
```

*Этот пример сравнивает карты с помощью оператора `==`.*

---

#### `bool operator!=(const Map &other) const`

**Signature**

```cpp
bool operator!=(const Map &other) const;
```

**Synopsis**
Возвращает true, если эта карта не равна другой карте.

**Параметры**

* `other` – Карта для сравнения.

**Возвращаемое значение**

* `true`, если карты не равны; `false`, если равны.

**Подробно**

Этот оператор — логическое отрицание `operator==`:

* Он возвращает `true` в тех случаях, когда `operator==` вернул бы `false`.

Удобен, когда нужно ветвить логику по неравенству.

**Пример**

```cpp
Map a("key", 1);
Map b("key", 2);

if (a != b) {
  // the value for "key" differs between the two maps
}
```

*Этот пример использует неравенство для обнаружения различий в содержимом карт.*