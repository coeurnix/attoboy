# DateTime

## Обзор

Класс `attoboy::DateTime` представляет момент времени с точностью до **миллисекунд**, всегда в **UTC** (Coordinated Universal Time). Это основной способ библиотеки фиксировать «сейчас», сохранять метки времени, измерять прошедшее время и преобразовывать между машинно-удобными числовыми timestamp и человекочитаемыми строками.

Можно рассматривать `DateTime` как компактную оболочку на основе RAII вокруг:

* Внутреннего 64-битного timestamp, измеряемого в **миллисекундах с начала эпохи Unix**, и
* Набора операций для сложения, сравнения и форматирования в строку ISO‑8601.

В отличие от `String`, `DateTime` **изменяемый**: функция `add()` модифицирует объект на месте и возвращает ссылку на него для цепочек вызовов. Копирование и присваивание безопасны и дешёвые; они просто копируют внутренний timestamp.

### Основные понятия: UTC, эпоха Unix и миллисекунды

Если вы новичок в работе со временем в программировании, полезно знать несколько ключевых идей:

* **UTC (Coordinated Universal Time)**  
  UTC — глобальный стандарт, нейтральный к часовым поясам. `DateTime` всегда представляет время в UTC; он не хранит информацию о часовых поясах или правилах перехода на летнее время. При преобразовании `DateTime` в строку вы получаете ISO‑8601 значение в UTC с окончанием `"Z"` (например, `"2024-01-01T12:00:00.000Z"`).

* **Эпоха Unix**  
  Эпоха Unix определяется как **1 января 1970 года в 00:00:00 UTC**. Внутри `DateTime` используется 64‑битное целое число, считающее **миллисекунды** с этого момента:

  * `0` → ровно `1970-01-01T00:00:00.000Z`
  * `1` → одна миллисекунда после этого
  * Отрицательные значения представляют время до эпохи.

* **Точность до миллисекунд**  
  Вся арифметика и разности выполняются в миллисекундах:

  * Одна секунда = 1 000 миллисекунд.
  * Одна минута = 60 000 миллисекунд.
  * Один час = 3 600 000 миллисекунд.

Такая конструкция упрощает:

* Измерение прошедшего времени между двумя событиями (`diff()`),
* Сдвиг `DateTime` вперёд или назад (`add()`),
* Логирование меток времени или их сохранение в числовом виде (`timestamp()`),
* Получение и разбор строк ISO‑8601 (`toString()`, конструктор из `String`).

> **Примечание:** `DateTime` использует системное реальное (wall‑clock) время. Это не монотонный «таймер». Если системное время будет скорректировано пользователем или через NTP, новые объекты `DateTime()` отразят это изменение.

---

## Справочник

Каждый раздел ниже описывает один публичный конструктор, метод или оператор `attoboy::DateTime`. Для каждого вы найдёте:

* **Signature** — точное объявление из заголовка.
* **Synopsis** — исходный однострочный комментарий Doxygen.
* Описания **Параметров** и **Возвращаемого значения**.
* **Подробно** — детали поведения, оговорки и короткий пример.

Во всех примерах предполагается:

```cpp
using namespace attoboy;
```

---

#### `DateTime()`

**Signature**

```cpp
DateTime();
```

**Краткое описание**  
Создаёт DateTime, представляющий текущее время.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(конструктор; не применяется)*

**Подробно**

Конструктор по умолчанию захватывает **текущее время в UTC** из системных часов с точностью до миллисекунд. Это самый простой способ получить «метку времени сейчас».

Захваченное время фиксируется в объекте; последующие вызовы `timestamp()` или `toString()` у того же экземпляра вернут то же значение, если только вы не вызовете `add()` для изменения.

**Пример**

```cpp
DateTime now;
String iso = now.toString();  // e.g., "2025-11-27T21:00:00.123Z"
```

*В этом примере создаётся `DateTime` для текущего момента и преобразуется в строку в формате ISO‑8601.*

---

#### `DateTime(long long millisSinceEpoch)`

**Signature**

```cpp
DateTime(long long millisSinceEpoch);
```

**Краткое описание**  
Создаёт DateTime из количества миллисекунд с начала эпохи Unix (1 янв. 1970).

**Параметры**

* `millisSinceEpoch` – количество миллисекунд, прошедших с `1970-01-01T00:00:00.000Z` (UTC). Может быть отрицательным для времени до эпохи.

**Возвращаемое значение**

* *(конструктор; не применяется)*

**Подробно**

Используйте этот конструктор, когда у вас уже есть числовой timestamp (например, из хранилища, сетевого протокола или `timestamp()` другого `DateTime`). Значение хранится как есть; преобразование часовых поясов не выполняется.

Типичные сценарии:

* Сохранить `timestamp()` в файл или в настройки.
* Позже прочитать и восстановить `DateTime` с тем же моментом времени.

**Пример**

```cpp
DateTime now;
long long saved = now.timestamp();

// later...
DateTime restored(saved);
String iso = restored.toString();
```

*В этом примере фиксируется текущее время, сохраняется его миллисекундный timestamp, и позже по этому значению восстанавливается тот же момент.*

---

#### `DateTime(const String &iso8601)`

**Signature**

```cpp
DateTime(const String &iso8601);
```

**Краткое описание**  
Создаёт DateTime из строки в формате ISO‑8601 (YYYY‑MM‑DDTHH:MM:SS.fffZ).

**Параметры**

* `iso8601` – `String`, содержащая UTC‑метку времени в формате ISO‑8601, например `"2024-05-10T14:30:00.000Z"`.

**Возвращаемое значение**

* *(конструктор; не применяется)*

**Подробно**

Этот конструктор разбирает строку с меткой времени в формате ISO‑8601 и конвертирует её в `DateTime`. Ожидаемый формат:

```text
YYYY-MM-DDTHH:MM:SS.fffZ
```

например: `"2025-11-27T21:15:30.250Z"`.

Ключевые моменты:

* Заканчивающий символ `'Z'` указывает на UTC; парсинг смещений по часовым поясам не выполняется.
* Ошибки разбора (неверный формат, недопустимая дата) приводят к поведению, определяемому реализацией; следует передавать корректные строки, обычно те, что возвращаются `DateTime::toString()`.

**Пример**

```cpp
String text("2024-01-01T00:00:00.000Z");
DateTime start(text);
```

*В этом примере конструируется `DateTime` из известной строки в формате ISO‑8601.*

---

#### `DateTime(const DateTime &other)`

**Signature**

```cpp
DateTime(const DateTime &other);
```

**Краткое описание**  
Создаёт копию другого DateTime.

**Параметры**

* `other` – существующий экземпляр `DateTime` для копирования.

**Возвращаемое значение**

* *(конструктор; не применяется)*

**Подробно**

Конструктор копирования дублирует внутренний timestamp с точностью до миллисекунд. Поскольку `DateTime` — простой тип значений, копирование дешёвое и безопасное. Изменения одного экземпляра (через `add()`) не влияют на копии.

**Пример**

```cpp
DateTime original;
DateTime copy(original);
// both represent the same instant initially
```

*Этот пример демонстрирует копирование значения `DateTime`.*

---

#### `~DateTime()`

**Signature**

```cpp
~DateTime();
```

**Краткое описание**  
Уничтожает DateTime и освобождает память.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; не применяется)*

**Подробно**

Когда объект `DateTime` выходит из области видимости, его деструктор освобождает внутренние ресурсы. Поскольку `DateTime` в основном инкапсулирует timestamp, разрушение обычно тривиально, но RAII гарантирует корректную обработку всех деталей реализации.

**Пример**

```cpp
{
  DateTime temp;
  String iso = temp.toString();
}
// temp is destroyed here
```

*Этот пример показывает `DateTime`, который создаётся и автоматически уничтожается при выходе из области видимости.*

---

#### `DateTime &operator=(const DateTime &other)`

**Signature**

```cpp
DateTime &operator=(const DateTime &other);
```

**Краткое описание**  
Присваивает этому DateTime значение другого DateTime.

**Параметры**

* `other` – `DateTime`, значение которого должно быть скопировано в `*this`.

**Возвращаемое значение**

* Ссылка на `*this`, позволяющая цепочку присваиваний.

**Подробно**

Оператор присваивания заменяет внутренний timestamp левого операнда на timestamp из `other`. После присваивания оба объекта представляют один и тот же момент, но их можно изменять независимо с помощью `add()`.

Самоприсваивание (`dt = dt`) безопасно.

**Пример**

```cpp
DateTime a;
DateTime b;

b = a;  // b now represents the same time as a
```

*В этом примере `DateTime` переназначается так, чтобы совпадать с другим.*

---

#### `DateTime &add(long long milliseconds)`

**Signature**

```cpp
DateTime &add(long long milliseconds);
```

**Краткое описание**  
Добавляет миллисекунды (отрицательное значение — вычитание). Возвращает этот DateTime для цепочек вызовов.

**Параметры**

* `milliseconds` – количество миллисекунд, которое следует добавить к текущему timestamp. Используйте отрицательное значение для вычитания.

**Возвращаемое значение**

* Ссылка на `*this` после модификации, что позволяет составные вызовы.

**Подробно**

`add()` корректирует `DateTime` на заданный относительный интервал времени. Он изменяет объект на месте, сдвигая его вперёд или назад.

Типичные варианты использования:

* Добавить секунды: `dt.add(1000 * seconds);`
* Добавить минуты: `dt.add(60 * 1000 * minutes);`
* Добавить часы: `dt.add(60 * 60 * 1000 * hours);`

Поскольку функция возвращает ссылку на `*this`, вы можете выполнять цепочки вызовов:

```cpp
deadline.add(60 * 1000).add(5 * 1000);
```

Учтите, что добавление очень больших положительных или отрицательных значений может привести к переполнению внутреннего timestamp (поведение определяется реализацией). Для типичных временных промежутков приложений это не вызывает проблем.

**Пример**

```cpp
DateTime now;
DateTime deadline(now);
deadline.add(5 * 60 * 1000);  // add 5 minutes
```

*В этом примере текущее время копируется в `deadline`, а затем сдвигается на 5 минут вперёд.*

---

#### `long long diff(const DateTime &other) const`

**Signature**

```cpp
long long diff(const DateTime &other) const;
```

**Краткое описание**  
Возвращает разницу в миллисекундах (положительное, если этот объект позже).

**Параметры**

* `other` – `DateTime`, с которым выполняется сравнение.

**Возвращаемое значение**

* Разница в миллисекундах: `timestamp() - other.timestamp()`. Результат:

  * Положительный, если `*this` позже, чем `other`.
  * Ноль, если они представляют один и тот же момент.
  * Отрицательный, если `*this` раньше, чем `other`.

**Подробно**

`diff()` — основной способ измерить прошедшее время или интервал:

* `end.diff(start)` → сколько миллисекунд прошло от `start` до `end`.
* `now.diff(past)` → положительная задержка (если `now` позже).
* `future.diff(now)` → положительное оставшееся время до `future`.

Внутренне это эквивалентно вычитанию двух timestamp. Метод не изменяет объекты.

**Пример**

```cpp
DateTime start;
// ... do some work ...
DateTime end;

long long elapsedMs = end.diff(start);
// elapsedMs is the duration between start and end in milliseconds
```

*Этот пример измеряет прошедшее время между двумя захваченными метками.*

---

#### `int compare(const DateTime &other) const`

**Signature**

```cpp
int compare(const DateTime &other) const;
```

**Краткое описание**  
Сравнивает с другим DateTime. Возвращает <0, 0, или >0.

**Параметры**

* `other` – `DateTime`, с которым производится сравнение.

**Возвращаемое значение**

* Отрицательное значение, если `*this` раньше, чем `other`.
* `0`, если оба представляют один и тот же момент.
* Положительное значение, если `*this` позже, чем `other`.

**Подробно**

`compare()` предоставляет трёхзначное сравнение, подходящее для сортировки или упорядочивания. Эквивалентно следующему:

```cpp
if (timestamp() < other.timestamp()) return negative;
if (timestamp() > other.timestamp()) return positive;
return 0;
```

Точные численные значения отрицательного/положительного результата не специфицированы; важен только знак.

**Пример**

```cpp
DateTime a;            // now
DateTime b(a);
b.add(1000);           // a second later

int result = a.compare(b);  // result < 0 because a is earlier
```

*В этом примере сравниваются два экземпляра `DateTime`, чтобы определить хронологический порядок.*

---

#### `bool equals(const DateTime &other) const`

**Signature**

```cpp
bool equals(const DateTime &other) const;
```

**Краткое описание**  
Возвращает true, если этот DateTime равен другому.

**Параметры**

* `other` – `DateTime`, с которым выполняется сравнение.

**Возвращаемое значение**

* `true`, если оба представляют одну и ту же миллисекунду с начала эпохи; иначе `false`.

**Подробно**

`equals()` проверяет строгую эквивалентность timestamp с точностью до миллисекунд. Это эквивалентно проверке равенства `timestamp()` у обоих объектов.

Этот метод функционально эквивалентен `operator==`, но в некоторых кодовых базах предпочитают явный метод для ясности.

**Пример**

```cpp
DateTime a;
DateTime b(a);

bool same = a.equals(b);  // true
```

*В этом примере используется `equals()`, чтобы проверить, представляют ли два объекта одно и то же время.*

---

#### `bool operator==(const DateTime &other) const`

**Signature**

```cpp
bool operator==(const DateTime &other) const;
```

**Краткое описание**  
Возвращает true, если этот DateTime равен другому.

**Параметры**

* `other` – `DateTime`, с которым выполняется сравнение.

**Возвращаемое значение**

* `true`, если timestamps равны; иначе `false`.

**Подробно**

Этот оператор обеспечивает идиоматическое сравнение в C++:

```cpp
if (a == b) { ... }
```

Внутренне он эквивалентен вызову `equals(other)`.

**Пример**

```cpp
DateTime a;
DateTime b(a);

if (a == b) {
  String msg("Times are equal");
}
```

*В этом примере проверяется равенство с помощью оператора `==`.*

---

#### `bool operator!=(const DateTime &other) const`

**Signature**

```cpp
bool operator!=(const DateTime &other) const;
```

**Краткое описание**  
Возвращает true, если этот DateTime не равен другому.

**Параметры**

* `other` – `DateTime`, с которым выполняется сравнение.

**Возвращаемое значение**

* `true`, если timestamps различаются; `false`, если они равны.

**Подробно**

Этот оператор — логическое отрицание `operator==`. Используйте его, когда нужно ветвить по неравенству:

```cpp
if (a != b) { ... }
```

**Пример**

```cpp
DateTime scheduled;
DateTime actual;

if (actual != scheduled) {
  String msg("Schedule changed");
}
```

*В этом примере определяется, отличается ли фактическое время от запланированного.*

---

#### `long long timestamp() const`

**Signature**

```cpp
long long timestamp() const;
```

**Краткое описание**  
Возвращает миллисекунды с начала эпохи Unix (1 янв. 1970).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* 64‑битное целое, представляющее количество миллисекунд с `1970-01-01T00:00:00.000Z` (UTC).

**Подробно**

`timestamp()` открывает внутреннее числовое представление `DateTime`. Используйте его, когда необходимо:

* Сохранить время в компактном, машинно‑удобном формате.
* Выполнить арифметику вне API `DateTime`.
* Взаимодействовать с другими системами, использующими миллисекундные timestamp.

Имейте в виду, что это основано на реальном системном времени; если системные часы откатятся назад, будущие объекты `DateTime()` могут иметь меньшие значения timestamp, чем предыдущие.

**Пример**

```cpp
DateTime now;
long long ms = now.timestamp();
// ms can be saved to a file or sent over the network
```

*В этом примере извлекается сырое значение миллисекундного timestamp из `DateTime`.*

---

#### `String toString() const`

**Signature**

```cpp
String toString() const;
```

**Краткое описание**  
Возвращает строку в формате ISO‑8601.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая время в UTC в формате ISO‑8601, например `"YYYY-MM-DDTHH:MM:SS.fffZ"`.

**Подробно**

`toString()` преобразует внутренний timestamp в человекочитаемую строку ISO‑8601 в UTC, включая миллисекунды и завершающий `'Z'`, указывающий на UTC.

Типичные случаи использования:

* Логирование меток времени.
* Встраивание значений времени в JSON или файлы конфигурации.
* Круговое преобразование с конструктором `DateTime(const String &iso8601)`.

Комбинация `timestamp()` и `toString()` даёт как машинно‑удобное, так и человекочитаемое представление одного и того же момента.

**Пример**

```cpp
DateTime now;
String iso = now.toString();  // e.g., "2025-11-27T21:05:30.123Z"
```

*В этом примере `DateTime` преобразуется в стандартную строку ISO‑8601 в UTC, пригодную для логирования или сохранения.*