# File

Класс `attoboy::File` — это унифицированная абстракция для потокового ввода и вывода (stream-based input and output) в библиотеке attoboy. Один тип представляет:

* Обычные файлы на диске.
* Клиентские TCP-сокеты (исходящие соединения).
* Серверные TCP-сокеты (прослушивание входящих соединений).
* Именованные каналы (named pipes), если это поддерживается платформой.

Такой дизайн позволяет работать с различными каналами ввода-вывода через единый API для чтения, записи и запроса состояния, не обращаясь напрямую к Windows API или другим низкоуровневым функциям.

### Потоки, файлы и сокеты (концептуальные основы)

Поток (stream) — это последовательность байтов, из которой можно читать или в которую можно записывать в порядке. Главное — вам не обязательно знать, где байты хранятся или как они передаются:

* Для обычного файла байты хранятся на диске.
* Для TCP-сокета байты передаются по сети другому хосту.
* Для серверного сокета вы ожидаете подключения других машин и затем создаёте отдельные клиентские сокеты для общения с каждым из них.
* Для именованного канала байты перемещаются между процессами на одной машине.

Класс `File` скрывает эти различия за общим интерфейсом:

* Вы можете вызвать `readAllToBuffer()` или `readAllToString()` как для файла, так и для сокета.
* Вы можете вызывать `write()` и `flush()` для обоих типов.
* При необходимости можно узнать тип дескриптора (`isRegularFile()`, `isSocket()` и т. п.) чтобы скорректировать поведение.

### Корректность (Validity) и состояние открытия (Open State)

Особо важны два метода:

* `isValid()` — был ли объект успешно создан или открыт (underlying handle успешно создан/открыт)?
* `isOpen()` — открыт ли дескриптор в данный момент (еще не закрыт или не полностью завершён)?

Типичный сценарий использования:

1. Создаёте `File` (по пути или для сокета).
2. Сразу проверяете `isValid()`.
3. Если валиден, выполняете чтение/запись, пока `isOpen()` возвращает `true`.
4. Вызываете `close()` по окончании работы или даёте деструктору автоматически закрыть дескриптор.

### Блокировка и доступность

Большинство операций `File` являются блокирующими (blocking):

* `readAllToBuffer()`, `readToBuffer()`, `readAllToString()`, `readToString()` обычно блокируют выполнение до тех пор, пока не появятся данные или поток не завершится.
* `write()` и `writeUpTo()` блокируют до тех пор, пока не будут записаны какие-то байты или пока не произойдёт ошибка.

Чтобы избежать блокировки при отсутствии данных, можно использовать:

* `hasAvailable()` — быстрый чек на наличие готовых к чтению данных.
* `getAvailableCount()` — сколько байтов можно прочитать без блокировки (если поддерживается).

Для обычных файлов «доступно» обычно означает «байты, оставшиеся до конца файла». Для сокетов и каналов — это байты, находящиеся в буфере и готовые к немедленному чтению.

### RAII и управление ресурсами

`File` использует RAII (Resource Acquisition Is Initialization):

* При создании `File` он захватывает ресурс ОС (дескриптор файла, сокет, канал).
* При уничтожении объекта `File` он автоматически закрывает связанный дескриптор, если он всё ещё открыт.

Также можно вызывать `close()` явно по окончании работы — это особенно важно для сетевых сокетов или когда нужно гарантированно сбросить данные и освободить файловые дескрипторы как можно скорее.

---

## Справочник

Каждый пункт ниже описывает один публичный конструктор, метод или оператор `attoboy::File`. Для каждого приведены:

* Подпись (Signature) — точное объявление из заголовка.
* Краткое описание (Synopsis) — исходный однострочный комментарий Doxygen.
* Описание параметров и возвращаемого значения.
* Подробности (In Depth) — дополнительное поведение, пограничные случаи и короткий пример.

> Примечание: все примеры предполагают `using namespace attoboy;`.

---

#### `File(const Path &path)`

**Signature**

```cpp
File(const Path &path);
```

**Synopsis**
Открывает файл по заданному пути для чтения и записи.

**Параметры**

* `path` – `Path`, указывающий файл для открытия.

**Возвращаемое значение**

* *(конструктор; не применимо)*

**Подробно**

Этот конструктор пытается открыть обычный файл по указанному пути:

* Если операция успешна, `isValid()` вернёт `true`.
* Если она не удалась (например, файл не существует или недостаточно прав), `isValid()` вернёт `false`, а `isOpen()` также будет `false`.

Файл открывается для чтения и записи в соответствии с внутренней политикой библиотеки. Вы можете использовать методы `read...` и `write...` на одном экземпляре `File`.

Всегда проверяйте `isValid()` после создания `File` из `Path` перед попыткой ввода-вывода.

**Пример**

```cpp
Path path("config.txt");
File f(path);

if (f.isValid()) {
  String contents = f.readAllToString();
  // Use contents...
  f.close();
}
```

*В этом примере файл открывается для чтения и записи, проверяется его валидность, читается весь текст, затем файл закрывается.*

---

#### `File(const String &host, int port)`

**Signature**

```cpp
File(const String &host, int port);
```

**Synopsis**
Открывает TCP-соединение к host:port.

**Параметры**

* `host` – имя хоста или IP-адрес для подключения (например, `"example.com"` или `"127.0.0.1"`).
* `port` – номер TCP-порта на удалённом хосте.

**Возвращаемое значение**

* *(конструктор; не применимо)*

**Подробно**

Этот конструктор действует как TCP-клиент:

* Он пытается подключиться к `host:port`.
* В случае успеха `isValid()` и `isOpen()` возвращают `true`, а `isSocket()` возвращает `true`.
* В случае неудачи (ошибки DNS, недоступный хост, отказ в соединении) `isValid()` возвращает `false`.

После установления соединения вы можете использовать те же методы `read...` и `write...`, что и для файлов. По окончании работы вызовите `close()` для завершения соединения.

**Пример**

```cpp
File socket("example.com", 80);

if (socket.isValid()) {
  String request = "GET / HTTP/1.0\r\nHost: example.com\r\n\r\n";
  socket.write(request);
  String response = socket.readAllToString();
  socket.close();
}
```

*В этом примере открывается TCP-соединение, отправляется простой HTTP-запрос, читается ответ и закрывается сокет.*

---

#### `File(int port)`

**Signature**

```cpp
File(int port);
```

**Synopsis**
Создаёт слушающий серверный сокет на указанном порту.

**Параметры**

* `port` – номер TCP-порта, на котором следует прослушивать входящие подключения.

**Возвращаемое значение**

* *(конструктор; не применимо)*

**Подробно**

Этот конструктор создаёт серверный сокет, который слушает новые подключения клиентов:

* В случае успеха `isValid()` вернёт `true`, `isServerSocket()` вернёт `true`, а `isSocket()` также вернёт `true`.
* В случае неудачи (порт занят, недостаточно привилегий) `isValid()` вернёт `false`.

Чтобы принять клиентское соединение, вызовите `accept()`, который вернёт новый экземпляр `File`, представляющий клиентский сокет.

**Пример**

```cpp
File server(8080);

if (server.isValid() && server.isServerSocket()) {
  File client = server.accept();
  if (client.isValid()) {
    String request = client.readAllToString();
    client.write("OK");
    client.close();
  }
}
```

*В этом примере создаётся серверный сокет, принимается один клиент, читается запрос, отправляется ответ `"OK"` и закрывается клиентское соединение.*

---

#### `File(const File &other)`

**Signature**

```cpp
File(const File &other);
```

**Synopsis**
Создаёт копию (разделяет базовый дескриптор).

**Параметры**

* `other` – существующий `File`, чей базовый дескриптор будет разделён.

**Возвращаемое значение**

* *(конструктор; не применимо)*

**Подробно**

Конструктор копирования создаёт новый объект `File`, который ссылается на тот же базовый дескриптор ОС, что и `other`:

* Операции на любом из экземпляров `File` влияют на один и тот же файл или сокет.
* Закрытие одного экземпляра обычно закрывает общий дескриптор; поведение другого экземпляра после этого становится зависимым от реализации.

Используйте это, когда вам нужно несколько объектов `File`, ссылающихся на один ресурс, но аккуратно координируйте время жизни и семантику закрытия.

**Пример**

```cpp
Path path("log.txt");
File f1(path);

if (f1.isValid()) {
  File f2(f1);           // shares the same handle
  f1.write("First\n");
  f2.write("Second\n");  // writes to the same file
}
```

*В этом примере два объекта `File` пишут через один и тот же базовый дескриптор.*

---

#### `~File()`

**Signature**

```cpp
~File();
```

**Synopsis**
Закрывает файл/сокет и освобождает ресурсы.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; не применимо)*

**Подробно**

При уничтожении объекта `File` он автоматически закрывает связанный файл или сокет, если тот ещё открыт. Это гарантирует, что ресурсы не будут утекать, даже если вы забыли вызвать `close()` явно.

RAII обеспечивает детерминированную очистку при правильном управлении областями видимости.

**Пример**

```cpp
{
  File f(Path("data.bin"));
  if (f.isValid()) {
    // perform I/O
  }
} // f is destroyed here; handle is closed automatically
```

*В этом примере деструктор закрывает файл при выходе объекта из области видимости.*

---

#### `File &operator=(const File &other)`

**Signature**

```cpp
File &operator=(const File &other);
```

**Synopsis**
Присваивает другой файл (делится базовым дескриптором).

**Параметры**

* `other` – `File`, чей дескриптор должен быть присвоен этому объекту.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочку присваиваний.

**Подробно**

Оператор копирующего присваивания заменяет текущий дескриптор (закрывая его при необходимости) и делает так, чтобы этот `File` разделял базовый дескриптор `other`. После присваивания:

* И `*this`, и `other` будут ссылаться на один и тот же ресурс.
* Закрытие одного влияет на общий дескриптор для обоих, аналогично конструктору копирования.

Всегда учитывайте совместное владение при присваивании объектов `File`.

**Пример**

```cpp
File f1(Path("output.txt"));
File f2(Path("backup.txt"));

if (f1.isValid()) {
  f2 = f1;            // f2 now refers to the same handle as f1
  f2.write("Hello");  // writes through the shared handle
}
```

*В этом примере один `File` присваивается другому, из-за чего они начинают делить один и тот же базовый дескриптор.*

---

#### `String getPath() const`

**Signature**

```cpp
String getPath() const;
```

**Synopsis**
Возвращает путь к файлу или пустую строку для сокетов.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая путь для обычных файлов, или пустая строка, если `File` представляет сокет или другой не-файловый дескриптор.

**Подробно**

Используйте `getPath()` чтобы узнать путь, связанный с обычным файлом. Это полезно для логирования или отладки.

Для сокетов (клиентских или серверных), а также, возможно, для именованных каналов, путь отсутствует, поэтому функция возвращает пустую строку.

**Пример**

```cpp
File f(Path("data.txt"));

if (f.isValid() && f.isRegularFile()) {
  String path = f.getPath();
  if (!path.isEmpty()) {
    // path contains "data.txt" (or the full resolved path)
  }
}
```

*В этом примере извлекается путь файла для обычного файлового дескриптора.*

---

#### `String getHost() const`

**Signature**

```cpp
String getHost() const;
```

**Synopsis**
Возвращает хост сокета или пустую строку для файлов.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая имя хоста для сокетов, или пустая строка для файловых дескрипторов.

**Подробно**

Для TCP-клиентского сокета, созданного через `File(const String &host, int port)`, `getHost()` возвращает хост, к которому вы подключились. Для обычных файлов и не-сокетов хост отсутствует, поэтому возвращается пустая строка.

**Пример**

```cpp
File socket("example.com", 80);

if (socket.isValid() && socket.isSocket()) {
  String host = socket.getHost();  // "example.com"
  if (!host.isEmpty()) {
    // Use host name
  }
}
```

*В этом примере запрашивается имя удалённого хоста у TCP-клиентского сокета.*

---

#### `int getPort() const`

**Signature**

```cpp
int getPort() const;
```

**Synopsis**
Возвращает порт сокета или -1 для файлов.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Номер порта, связанного с сокетом, или `-1`, если дескриптор не является сокетом.

**Подробно**

Для сокетов, созданных через `File(const String &host, int port)` или `File(int port)`:

* `getPort()` возвращает номер порта (удалённый порт для клиентов, локальный порт для серверов, в зависимости от реализации).

Для обычных файлов и не-сокетных дескрипторов возвращается `-1`.

**Пример**

```cpp
File server(8080);

if (server.isValid()) {
  int port = server.getPort();  // 8080
}
```

*В этом примере читается порт прослушивания у серверного сокета.*

---

#### `bool isValid() const`

**Signature**

```cpp
bool isValid() const;
```

**Synopsis**
Возвращает true, если файл/сокет был открыт успешно.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если базовый дескриптор был успешно создан или открыт; `false` в противном случае.

**Подробно**

`isValid()` — основной способ проверки, успешно ли прошло создание (или последующие операции, которые могли заменить дескриптор). Если он возвращает `false`:

* Все операции ввода-вывода обычно будут терпеть неудачу или вести себя как no-op.
* `isOpen()` обычно тоже будет `false`.

Всегда проверяйте `isValid()` сразу после создания `File`, чтобы избежать попыток I/O на невалидном дескрипторе.

**Пример**

```cpp
File f(Path("missing.txt"));

if (!f.isValid()) {
  // Handle error: file could not be opened
}
```

*В этом примере проверяется неудача при открытии файла и выполняется соответствующая обработка.*

---

#### `bool isOpen() const`

**Signature**

```cpp
bool isOpen() const;
```

**Synopsis**
Возвращает true, если файл/сокет в данный момент открыт.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если дескриптор в данный момент открыт; `false`, если он был закрыт или никогда не был успешно открыт.

**Подробно**

`isOpen()` сообщает, активен ли базовый дескриптор:

* Для обычных файлов он станет `false` после вызова `close()` или при некоторых фатальных ошибках.
* Для сокетов он станет `false` после `close()` или когда соединение полностью завершено.

Объект `File` может быть невалидным (`isValid() == false`) и при этом не открытым. Для валидного дескриптора `isOpen()` указывает, возможен ли дальнейший ввод-вывод.

**Пример**

```cpp
File f(Path("data.txt"));

if (f.isValid()) {
  // Do some I/O...
  f.close();
  bool stillOpen = f.isOpen();  // false
}
```

*В этом примере `isOpen()` становится `false` после явного закрытия.*

---

#### `void close()`

**Signature**

```cpp
void close();
```

**Synopsis**
Закрывает файл/сокет.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(нет)*

**Подробно**

`close()` явно освобождает связанный ресурс:

* Для файлов дальнейшие чтения или записи после закрытия будут приводить к ошибкам.
* Для сокетов соединение закрывается, а буферизованные данные обрабатываются в соответствии с поведением ОС.

Вызывать `close()` безопасно несколько раз; последующие вызовы обычно являются no-op.

Даже если вы полагаетесь на деструктор для закрытия дескриптора, явный вызов `close()` полезен, когда:

* Нужно быстро снять блокировки на файле.
* Нужно сигнализировать об окончании сетевой сессии до выхода из области видимости.

**Пример**

```cpp
File f(Path("output.txt"));

if (f.isValid()) {
  f.write("Done.\n");
  f.close();  // ensure data is flushed and handle is released
}
```

*В этом примере в файл записывается текст, затем он явно закрывается.*

---

#### `Buffer readAllToBuffer()`

**Signature**

```cpp
Buffer readAllToBuffer();
```

**Synopsis**
Читает все доступные данные в буфер.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Buffer`, содержащий все байты, которые можно прочитать до конца потока или до тех пор, пока больше нет немедленно доступных данных.

**Подробно**

Этот метод читает от текущей позиции до конца:

* Для обычных файлов обычно читается до конца файла от текущей позиции.
* Для сокетов и каналов читается до тех пор, пока удалённая сторона не закроет соединение или пока система не укажет, что немедленно доступных данных больше нет.

Возвращённый `Buffer` может быть пустым, если нечего читать или произошла ошибка.

**Пример**

```cpp
File f(Path("image.bin"));

if (f.isValid()) {
  Buffer data = f.readAllToBuffer();
  int size = data.length();
}
```

*В этом примере всё содержимое бинарного файла читается в `Buffer`.*

---

#### `Buffer readToBuffer(int count)`

**Signature**

```cpp
Buffer readToBuffer(int count);
```

**Synopsis**
Читает до count байтов в буфер.

**Параметры**

* `count` – Максимальное число байтов для чтения.

**Возвращаемое значение**

* `Buffer`, содержащий до `count` байтов. Может содержать меньше байтов, если поток закончился раньше или если в данный момент доступно меньше данных.

**Подробно**

Этот метод полезен, когда вы хотите контролировать объём чтения за один шаг, например при обработке файла частями:

* Он может блокировать выполнение до тех пор, пока не появится хотя бы один байт или поток не закончится.
* Останавливается, когда либо прочитано `count` байтов, либо немедленно доступных данных больше нет.

Если `count <= 0`, поведение зависит от реализации; передавайте положительные значения.

**Пример**

```cpp
File f(Path("data.bin"));

if (f.isValid()) {
  Buffer chunk = f.readToBuffer(1024);  // read up to 1024 bytes
}
```

*В этом примере читается блок до 1024 байтов из файла.*

---

#### `String readAllToString()`

**Signature**

```cpp
String readAllToString();
```

**Synopsis**
Читает все доступные данные в строку.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая все доступные данные, интерпретированные как UTF-8 текст.

**Подробно**

`readAllToString()` аналогичен `readAllToBuffer()`, но интерпретирует данные как UTF-8 и возвращает `String`. Это удобно для текстовых файлов, HTTP-ответов и других текстовых протоколов.

Если данные не являются корректным UTF-8, поведение зависит от реализации (возможно появление замещающих символов или усечение текста).

**Пример**

```cpp
File f(Path("notes.txt"));

if (f.isValid()) {
  String text = f.readAllToString();
}
```

*В этом примере весь текстовый файл читается в `String`.*

---

#### `String readToString(int count)`

**Signature**

```cpp
String readToString(int count);
```

**Synopsis**
Читает до count байтов в строку.

**Параметры**

* `count` – Максимальное число байтов для чтения.

**Возвращаемое значение**

* `String`, содержащая до `count` байтов, интерпретированных как UTF-8 текст.

**Подробно**

Этот метод похож на `readToBuffer(int)`, но возвращает `String`. Он полезен, когда нужно обрабатывать текст частями фиксированного размера или работать со стриминговыми протоколами.

Будьте осторожны при чтении частями, которые не выровнены по границам UTF-8 символов: многобайтовый символ может оказаться разделённым между чтениями, что приведёт к недопустимой промежуточной строке. Для простых ASCII-протоколов это не имеет значения.

**Пример**

```cpp
File f(Path("log.txt"));

if (f.isValid()) {
  String firstPart = f.readToString(1000);  // read up to 1000 bytes as text
}
```

*В этом примере читается ограниченный объём текста из файла.*

---

#### `bool hasAvailable() const`

**Signature**

```cpp
bool hasAvailable() const;
```

**Synopsis**
Возвращает true, если есть данные, готовые к чтению.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если хотя бы один байт можно прочитать без блокировки; `false` в противном случае.

**Подробно**

`hasAvailable()` — неблокирующий способ проверить наличие ожидающих данных:

* Для сокетов и каналов это помогает избежать блокирующих чтений, когда данных нет.
* Для обычных файлов это обычно указывает, есть ли байты между текущей позицией и концом файла.

Используйте это перед вызовом `read...`, если хотите избежать блокировок, особенно в простых событийных циклах.

**Пример**

```cpp
File socket("example.com", 80);

if (socket.isValid()) {
  if (socket.hasAvailable()) {
    String response = socket.readAllToString();
  }
}
```

*В этом примере проверяется наличие данных в сокете перед чтением.*

---

#### `int getAvailableCount() const`

**Signature**

```cpp
int getAvailableCount() const;
```

**Synopsis**
Возвращает количество байтов, доступных для чтения.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Количество байтов, которые можно прочитать без блокировки, или `0`, если ничего не доступно или если функция не поддерживается.

**Подробно**

`getAvailableCount()` уточняет `hasAvailable()` и возвращает число читаемых байтов:

* Для обычных файлов это обычно `endPosition - currentPosition`, ограниченное пределами реализации.
* Для сокетов и каналов возвращается количество байтов, находящихся в буфере и готовых к чтению.

Если платформа не поддерживает получение такой информации, может возвращаться `0` или другой сигнальный результат.

**Пример**

```cpp
File f(Path("data.bin"));

if (f.isValid()) {
  int available = f.getAvailableCount();
  Buffer chunk = f.readToBuffer(available);
}
```

*В этом примере запрашивается количество доступных байтов и читается ровно это количество.*

---

#### `int write(const Buffer &buf)`

**Signature**

```cpp
int write(const Buffer &buf);
```

**Synopsis**
Записывает буфер. Возвращает число записанных байтов или -1 при ошибке.

**Параметры**

* `buf` – `Buffer`, байты которого будут записаны в поток.

**Возвращаемое значение**

* Количество байтов, успешно записанных, или `-1` при ошибке.

**Подробно**

`write()` пытается записать всё содержимое `buf`:

* При успешной записи возвращаемое значение равно `buf.length()`.
* При частичных записях (чаще для сокетов) может вернуться меньшее число.
* При ошибке возвращается `-1`.

Всегда проверяйте возвращаемое значение, особенно для сетевых сокетов, и обрабатывайте частичные записи при необходимости.

**Пример**

```cpp
Buffer data(String("Hello\n"));
File f(Path("output.txt"));

if (f.isValid()) {
  int written = f.write(data);
  // written is the number of bytes actually written
}
```

*В этом примере буфер записывается в файл, и проверяется количество реально записанных байтов.*

---

#### `int write(const String &str)`

**Signature**

```cpp
int write(const String &str);
```

**Synopsis**
Записывает строку. Возвращает число записанных байтов или -1 при ошибке.

**Параметры**

* `str` – UTF-8 `String`, байты которой будут записаны.

**Возвращаемое значение**

* Количество записанных байтов (в UTF-8), или `-1` при ошибке.

**Подробно**

Это удобная перегрузка, которая конвертирует строку в байты и делегирует запись в базовую логику. Используйте её, когда работаете с текстом, а не с бинарными данными.

Как и для версии с `Buffer`, возможны частичные записи; возвращаемое значение может быть меньше, чем `str.byteLength()`.

**Пример**

```cpp
File f(Path("log.txt"));

if (f.isValid()) {
  f.write("Application started\n");
}
```

*В этом примере строка текста записывается напрямую.*

---

#### `int writeUpTo(const Buffer &buf, int count = -1)`

**Signature**

```cpp
int writeUpTo(const Buffer &buf, int count = -1);
```

**Synopsis**
Записывает до count байтов из буфера. Возвращает число записанных байтов или -1 при ошибке.

**Параметры**

* `buf` – буфер, байты которого будут записаны.
* `count` – максимальное число байтов для записи. Если `-1`, допускается весь буфер.

**Возвращаемое значение**

* Фактическое число записанных байтов или `-1` при ошибке.

**Подробно**

`writeUpTo()` полезен, когда вы хотите отправлять данные меньшими сегментами:

* Если `count` равно `-1`, метод рассматривает это как «до `buf.length()` байтов».
* Если `count` положительное, только первые `count` байтов буфера могут быть записаны.
* Как всегда, возвращаемое значение может быть меньше `count` из-за частичных записей.

**Пример**

```cpp
Buffer data(String("chunked data"));
File socket("example.com", 80);

if (socket.isValid()) {
  int written = socket.writeUpTo(data, 5);  // write first 5 bytes
}
```

*В этом примере записывается только часть буфера в сокет.*

---

#### `int writeUpTo(const String &str, int count = -1)`

**Signature**

```cpp
int writeUpTo(const String &str, int count = -1);
```

**Synopsis**
Записывает до count байтов из строки. Возвращает число записанных байтов или -1 при ошибке.

**Параметры**

* `str` – `String`, UTF-8 байты которой будут записаны.
* `count` – максимальное число байтов для записи. Если `-1`, допускается вся строка.

**Возвращаемое значение**

* Фактическое число записанных байтов или `-1` при ошибке.

**Подробно**

Эта перегрузка аналогична версии с `Buffer`, но принимает `String`. Будьте осторожны с многобайтовыми UTF-8 символами при ограничении по байтам:

* Если `count` обрывает многобайтовый символ, будут записаны лишь начальные байты; получатель может получить некорректный UTF-8.
* Для чистого ASCII это не проблема.

Используйте значение по умолчанию `-1`, когда нужно записать всю строку.

**Пример**

```cpp
String msg("Hello, world\n");
File f(Path("partial.txt"));

if (f.isValid()) {
  int written = f.writeUpTo(msg, 5);  // write "Hello"
}
```

*В этом примере записываются только первые 5 байтов строки в файл.*

---

#### `bool flush()`

**Signature**

```cpp
bool flush();
```

**Synopsis**
Сброс буферизованных данных. Возвращает true при успехе.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если сброс выполнен успешно или не требуется; `false`, если произошла ошибка.

**Подробно**

`flush()` гарантирует, что любые буферизованные данные будут переданы в базовую систему:

* Для обычных файлов это обычно приводит к тому, что данные переходят из пользовательских буферов в ОС.
* Для сокетов это может быть no-op, если система сразу отправляет данные.

Вызов `flush()` особенно важен, когда:

* Вы хотите убедиться, что запись лога сохранена на диске.
* Вы пишете протоколы, где важна своевременная доставка данных.

**Пример**

```cpp
File f(Path("log.txt"));

if (f.isValid()) {
  f.write("Critical event\n");
  bool ok = f.flush();
}
```

*В этом примере записывается лог и затем выполняется его сброс для гарантии сохранения.*

---

#### `bool setPosition(long long pos)`

**Signature**

```cpp
bool setPosition(long long pos);
```

**Synopsis**
Устанавливает позицию чтения/записи (только для файлов). Возвращает true при успехе.

**Параметры**

* `pos` – новая позиция в байтах от начала файла.

**Возвращаемое значение**

* `true`, если позиция успешно изменена; `false`, если операция не поддерживается или не удалась.

**Подробно**

`setPosition()` перемещает указатель файла на новый байтовый смещение:

* Поддерживается для обычных файлов.
* Обычно не поддерживается для сокетов или каналов; в таких случаях возвращается `false`.

Используйте это для реализации произвольного доступа:

* Перейдите в начало (`pos = 0`).
* Перейдите к конкретному смещению записи.

**Пример**

```cpp
File f(Path("data.bin"));

if (f.isValid() && f.isRegularFile()) {
  f.setPosition(0);                // rewind to start
  Buffer head = f.readToBuffer(16); // read first 16 bytes
}
```

*В этом примере файл перематывается в начало и читается заголовок фиксированного размера.*

---

#### `long long getPosition() const`

**Signature**

```cpp
long long getPosition() const;
```

**Synopsis**
Возвращает текущую позицию или -1, если не поддерживается.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Текущее смещение в байтах от начала файла, или `-1`, если операция не поддерживается.

**Подробно**

Для обычных файлов `getPosition()` возвращает текущую позицию указателя файла. Для сокетов и каналов смещение не имеет смысла, поэтому обычно возвращается `-1`.

Это полезно для отчёта о прогрессе или сохранения/восстановления позиции в файле.

**Пример**

```cpp
File f(Path("data.bin"));

if (f.isValid()) {
  long long pos = f.getPosition();
}
```

*В этом примере запрашивается текущая позиция чтения/записи в файле.*

---

#### `long long getEndPosition() const`

**Signature**

```cpp
long long getEndPosition() const;
```

**Synopsis**
Возвращает размер файла или -1, если не поддерживается.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Размер файла в байтах для обычных файлов, или `-1`, если операция не поддерживается (например, для сокетов).

**Подробно**

Для обычных файлов `getEndPosition()` обычно возвращает общий размер файла в байтах. В сочетании с `getPosition()` можно вычислять прогресс:

```cpp
progress = (double)getPosition() / getEndPosition();
```

Для неспецифичных потоков функция обычно возвращает `-1`.

**Пример**

```cpp
File f(Path("data.bin"));

if (f.isValid() && f.isRegularFile()) {
  long long size = f.getEndPosition();
}
```

*В этом примере получается общий размер обычного файла.*

---

#### `bool isAtEnd() const`

**Signature**

```cpp
bool isAtEnd() const;
```

**Synopsis**
Возвращает true, если достигнут конец файла.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если текущая позиция находится на или за пределами конца файла; `false` в противном случае.

**Подробно**

`isAtEnd()` в первую очередь имеет смысл для обычных файлов:

* После чтения до конца становится `true`.
* Для сокетов и каналов семантика может быть схожа, когда удалённая сторона закрывает соединение, но точное поведение зависит от реализации.

Используйте это, чтобы определить, когда вы прочитали весь контент файла, не сравнивая позиции вручную.

**Пример**

```cpp
File f(Path("data.txt"));

if (f.isValid()) {
  String all = f.readAllToString();
  bool done = f.isAtEnd();  // typically true after reading everything
}
```

*В этом примере проверяется, достигнут ли конец файла после чтения всего содержимого.*

---

#### `bool isRegularFile() const`

**Signature**

```cpp
bool isRegularFile() const;
```

**Synopsis**
Возвращает true, если это обычный файл.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если `File` представляет файл на диске; `false` в противном случае.

**Подробно**

Используйте `isRegularFile()` чтобы отличить файлы от сокетов и каналов. Это важно, когда нужно:

* Вызвать `setPosition()`, `getPosition()` или `getEndPosition()`, которые имеют смысл только для обычных файлов.
* Применить файловую логику, например перемотку или вычисление размера.

**Пример**

```cpp
File f(Path("data.bin"));

if (f.isRegularFile()) {
  long long size = f.getEndPosition();
}
```

*В этом примере подтверждается, что дескриптор — обычный файл, перед вызовом файловых API.*

---

#### `bool isSocket() const`

**Signature**

```cpp
bool isSocket() const;
```

**Synopsis**
Возвращает true, если это TCP-сокет.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если `File` представляет TCP-сокет (клиентский или серверный); `false` в противном случае.

**Подробно**

`isSocket()` позволяет быстро обнаружить сетевые дескрипторы. И клиентские сокеты (`File(const String&, int)`) и серверные (`File(int port)`) должны возвращать `true`.

В сочетании с `isServerSocket()` это позволяет различать слушающие сокеты и установленные соединения.

**Пример**

```cpp
File socket("example.com", 80);

if (socket.isSocket()) {
  // Perform network-specific logic
}
```

*В этом примере проверяется, является ли дескриптор сокетом, перед выполнением сетевой логики.*

---

#### `bool isServerSocket() const`

**Signature**

```cpp
bool isServerSocket() const;
```

**Synopsis**
Возвращает true, если это серверный (listening) сокет.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если дескриптор является слушающим серверным сокетом; `false` в противном случае.

**Подробно**

Серверные сокеты создаются через `File(int port)`. Они:

* Прослушивают входящие подключения.
* Используются вместе с `accept()` для создания клиентских сокетов.

Клиентские сокеты, созданные через `File(const String&, int)`, должны возвращать `false` для `isServerSocket()`.

**Пример**

```cpp
File listener(9000);

if (listener.isValid() && listener.isServerSocket()) {
  File client = listener.accept();
}
```

*В этом примере подтверждается, что `File` — серверный сокет перед вызовом `accept()`.*

---

#### `bool isNamedPipe() const`

**Signature**

```cpp
bool isNamedPipe() const;
```

**Synopsis**
Возвращает true, если это именованный канал (named pipe).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если базовый дескриптор — именованный канал; `false` в противном случае.

**Подробно**

Именованные каналы обеспечивают межпроцессное взаимодействие на одной машине. Использование и поддержка зависят от того, как `File` был создан другими частями библиотеки attoboy или интеграцией с системой.

`File` предоставляет этот метод, чтобы вы могли адаптировать логику при обработке таких дескрипторов.

**Пример**

```cpp
File f(Path("\\\\.\\pipe\\my_pipe"));

if (f.isNamedPipe()) {
  // Handle pipe-specific behavior
}
```

*В этом примере проверяется, представляет ли дескриптор именованный канал.*

---

#### `File accept()`

**Signature**

```cpp
File accept();
```

**Synopsis**
Принимает клиентское соединение на серверном сокете.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `File`, представляющий принятое клиентское соединение. Если принятие не удалось, возвращённый `File` будет невалидным (`isValid() == false`).

**Подробно**

`accept()` имеет смысл вызывать только на серверном сокете (`isServerSocket() == true`):

* Он блокирует до тех пор, пока клиент не подключится или не произойдёт ошибка.
* В случае успеха возвращается новый `File`, представляющий клиентское соединение. Этот новый `File` — обычный сокет (не серверный).
* Исходный серверный `File` остаётся открытым и может принимать новые соединения при повторном вызове `accept()`.

Если вызвать `accept()` на несерверном дескрипторе, поведение не определено; всегда проверяйте `isServerSocket()` заранее.

**Пример**

```cpp
File server(8080);

if (server.isValid() && server.isServerSocket()) {
  File client = server.accept();
  if (client.isValid()) {
    String msg = client.readAllToString();
    client.write("OK");
    client.close();
  }
}
```

*В этом примере принимается одно соединение на серверном сокете, выполняется обмен простым текстовым сообщением и закрывается клиентское соединение.*

---

#### `bool equals(const File &other) const`

**Signature**

```cpp
bool equals(const File &other) const;
```

**Synopsis**
Возвращает true, если этот файл равен другому.

**Параметры**

* `other` – другой `File` для сравнения.

**Возвращаемое значение**

* `true`, если оба объекта `File` ссылаются на один и тот же базовый дескриптор; `false` в противном случае.

**Подробно**

`equals()` сравнивает идентичность базового дескриптора ОС, а не содержимое файла или сокета. Два экземпляра `File` считаются равными, если они разделяют один и тот же внутренний дескриптор (например, созданы через копирующий конструктор или присваивание).

Это не сравнение путей или удалённых конечных точек; сравнивается сам дескриптор.

**Пример**

```cpp
File f1(Path("data.txt"));
File f2(f1);  // shares handle with f1

bool same = f1.equals(f2);  // true
```

*В этом примере два объекта `File` равны, потому что делят один и тот же дескриптор.*

---

#### `bool operator==(const File &other) const`

**Signature**

```cpp
bool operator==(const File &other) const;
```

**Synopsis**
Возвращает true, если этот файл равен другому.

**Параметры**

* `other` – другой `File` для сравнения.

**Возвращаемое значение**

* `true`, если оба объекта `File` ссылаются на один и тот же базовый дескриптор; `false` в противном случае.

**Подробно**

`operator==` — это сокращение для `equals(other)`. Он позволяет использовать идиоматические сравнения:

```cpp
if (a == b) { ... }
```

Как и `equals()`, сравнение выполняется по идентичности дескриптора, а не по содержимому файла.

**Пример**

```cpp
File a(Path("data.txt"));
File b(a);

if (a == b) {
  // a and b share the same handle
}
```

*В этом примере оператор равенства используется для проверки, ссылаются ли два `File` на один и тот же дескриптор.*

---

#### `bool operator!=(const File &other) const`

**Signature**

```cpp
bool operator!=(const File &other) const;
```

**Synopsis**
Возвращает true, если этот файл не равен другому.

**Параметры**

* `other` – другой `File` для сравнения.

**Возвращаемое значение**

* `true`, если два экземпляра `File` не ссылаются на один и тот же дескриптор; `false`, если ссылаются.

**Подробно**

Этот оператор — логическое отрицание `operator==`. Удобен, когда нужно удостовериться, что два дескриптора различны.

**Пример**

```cpp
File f1(Path("a.txt"));
File f2(Path("b.txt"));

if (f1 != f2) {
  // f1 and f2 refer to different handles (likely different files)
}
```

*В этом примере проверяется, что два объекта `File` ссылаются на разные ресурсы.*