# List

## Обзор

Класс `attoboy::List` — это **динамический массив**, который может хранить значения разных типов в одной последовательности. Он спроектирован как гибкая, лёгкая замена контейнерам вроде `std::vector` или `std::list`, но без зависимости от стандартной библиотеки C++. Вместо этого он интегрируется напрямую с другими типами attoboy:

* Примитивы: `bool`, `int`, `float`
* Текст: `String`
* Вложенные контейнеры: `List`, `Map`, `Set`

В основе `List` вы получаете:

* **Доступ по индексу** к элементам (с поддержкой отрицательных индексов для обращения с конца).
* **Модификацию на месте** (append, insert, remove, sort, reverse).
* **Методы, удобные для цепочек вызовов** (большинство мутирующих методов возвращают `*this`).
* **Простую сериализацию** в CSV и JSON строки и обратно.

### Смешанные типы и `ValueType`

Поскольку `List` может содержать смешанные типы, каждый элемент имеет связанный **тег типа** из перечисления `ValueType`:

* `TYPE_BOOL`, `TYPE_INT`, `TYPE_FLOAT`
* `TYPE_STRING`, `TYPE_LIST`, `TYPE_MAP`, `TYPE_SET`
* `TYPE_NULL`, `TYPE_INVALID`, `TYPE_UNKNOWN` для специальных или ошибочных состояний

Функция `typeAt()` позволяет проверить тип, хранящийся по данному индексу, прежде чем извлекать значение, чтобы вы могли безопасно определить, какой C++ тип использовать при чтении.

Для удобства аксессоры `at()` и `operator[]` возвращают лёгкий прокси-тип (`ListValueView`), который может неявно приводиться к конкретному типу, который вам нужен. Это позволяет писать компактные выражения типа `String s = list.at(1);` или `int x = list[i];` без указания параметров шаблона. При присвоении прокси-представления переменной типа `T` он использует те же правила преобразования, что и шаблонные перегрузки `at<T>()` и `operator[]<T>()`.

### Индексация и отрицательные индексы

Элементы доступны по **индексу**, причём индексы поддерживают полезное расширение:

* `0` — первый элемент.
* `1` — второй, и т. д.
* `-1` — относится к **последнему** элементу.
* `-2` — к предпоследнему и т. д.

Это поведение применяется ко всем операциям, принимающим индекс элемента (таким как `at()`, `pop()`, `remove()` и `set()`), если не указано иное. Отрицательные индексы часто удобны, когда нужно обратиться или изменить элементы относительно конца списка.

### Изменяемость и цепочки вызовов

В отличие от `String`, `List` — **изменяемый**: методы вроде `append()`, `remove()` и `sort()` изменяют список на месте. Большинство таких методов возвращают ссылку на `*this`, что позволяет использовать **цепочки вызовов**:

```cpp
using namespace attoboy;

List values;
values.append(1)
      .append(2)
      .append(3)
      .reverse()
      .append(4);
// values теперь содержит [3, 2, 1, 4]
```

Такой стиль облегчает компактное и читабельное описание преобразований над одним списком.

### Владение и RAII

`List` использует принцип **RAII** (Resource Acquisition Is Initialization):

* Конструктор выделяет любые необходимые внутренние ресурсы.
* Деструктор автоматически освобождает память, когда список выходит из области видимости.
* Копирование и присвоение выполняют корректное управление совместным или копируемым внутренним состоянием.

Это означает, что вам не нужно вручную освобождать память; достаточно дать объекту `List` выйти из области видимости.

### Интеграция с CSV и JSON

`List` включает встроенную поддержку **CSV** (comma-separated values) и **JSON**:

* `toCSVString()` и `FromCSVString()` позволяют просто импортировать/экспортировать табличные данные, представленные как список списков.
* `toJSONString()` и `FromJSONString()` позволяют трактовать список как JSON-массив, совместимый с другими частями библиотеки attoboy, которые работают со строками JSON.

Эти помощники делают `List` естественным мостом между структурированными данными в памяти и текстовыми форматами на диске или по сети.

---

## Справочник

Каждый пункт ниже описывает один публичный конструктор, метод, статическую функцию или оператор `attoboy::List`. Для каждого вы найдёте:

* **Сигнатура** – точное объявление из заголовочного файла.
* **Краткое описание** – исходный однострочный комментарий Doxygen.
* **Параметры** и **Описание возвращаемого значения**.
* **Подробнее** – дополнительные детали, оговорки и краткий пример.

> **Примечание:** Во всех примерах предполагается `using namespace attoboy;`.

---

#### `List()`

**Сигнатура**

```cpp
List();
```

**Краткое описание**
Создаёт пустой список.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Этот конструктор создаёт список без элементов и без зарезервированной ёмкости, кроме той, которую реализация выбирает по умолчанию. Сразу после создания:

* `length()` возвращает `0`.
* `isEmpty()` возвращает `true`.

Это стандартная отправная точка для постепенного построения списка с помощью `append()`, `prepend()` или `insert()`.

**Пример**

```cpp
List values;
values.append(1).append(2);
// values теперь содержит [1, 2]
```

*Этот пример начинается с пустого списка и добавляет два элемента.*

---

#### `List(int capacity)`

**Сигнатура**

```cpp
List(int capacity);
```

**Краткое описание**
Создаёт пустой список с зарезервированной ёмкостью.

**Параметры**

* `capacity` – подсказка о том, сколько элементов вы планируете хранить.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Этот конструктор создаёт пустой список, но предварительно выделяет внутреннюю память примерно под `capacity` элементов. Это может сократить количество реаллокаций и копирований, когда вы знаете размер заранее, например при чтении набора данных известной длины.

Список при этом остаётся пустым; `length()` равен `0`, пока вы не добавите элементы.

**Пример**

```cpp
int expected = 100;
List values(expected);
for (int i = 0; i < expected; ++i) {
  values.append(i);
}
```

*Этот пример заранее резервирует место для 100 целых чисел, чтобы уменьшить число внутренних переразмериваний.*

---

#### `template <typename... Args> List(const Args &...args)`

**Сигнатура**

```cpp
template <typename... Args> List(const Args &...args) : List() {
  variadic_append(args...);
}
```

**Краткое описание**
Создаёт список с заданными значениями: List(1, "two", 3.0f)

**Параметры**

* `args` – один или несколько значений, которые будут вставлены в список в порядке следования. Каждый должен быть типом, который `List` может хранить (например, `bool`, `int`, `float`, `const char *`, `String`, `List`, `Map` или `Set`).

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Этот вариативный конструктор предоставляет компактный способ создать `List` с начальным набором значений. Внутри он:

1. Конструирует пустой список.
2. Добавляет каждое значение из `args` по порядку с помощью того же механизма, что и `append()`.

Удобно для небольших списков или когда вы хотите выразить литерал-подобную последовательность.

**Пример**

```cpp
List mixed(1, "two", 3.0f);
// mixed содержит [1, "two", 3.0f]
```

*Этот пример создаёт разнородный список в одном выражении.*

---

#### `List(const List &other)`

**Сигнатура**

```cpp
List(const List &other);
```

**Краткое описание**
Создаёт копию другого списка.

**Параметры**

* `other` – существующий список, содержимое которого должно быть скопировано.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Конструктор копирования создаёт новый список, содержащий ту же последовательность значений, что и `other`. Точная модель владения внутренняя, но с точки зрения пользователя:

* Изменение одного списка не меняет содержимое другого.
* Память и дескрипторы автоматически очищаются, когда каждый список уничтожается.

**Пример**

```cpp
List original(1, 2, 3);
List copy(original);
// copy изначально имеет те же элементы, что и original
```

*Этот пример дублирует список, так что обе переменные начинаются с одинаковым содержимым.*

---

#### `List(const Set &set)`

**Сигнатура**

```cpp
List(const Set &set);
```

**Краткое описание**
Создаёт список из множества.

**Параметры**

* `set` – исходный `Set`, значения которого будут скопированы в список.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Этот конструктор преобразует `Set` в `List`, копируя все значения из множества. Получившийся список:

* Содержит каждое уникальное значение ровно один раз (так как множества не допускают дубликатов).
* Не гарантирует какого-либо определённого порядка; он зависит от того, как множество хранит свои элементы.

Полезно, когда вам нужны операции, характерные для списка (доступ по индексу, сортировка, экспорт в CSV) для набора значений.

**Пример**

```cpp
Set unique(3, 1, 2);   // множество {3, 1, 2}
List asList(unique);   // список с теми же значениями, порядок не определён
```

*Этот пример конвертирует множество чисел в список, чтобы иметь возможность индексированных операций.*

---

#### `~List()`

**Сигнатура**

```cpp
~List();
```

**Краткое описание**
Уничтожает список и освобождает память.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробнее**

Когда `List` выходит из области видимости или иначе уничтожается, его деструктор:

* Освобождает внутренние буферы.
* Очищает связанные ресурсы.

Поскольку attoboy использует RAII, вам никогда не нужно вручную освобождать память, связанную со списком.

**Пример**

```cpp
{
  List temp(1, 2, 3);
  // используйте temp здесь
}
// temp уничтожается; связанная память освобождается
```

*Этот пример показывает локальный список, который автоматически очищается.*

---

#### `List &operator=(const List &other)`

**Сигнатура**

```cpp
List &operator=(const List &other);
```

**Краткое описание**
Присваивает этому списку другой список.

**Параметры**

* `other` – список, содержимое которого должно заменить текущее.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочки присвоений.

**Подробнее**

Оператор присвоения копирующим образом заменяет содержимое текущего списка на содержимое `other`. После присвоения:

* `length()` соответствует `other.length()`.
* Значения элементов совпадают с таковыми в `other` и имеют тот же порядок.

Самоприсвоение (`list = list`) безопасно.

**Пример**

```cpp
List a(1, 2);
List b(3, 4, 5);

a = b;
// a теперь содержит [3, 4, 5]
```

*Этот пример перезаписывает один список другим.*

---

#### `int length() const`

**Сигнатура**

```cpp
int length() const;
```

**Краткое описание**
Возвращает количество элементов в списке.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Текущее количество хранимых элементов.

**Подробнее**

`length()` — основной способ узнать, сколько элементов в списке. Допустимые индексы для доступа к элементам находятся в диапазоне от `0` до `length() - 1` (и соответствующий отрицательный диапазон от `-length()` до `-1`).

**Пример**

```cpp
List values(1, 2, 3);
int n = values.length();  // 3
```

*Этот пример запрашивает текущее число элементов.*

---

#### `bool isEmpty() const`

**Сигнатура**

```cpp
bool isEmpty() const;
```

**Краткое описание**
Возвращает true, если список пуст.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если `length() == 0`; иначе `false`.

**Подробнее**

Это удобная функция, эквивалентная проверке `length() == 0`. Часто выглядит более ясно и выразительно в условиях.

**Пример**

```cpp
List values;
if (values.isEmpty()) {
  values.append("first");
}
```

*Этот пример инициализирует список только если он в настоящий момент пуст.*

---

#### `template <typename T> List &append(T value)`

**Сигнатура**

```cpp
template <typename T> List &append(T value) {
  append_impl(value);
  return *this;
}
```

**Краткое описание**
Добавляет значение в конец. Возвращает этот список для цепочек.

**Параметры**

* `value` – значение, которое будет добавлено в конец списка. Должно быть поддерживаемого типа (например, `bool`, `int`, `float`, `const char *`, `String`, `List`, `Map` или `Set`).

**Возвращаемое значение**

* Ссылка на `*this`, позволяющая цепочки вида `list.append(1).append(2)`.

**Подробнее**

`append()` добавляет новый элемент после текущего последнего элемента. Это увеличивает длину списка на единицу. Если внутренняя ёмкость превышена, список автоматически растёт.

Поскольку метод шаблонный, вы можете передавать значения разных типов. Внутри выбирается соответствующая перегрузка `append_impl()`.

**Пример**

```cpp
List values;
values.append(1)
      .append("two")
      .append(3.0f);
// values содержит [1, "two", 3.0f]
```

*Этот пример добавляет несколько разнородных значений с помощью цепочек вызовов.*

---

#### `template <typename T> List &prepend(T value)`

**Сигнатура**

```cpp
template <typename T> List &prepend(T value) {
  prepend_impl(value);
  return *this;
}
```

**Краткое описание**
Вставляет значение в начало. Возвращает этот список для цепочек.

**Параметры**

* `value` – значение, которое будет вставлено в начало.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробнее**

`prepend()` вставляет значение по индексу `0`, сдвигая существующие элементы на большие индексы. Это полезно при построении списка спереди или когда нужно быстро добавить заголовочный элемент.

**Пример**

```cpp
List values(2, 3);
values.prepend(1);
// values содержит [1, 2, 3]
```

*Этот пример добавляет элемент в начало списка.*

---

#### `template <typename T> List &insert(int index, T value)`

**Сигнатура**

```cpp
template <typename T> List &insert(int index, T value) {
  insert_impl(index, value);
  return *this;
}
```

**Краткое описание**
Вставляет значение по индексу. Возвращает этот список для цепочек.

**Параметры**

* `index` – позиция для вставки. Отрицательные индексы считаются от конца.
* `value` – значение для вставки.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробнее**

`insert()` добавляет новый элемент на указанную **позицию**, сдвигая существующие элементы, находящиеся в этой позиции и дальше, вправо. Правила для индекса:

* `0` — вставить в начало.
* `length()` — вставить в конец (эквивалентно `append()`).
* Отрицательные значения — считаются от конца (`-1` — перед последним элементом и т. п.), поведение зависит от того, как индексы сопоставляются внутри.

Убедитесь, что `index` находится в допустимом диапазоне (включая корректные отрицательные индексы); выход за диапазон приводит к неопределённому или зависящему от реализации поведению.

**Пример**

```cpp
List values(1, 3);
values.insert(1, 2);
// values содержит [1, 2, 3]
```

*Этот пример вставляет новый элемент в середину списка.*

---

#### `template <typename T> List &set(int index, T value)`

**Сигнатура**

```cpp
template <typename T> List &set(int index, T value) {
  set_impl(index, value);
  return *this;
}
```

**Краткое описание**
Заменяет значение по индексу. Возвращает этот список для цепочек.

**Параметры**

* `index` – индекс элемента, который будет перезаписан. Отрицательные индексы считаются от конца.
* `value` – новое значение для хранения в этой позиции.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробнее**

`set()` заменяет значение по указанному индексу, не меняя длину списка и не смещая другие элементы. Правила индексации (включая отрицательные индексы) такие же, как у `insert()` и `at()`.

Убедитесь, что индекс ссылается на существующий элемент (т. е. `-length() <= index < length()`).

**Пример**

```cpp
List values("red", "green", "blue");
values.set(1, "yellow");
// values содержит ["red", "yellow", "blue"]
```

*Этот пример перезаписывает один элемент в списке.*

---

#### `List &remove(int index)`

**Сигнатура**

```cpp
List &remove(int index);
```

**Краткое описание**
Удаляет элемент по индексу. Возвращает этот список для цепочек.

**Параметры**

* `index` – индекс удаляемого элемента. Отрицательные индексы считаются от конца.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробнее**

`remove()` удаляет элемент по указанному индексу и сдвигает последующие элементы на одну позицию влево. Длина списка уменьшается на единицу.

Поведение неопределено, если индекс выходит за пределы. Можно защититься проверкой `length()` или использовать `isEmpty()`, работая с отрицательными индексами вроде `-1`.

**Пример**

```cpp
List values("a", "b", "c");
values.remove(1);
// values содержит ["a", "c"]
```

*Этот пример удаляет средний элемент из списка из трёх элементов.*

---

#### `List &clear()`

**Сигнатура**

```cpp
List &clear();
```

**Краткое описание**
Удаляет все элементы. Возвращает этот список для цепочек.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробнее**

`clear()` полностью очищает список:

* `length()` становится `0`.
* `isEmpty()` становится `true`.

Ёмкость может быть уменьшена или нет; детали реализации скрыты.

**Пример**

```cpp
List values(1, 2, 3);
values.clear();
// values теперь пуст
```

*Этот пример очищает все элементы списка.*

---

#### `List &reverse()`

**Сигнатура**

```cpp
List &reverse();
```

**Краткое описание**
Инвертирует порядок элементов на месте. Возвращает этот список для цепочек.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробнее**

`reverse()` переупорядочивает список так, что первый элемент становится последним, второй — предпоследним и т. д. Длина и типы элементов не меняются; изменяются только их позиции.

**Пример**

```cpp
List values(1, 2, 3);
values.reverse();
// values содержит [3, 2, 1]
```

*Этот пример обращает порядок элементов.*

---

#### `List &sort(bool ascending = true)`

**Сигнатура**

```cpp
List &sort(bool ascending = true);
```

**Краткое описание**
Сортирует элементы. Возвращает этот список для цепочек.

**Параметры**

* `ascending` – если `true` (по умолчанию), сортировать по возрастанию; если `false`, — по убыванию.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробнее**

`sort()` переупорядочивает элементы согласно внутреннему сравнению. Поскольку `List` может хранить смешанные типы, поведение сортировки для списков с разными типами значений зависит от реализации. Для предсказуемых результатов:

* Убедитесь, что все элементы одного **типа** (например, все `int` или все `String`).
* Избегайте смешивания чисел, строк и контейнеров в одном списке при сортировке.

**Пример**

```cpp
List numbers(3, 1, 2);
numbers.sort();
// numbers содержит [1, 2, 3]
```

*Этот пример сортирует чисто числовой список по возрастанию.*

---

#### `List &concat(const List &other)`

**Сигнатура**

```cpp
List &concat(const List &other);
```

**Краткое описание**
Добавляет все элементы из другого списка. Возвращает этот список для цепочек.

**Параметры**

* `other` – список, элементы которого будут добавлены в конец этого списка.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробнее**

`concat()` проходит по `other` и добавляет каждый элемент по порядку. Исходный `other` не модифицируется. Длина результирующего списка становится `length() + other.length()`.

**Пример**

```cpp
List a(1, 2);
List b(3, 4);

a.concat(b);
// a содержит [1, 2, 3, 4]
// b остаётся без изменений
```

*Этот пример объединяет все элементы одного списка с другим.*

---

#### `List &concat(const Set &set)`

**Сигнатура**

```cpp
List &concat(const Set &set);
```

**Краткое описание**
Добавляет все значения из множества. Возвращает этот список для цепочек.

**Параметры**

* `set` – `Set`, значения которого будут добавлены.

**Возвращаемое значение**

* Ссылка на `*this`.

**Подробнее**

Эта перегрузка ведёт себя аналогично `concat(const List&)`, но читает элементы из `Set`. Поскольку множества неупорядочены, порядок, в котором значения добавляются, зависит от реализации.

Дубликаты не вводятся самим множеством (каждое значение появляется не более одного раза), но добавление в существующий список всё равно может привести к появлению дубликатов в итоговом списке.

**Пример**

```cpp
Set tags("red", "green");
List allTags("blue");
allTags.concat(tags);
// allTags теперь содержит "blue" и значения множества, порядок не определён
```

*Этот пример объединяет список и множество в один список.*

---

#### `template <typename T> T pop()`

**Сигнатура**

```cpp
template <typename T> T pop();
```

**Краткое описание**
Удаляет и возвращает элемент по индексу.

**Параметры**

* *(в сигнатуре нет; индекс подразумевается)*

**Возвращаемое значение**

* Удалённый из списка элемент, приведённый к типу `T`.

**Подробнее**

Хотя в кратком описании говорится «по индексу», сигнатура не принимает явный параметр индекса. Предполагаемое поведение — удалить и вернуть элемент, обычно с конца или с другой фиксированной позиции, выбранной реализацией. Вы должны запросить тип `T`, соответствующий типу хранимого значения.

Важные замечания:

* Если список пуст, поведение неопределено; сначала проверьте `isEmpty()`.
* Если тип хранимого элемента не совпадает с `T`, результат неопределён или может быть неинформативен.

**Пример**

```cpp
List values(1, 2, 3);
int last = values.pop<int>();
// last содержит 3 (зависит от реализации)
// values теперь содержит [1, 2]
```

*Этот пример удаляет и возвращает элемент из списка, после чего использует изменённый список.*

---

#### `ListValueView at(int index) const`

**Сигнатура**

```cpp
ListValueView at(int index) const;
```

**Краткое описание**
Возвращает типизированный вид (view) элемента по индексу.

**Параметры**

* `index` – индекс элемента для доступа. Отрицательные индексы считаются от конца.

**Возвращаемое значение**

* Прокси-объект `ListValueView`, ссылающийся на элемент по заданному индексу.

**Подробнее**

Эта перегрузка `at()` возвращает **прокси-объект**, который ссылается на элемент по `index`, не фиксируя сразу конкретный C++ тип. Обычно вам не нужно работать с `ListValueView` напрямую:

* При **присвоении** результата переменной типа `T` прокси неявно приводится к `T`.
* Преобразование использует ту же логику и ограничения, что и `at<T>(index)`.

Это позволяет писать простой, идиоматичный код:

```cpp
String name = values.at(0);
int count   = values.at(1);
```

вместо явного указания параметров шаблона.

Вы всё ещё должны гарантировать:

1. `index` находится в пределах (`-length() <= index < length()`).
2. Время выполнения: тип элемента совместим с C++ типом, в который вы приводите (например, хранимое значение — число при приведении к `int`, или строка при приведении к `String`).

Если любое из условий нарушено, результат неопределён или может быть неинформативен.

**Пример**

```cpp
List values("Alice", "Bob", 42);

// Неявное преобразование из ListValueView в String
String first = values.at(0);  // "Alice"

// Неявное преобразование из ListValueView в int
int answer = values.at(2);    // 42 (если совместимо с TYPE_INT)
```

*Этот пример показывает, как не-шаблонный `at()` возвращает прокси, который удобно преобразуется в нужный тип.*

---

#### `template <typename T> T at(int index) const`

**Сигнатура**

```cpp
template <typename T> T at(int index) const;
```

**Краткое описание**
Возвращает элемент по индексу.

**Параметры**

* `index` – индекс элемента для доступа. Отрицательные индексы считаются от конца.

**Возвращаемое значение**

* Значение по заданному индексу в виде типа `T`.

**Подробнее**

Эта шаблонная перегрузка возвращает копию элемента по указанному индексу, явно приведённую к запрошенному типу `T`.

Она концептуально эквивалентна взятию `ListValueView` из не-шаблонного `at(int)` и последующему приведению прокси к `T`. Основные различия:

* Вы явно указываете тип `T` в месте вызова (например, `at<String>(index)`).
* Это может быть понятнее в коде, когда вы хотите подчеркнуть ожидаемый тип или избежать неявных преобразований.

Как и в случае с прокси, вы должны:

1. Убедиться, что `index` в пределах (`-length() <= index < length()`).
2. Убедиться, что тип элемента совместим с `T`, что можно проверить через `typeAt(index)`.

**Пример**

```cpp
List values("Alice", "Bob");

// Явный выбор типа
String name = values.at<String>(0);

// Это эквивалентно:
String name2 = values.at(0);  // через ListValueView
```

*Этот пример получает строковый элемент по индексу с помощью шаблонного `at<T>()`, когда нужно явно указать тип.*

---

#### `ListValueView operator[](int index) const`

**Сигнатура**

```cpp
ListValueView operator[](int index) const;
```

**Краткое описание**
Возвращает типизированный вид (view) элемента по индексу.

**Параметры**

* `index` – индекс элемента для доступа. Отрицательные индексы считаются от конца.

**Возвращаемое значение**

* Прокси-объект `ListValueView`, ссылающийся на элемент по заданному индексу.

**Подробнее**

Эта перегрузка обеспечивает идиоматичный синтаксис с квадратными скобками для доступа к элементам при сохранении поддержки смешанных типов. Она возвращает тот же прокси-тип, что и `at(int)`, поэтому можно писать:

```cpp
String name = values[0];
int    age  = values[1];
```

Прокси преобразуется в тот C++ тип, который вы используете слева от присвоения (или при инициализации), с теми же ограничениями, что и `at<T>()`.

Ключевые моменты:

* Правила индексации (включая отрицательные индексы) идентичны `at()`.
* Проверки границ и совместимости типов не выполняются автоматически; при необходимости используйте `length()` и `typeAt()`.
* Если тип элемента во время выполнения несовместим с целевым C++ типом, результат неопределён или может быть неинформативен.

Если вы предпочитаете более явный, но потенциально более подверженный ошибкам код, можно комбинировать доступ через скобки с `typeAt()` для принятия решения о том, как интерпретировать значение.

**Пример**

```cpp
List values("Alice", "Bob", 42);

String second = values[1];  // "Bob"
int answer    = values[2];  // 42 (если совместимо с TYPE_INT)
```

*Этот пример демонстрирует идиоматический доступ по скобкам с возвратом прокси-объекта.*

---

#### `template <typename T> T operator[](int index) const`

**Сигнатура**

```cpp
template <typename T> T operator[](int index) const;
```

**Краткое описание**
Возвращает элемент по индексу.

**Параметры**

* `index` – индекс элемента для доступа. Отрицательные индексы считаются от конца.

**Возвращаемое значение**

* Значение по заданному индексу в виде типа `T`.

**Подробнее**

Эта шаблонная перегрузка — более явный аналог прокси-версии `operator[](int)`:

* Она сразу возвращает значение типа `T`.
* Ведёт себя как взятие `list.at(index)` (прокси) и приведение его к `T`.

В повседневном коде вы чаще будете использовать не-шаблонный `operator[]` и позволять компилятору вывести тип по контексту присвоения или инициализации. Шаблонная форма полезна, когда:

* Вы хотите явно указать ожидаемый тип, или
* Вы вызываете `operator[]` в контексте, где целевой тип не очевиден из окружающего кода.

Правила индексации и соответствия типов такие же, как и для `at<T>()`.

**Пример**

```cpp
List values("Alice", "Bob");

// Явный синтаксис шаблона
String second = values.operator[]<String>(1);

// Семантически похоже, но более кратко:
String second2 = values[1];
```

*Этот пример сопоставляет явный доступ через шаблон с более кратким прокси-основанным синтаксисом.*

---

#### `ValueType typeAt(int index) const`

**Сигнатура**

```cpp
ValueType typeAt(int index) const;
```

**Краткое описание**
Возвращает тип элемента по индексу.

**Параметры**

* `index` – индекс элемента для проверки. Отрицательные индексы считаются от конца.

**Возвращаемое значение**

* Значение перечисления `ValueType`, описывающее хранимый тип (например, `TYPE_INT`, `TYPE_STRING` и т. п.).

**Подробнее**

`typeAt()` позволяет безопасно определить, какой тип хранится по данному индексу, прежде чем извлекать его через `at<T>()`, `pop<T>()` или `operator[]<T>()`. Если индекс выходит за пределы, результат неопределён; следует предварительно проверять диапазоны.

**Пример**

```cpp
List values(1, "two", 3.0f);
ValueType t0 = values.typeAt(0);  // TYPE_INT (обычно)
ValueType t1 = values.typeAt(1);  // TYPE_STRING
ValueType t2 = values.typeAt(2);  // TYPE_FLOAT
```

*Этот пример проверяет типы нескольких элементов в смешанном списке.*

---

#### `List slice(int start, int end) const`

**Сигнатура**

```cpp
List slice(int start, int end) const;
```

**Краткое описание**
Возвращает новый список с элементами от start до end.

**Параметры**

* `start` – индекс первого включаемого элемента. Отрицательные индексы считаются от конца.
* `end` – индекс **после** последнего включаемого элемента (исключительно). Отрицательные индексы считаются от конца.

**Возвращаемое значение**

* Новый `List`, содержащий элементы в диапазоне `[start, end)`.

**Подробнее**

`slice()` создаёт поверхностную копию (shallow copy) поддиапазона списка. Например:

* `slice(0, length())` возвращает копию всего списка.
* `slice(1, 3)` возвращает элементы с индексами `1` и `2`.

Индексы работают так же, как в `at()` и `set()`. Убедитесь, что `start` и `end` описывают допустимый поддиапазон.

**Пример**

```cpp
List values(10, 20, 30, 40);
List middle = values.slice(1, 3);
// middle содержит [20, 30]
```

*Этот пример извлекает подсписок из середины большего списка.*

---

#### `List duplicate() const`

**Сигнатура**

```cpp
List duplicate() const;
```

**Краткое описание**
Возвращает копию этого списка.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Новый `List`, содержащий те же элементы, что и оригинал.

**Подробнее**

`duplicate()` предоставляет явный способ получить копию списка. Он эквивалентен семантике конструктора копирования, но может быть более понятен при использовании в цепочках вызовов:

```cpp
List copy = original.duplicate().reverse();
```

**Пример**

```cpp
List original(1, 2, 3);
List copy = original.duplicate();
// copy изначально содержит [1, 2, 3]
```

*Этот пример дублирует список для работы с отдельной копией.*

---

#### `template <typename T> int find(T value) const`

**Сигнатура**

```cpp
template <typename T> int find(T value) const;
```

**Краткое описание**
Возвращает индекс первого вхождения value, или -1.

**Параметры**

* `value` – значение для поиска. Тип должен быть сравним с хранимыми элементами.

**Возвращаемое значение**

* Индекс первого совпадающего элемента, или `-1`, если не найдено.

**Подробнее**

`find()` сканирует список с начала и ищет элемент, равный `value`. Сравнение основано на тип-специфичном сравнении, реализованном внутри списка. Для согласованных результатов:

* Передавайте `value` того же типа, что и ожидаемые элементы.
* Избегайте поиска сложных вложенных контейнеров, если вы не уверены, как они сравниваются.

**Пример**

```cpp
List values("apple", "banana", "apple");
int firstApple = values.find("apple");  // 0
int missing = values.find("pear");      // -1
```

*Этот пример находит первое вхождение строки в списке.*

---

#### `template <typename T> bool contains(T value) const`

**Сигнатура**

```cpp
template <typename T> bool contains(T value) const;
```

**Краткое описание**
Возвращает true, если список содержит значение.

**Параметры**

* `value` – значение для поиска.

**Возвращаемое значение**

* `true`, если `find(value)` возвращает неотрицательный индекс; иначе `false`.

**Подробнее**

`contains()` — это удобная обёртка вокруг `find()`, возвращающая булево значение. Идеально подходит для быстрых проверок принадлежности.

**Пример**

```cpp
List values(1, 2, 3);
bool hasTwo = values.contains(2);  // true
bool hasFive = values.contains(5); // false
```

*Этот пример проверяет наличие определённых значений в списке.*

---

#### `String toCSVString() const`

**Сигнатура**

```cpp
String toCSVString() const;
```

**Краткое описание**
Преобразует список списков в CSV-строку.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая CSV-представление списка.

**Подробнее**

`toCSVString()` ожидает, что текущий список представляет собой **строки** таблицы, где каждый элемент сам по себе является `List`, представляющим столбцы в этой строке:

* Каждый вложенный список соответствует одной строке CSV.
* Элементы внутреннего списка становятся значениями ячеек этой строки.

Функция обрабатывает типичные требования CSV, такие как разделение значений запятыми и завершение строк переносами строки. Точные правила кавычек и экранирования зависят от реализации.

**Пример**

```cpp
List row1("Alice", 30);
List row2("Bob", 25);

List table;
table.append(row1).append(row2);

String csv = table.toCSVString();
// csv может быть:
// Alice,30
// Bob,25
```

*Этот пример преобразует таблицу, представленную как список списков, в простую CSV-строку.*

---

#### `static List FromCSVString(const String &csv)`

**Сигнатура**

```cpp
static List FromCSVString(const String &csv);
```

**Краткое описание**
Создаёт список списков из CSV-строки.

**Параметры**

* `csv` – текст в формате CSV для парсинга.

**Возвращаемое значение**

* `List`, где каждый элемент — внутренний `List`, представляющий одну строку, а каждый внутренний элемент — значение ячейки (обычно `String`).

**Подробнее**

`FromCSVString()` — это обратная по смыслу функция к `toCSVString()`:

* Вход: CSV-текст, возможно с несколькими строками.
* Выход: список строк, каждая строка — список значений ячеек.

Она позволяет восстановить структурированные табличные данные из текстового CSV-контента.

**Пример**

```cpp
String csv("Alice,30\nBob,25\n");
List table = List::FromCSVString(csv);

// table[0] это ["Alice", "30"]
// table[1] это ["Bob", "25"]
```

*Этот пример парсит CSV-текст в представление список-из-списков.*

---

#### `String toJSONString() const`

**Сигнатура**

```cpp
String toJSONString() const;
```

**Краткое описание**
Преобразует этот список в JSON-строку массива.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая JSON-представление массива списка.

**Подробнее**

`toJSONString()` сериализует список в JSON-массив. Каждый элемент конвертируется в JSON согласно своему типу:

* Числа становятся JSON-числами.
* Булевы значения становятся `true`/`false`.
* Строки становятся заключёнными в кавычки JSON-строками с соответствующим экранированием.
* Вложенные `List`, `Map` и `Set` становятся вложенными массивами или объектами.

Полезно для логирования, конфигураций и взаимодействия с JSON-ориентированными API.

**Пример**

```cpp
List values;
values.append("Alice").append(30).append(true);

String json = values.toJSONString();
// например: ["Alice",30,true]
```

*Этот пример преобразует разнородный список в JSON-массив в виде строки.*

---

#### `static List FromJSONString(const String &json)`

**Сигнатура**

```cpp
static List FromJSONString(const String &json);
```

**Краткое описание**
Создаёт список из JSON-строки массива.

**Параметры**

* `json` – текст JSON-массива для парсинга.

**Возвращаемое значение**

* `List`, представляющий распарсенный JSON-массив.

**Подробнее**

`FromJSONString()` парсит JSON-строку массива и конструирует `List`, где:

* Каждый JSON-элемент становится соответствующим значением в списке.
* Вложенные JSON-массивы и объекты становятся значениями `List` и `Map` соответственно.

Если входной JSON не является валидным массивом, результирующий список может быть пустым или отражать состояние ошибки; при необходимости следует валидировать вход.

**Пример**

```cpp
String json("[\"Alice\",30,true]");
List values = List::FromJSONString(json);

// values[0] == "Alice"
// values[1] == "30" или целое 30 (зависит от представления реализации)
// values[2] == true
```

*Этот пример парсит JSON-массив в `List` для дальнейшей обработки.*

---

#### `bool compare(const List &other) const`

**Сигнатура**

```cpp
bool compare(const List &other) const;
```

**Краткое описание**
Возвращает true, если этот список равен другому списку.

**Параметры**

* `other` – список для сравнения.

**Возвращаемое значение**

* `true`, если оба списка имеют одинаковую длину и соответствующие элементы равны; иначе `false`.

**Подробнее**

`compare()` выполняет послементное сравнение:

* Сначала сравнивает длины.
* Затем сравнивает каждый элемент (включая тип и значение).

По сути эквивалентно `operator==` и является именованной альтернативой для кода, предпочитающего явные методы.

**Пример**

```cpp
List a(1, 2, 3);
List b(1, 2, 3);
List c(1, 2);

bool ab = a.compare(b);  // true
bool ac = a.compare(c);  // false
```

*Этот пример сравнивает два списка на равенство с помощью `compare()`.*

---

#### `bool operator==(const List &other) const`

**Сигнатура**

```cpp
bool operator==(const List &other) const;
```

**Краткое описание**
Возвращает true, если этот список равен другому списку.

**Параметры**

* `other` – список для сравнения.

**Возвращаемое значение**

* `true`, если списки равны; иначе `false`.

**Подробнее**

Этот оператор — идиоматический способ проверить равенство списков с помощью `==`. Он делегирует той же логике, что и `compare()`, сравнивая длины и элементы.

**Пример**

```cpp
List a(1, 2, 3);
List b(1, 2, 3);
List c(3, 2, 1);

bool sameOrder = (a == b); // true
bool diffOrder = (a == c); // false
```

*Этот пример показывает тесты на равенство с учётом и порядка, и значений.*

---

#### `bool operator!=(const List &other) const`

**Сигнатура**

```cpp
bool operator!=(const List &other) const;
```

**Краткое описание**
Возвращает true, если этот список не равен другому списку.

**Параметры**

* `other` – список для сравнения.

**Возвращаемое значение**

* `true`, если списки не равны; `false`, если они равны.

**Подробнее**

Это просто логическое отрицание `operator==`.

**Пример**

```cpp
List a(1, 2, 3);
List b(1, 2);

if (a != b) {
  // списки отличаются по длине или содержимому
}
```

*Этот пример использует оператор неравенства для обнаружения различий.*

---

#### `template <typename T> List operator+(T value) const`

**Сигнатура**

```cpp
template <typename T> List operator+(T value) const {
  List result = duplicate();
  result.append(value);
  return result;
}
```

**Краткое описание**
Возвращает новый список с добавленным значением.

**Параметры**

* `value` – значение, которое будет добавлено к копии текущего списка.

**Возвращаемое значение**

* Новый `List`, содержащий все оригинальные элементы и затем `value`.

**Подробнее**

Этот оператор предоставляет функциональный способ построения новых списков без изменения оригинала:

* Дублирует текущий список.
* Добавляет `value` к дубликату.
* Возвращает новый список.

Полезно, когда вы хотите сохранить исходный список и работать с расширенной версией.

**Пример**

```cpp
List base(1, 2);
List extended = base + 3;
// base по-прежнему содержит [1, 2]
// extended содержит [1, 2, 3]
```

*Этот пример использует оператор `+` для создания нового списка с дополнительным элементом, не изменяя исходный.*