# Subprocess

## Обзор

Класс `attoboy::Subprocess` предоставляет высокоуровневый RAII-интерфейс для запуска и взаимодействия с внешними программами (дочерними процессами) из вашего приложения attoboy. Он поддерживает:

* **Простые одноразовые помощники**:

  * `Start()` – запустить и забыть.
  * `Run()` – запустить и дождаться кода возврата.
  * `Capture()` – запустить и собрать объединённый `stdout + stderr` в `String`.
* **Потоковый ввод/вывод**:

  * Создайте объект `Subprocess` и используйте `write()` для отправки данных в стандартный ввод процесса.
  * Используйте `readToString()` или `readToBuffer()` для поэтапного чтения вывода.
  * Запрашивайте `isRunning()` и `hasAvailable()` для управления интерактивными или долгоживущими задачами.

`Subprocess` интегрируется с другими типами attoboy:

* `Path` – указывает исполняемый файл для запуска.
* `String` – для аргументов, ввода и текстового вывода.
* `Buffer` – для двоичного ввода и вывода.

### Процессы, стандартные потоки ввода/вывода и коды выхода

**Процесс** — это экземпляр программы, выполняющийся в операционной системе. Когда вы запускаете подпроцесс:

* У дочернего процесса обычно есть:

  * **Стандартный ввод (stdin)** – данные, которые ваша программа может ему отправлять.
  * **Стандартный вывод (stdout)** – данные, которые он отправляет обратно.
  * **Стандартная ошибка (stderr)** – сообщения об ошибках и диагностике.
* Процесс в конечном итоге **завершается** с **кодом выхода** (также известным как статус завершения или return code):

  * `0` обычно означает успех.
  * Ненулевой код часто указывает на ошибку или особое состояние.

`Subprocess` абстрагирует эти детали в простые методы:

* Код выхода через `Run()` или `wait()`.
* Объединённый вывод через `Capture()` или потоковые методы `read*`.
* Идентификатор процесса через `getProcessId()`.

### Одноразовый запуск (fire-and-forget) и потоковый ввод/вывод

Существуют два основных сценария использования:

1. **Одноразовый запуск / простые вызовы**  
   Используйте статические помощники, когда вам нужен только результат и не требуется потоковый ввод/вывод:

   * `Subprocess::Start(exe, args...)` – запустить и не ждать.
   * `Subprocess::Run(exe, args...)` – запустить и ждать; получить код выхода.
   * `Subprocess::Capture(exe, args...)` – запустить, ждать и получить полный вывод.

2. **Потоковый ввод/вывод (интерактивный)**  
   Используйте конструктор и методы экземпляра, когда нужно:

   * Читать вывод по частям.
   * Отправлять команды в процесс с течением времени.
   * Контролировать и мониторить долгоживущие задачи.

   В этом режиме объект `Subprocess` управляет дескриптором (handle) на базовый процесс. Дескриптор освобождается в деструкторе, но **сам процесс не завершается автоматически**; используйте `wait()` или `terminate()` для управления его жизненным циклом.

---

## Справочник

Ниже каждая запись документирует один публичный конструктор, статическую функцию или метод `attoboy::Subprocess`.

---

### Статические помощники

#### `template <typename... Args> static void Start(const Path &executable, const Args &...args)`

**Сигнатура**

```cpp
template <typename... Args>
static void Start(const Path &executable, const Args &...args) {
  Start_impl(executable, List(String(args)...));
}
```

**Краткое описание**
Запускает процесс без ожидания (fire and forget).

**Параметры**

* `executable` – `Path` к исполняемому файлу, который нужно запустить.
* `args` – Ноль или более аргументов командной строки. Каждый аргумент должен быть преобразуем в `String` (например, `const char *`, `String`, `int`, `bool`).

**Возвращаемое значение**

* *(нет; статическая функция с возвращаемым типом `void`)*

**Подробно**

`Start()` запускает процесс и возвращает управление немедленно, не предоставляя вам дескриптор на него. Это полезно, когда:

* Вы хотите запустить вспомогательный инструмент или фоновую задачу.
* Вам не нужно читать его вывод или ждать завершения.
* Код выхода и ввод/вывод процесса не важны для вашей логики.

Внутренне `args` конвертируются в значения `String` и собираются в `List`, который передаётся в приватную реализацию. Вызываемый процесс воспринимает их как обычные аргументы командной строки.

Поскольку `Subprocess` не возвращается, вы не сможете позднее вызвать `isRunning()` или завершить процесс. Используйте `Run()` или API на основе конструктора, если вам нужен такой контроль.

**Пример**

```cpp
Path exe("helper_tool.exe");

// Start the tool with two arguments and do not wait for it.
Subprocess::Start(exe, "--cleanup", "temp");
```

*Этот пример запускает фоновую вспомогательную программу для выполнения очистки и немедленно продолжает выполнение без ожидания её завершения.*

---

#### `template <typename... Args> static int Run(const Path &executable, const Args &...args)`

**Сигнатура**

```cpp
template <typename... Args>
static int Run(const Path &executable, const Args &...args) {
  return Run_impl(executable, List(String(args)...));
}
```

**Краткое описание**
Запускает процесс и ждёт его завершения. Возвращает код выхода.

**Параметры**

* `executable` – `Path` к исполняемому файлу, который нужно запустить.
* `args` – Ноль или более аргументов командной строки, каждый из которых преобразуем в `String`.

**Возвращаемое значение**

* Код выхода, возвращённый подпроцессом, или значение, определённое реализацией (обычно `-1`) при ошибке.

**Подробно**

`Run()` — самый простой способ выполнить внешнюю программу, когда вас интересует только её **код выхода**, а не вывод. Функция:

1. Запускает процесс с указанным `executable` и аргументами.
2. Синхронно ждёт, пока процесс не завершится.
3. Возвращает код выхода.

Поскольку вызов блокирует выполнение, используйте его для краткоживущих задач или когда вы готовы ждать. Для долгих задач, где нужны обновления по прогрессу или отзывчивый UI, предпочитайте потоковый экземпляр `Subprocess`.

**Пример**

```cpp
Path exe("validator.exe");

// Run the validator with a file path and check the exit code.
int exitCode = Subprocess::Run(exe, "config.json");

if (exitCode == 0) {
  // Validation succeeded.
} else {
  // Handle validation error.
}
```

*Этот пример синхронно запускает валидатор и выполняет ветвление в зависимости от кода выхода.*

---

#### `template <typename... Args> static String Capture(const Path &executable, const Args &...args)`

**Сигнатура**

```cpp
template <typename... Args>
static String Capture(const Path &executable, const Args &...args) {
  return Capture_impl(executable, List(String(args)...));
}
```

**Краткое описание**
Запускает процесс и захватывает stdout+stderr. Возвращает вывод в виде строки.

**Параметры**

* `executable` – `Path` к исполняемому файлу, который нужно запустить.
* `args` – Ноль или более аргументов командной строки, каждый из которых преобразуем в `String`.

**Возвращаемое значение**

* `String`, содержащая объединённый стандартный вывод и стандартную ошибку подпроцесса.
* Обычно пустая при ошибке или если процесс не произвёл вывода.

**Подробно**

`Capture()` — удобный метод для сценариев «запустить и собрать вывод»:

* Запускает процесс.
* Захватывает всё, что записано в `stdout` и `stderr`.
* Ждёт завершения процесса.
* Возвращает захваченный текст как единый `String`.

Это идеально для инструментов, которые:

* Печатают человекопонятные сообщения.
* Генерируют машинно-читаемый вывод (JSON, CSV), который вы хотите распарсить.

Если вам также нужен код выхода, возможно, придётся сделать так, чтобы ваш инструмент сообщал статус через вывод, или запустить его дважды с помощью `Run()` и `Capture()` (если уместно). Для тонкого контроля потокового ввода/вывода используйте API на основе конструктора.

**Пример**

```cpp
Path exe("tool.exe");

// Run the tool and capture all text output.
String output = Subprocess::Capture(exe, "--list", "--json");

// You can now parse or log 'output' as needed.
```

*Этот пример запускает инструмент, который выводит список в формате JSON, и собирает его вывод в `String`.*

---

#### `template <typename... Args> Subprocess(const Path &executable, const Args &...args)`

**Сигнатура**

```cpp
template <typename... Args>
Subprocess(const Path &executable, const Args &...args)
    : Subprocess(executable, List(String(args)...)) {}
```

**Краткое описание**
Создаёт подпроцесс с поддержкой потокового ввода/вывода.

**Параметры**

* `executable` – `Path` к исполняемому файлу, который нужно запустить.
* `args` – Ноль или более аргументов командной строки, каждый из которых преобразуем в `String`.

**Возвращаемое значение**

* *(конструктор; не применимо)*

**Подробно**

Этот конструктор запускает новый процесс и создаёт объект `Subprocess`, который управляет дескриптором на него. В отличие от `Start()`, вы сохраняете контроль над:

* Валидностью процесса (`isValid()`).
* Тем, запущен ли он ещё (`isRunning()`).
* Моментом ожидания завершения (`wait()`).
* Способами чтения и записи потоков ввода/вывода (`readToString()`, `readToBuffer()`, `write()`).
* Когда (и следует ли) завершать его (`terminate()`).

Внутри аргументы конвертируются в `String` и передаются в `List` приватному конструктору. Созданный объект `Subprocess` можно копировать и присваивать; копии разделяют один и тот же базовый дескриптор процесса.

После создания `Subprocess` обычно следует проверить `isValid()` перед использованием.

**Пример**

```cpp
Path exe("interactive_tool.exe");

// Start an interactive subprocess with one argument.
Subprocess proc(exe, "--interactive");

if (proc.isValid()) {
  // Ready to communicate using write() and readToString().
}
```

*Этот пример запускает интерактивный инструмент и проверяет, что он успешно создан, прежде чем продолжить.*

---

#### `Subprocess(const Subprocess &other)`

**Сигнатура**

```cpp
Subprocess(const Subprocess &other);
```

**Краткое описание**
Создаёт копию (делится базовым процессом).

**Параметры**

* `other` – Существующий `Subprocess`, дескриптор которого следует разделить.

**Возвращаемое значение**

* *(конструктор; не применимо)*

**Подробно**

Конструктор копирования **не** запускает новый процесс ОС. Вместо этого он создаёт ещё один объект `Subprocess`, который ссылается на тот же подпроцесс:

* Оба экземпляра видят одно и то же состояние `isRunning()`.
* Любой из них может вызвать `wait()`, `terminate()`, `write()` или `read*()`.
* Владение разделено; дескриптор очищается только когда уничтожены все ссылки.

Это упрощает передачу `Subprocess` между функциями без риска двойного запуска процесса.

**Пример**

```cpp
Path exe("server.exe");
Subprocess server(exe, "--mode", "child");

Subprocess shared(server);  // shares the same underlying process

// Both 'server' and 'shared' can interact with the same subprocess.
```

*Этот пример копирует дескриптор `Subprocess`, чтобы несколько частей кода могли взаимодействовать с одним и тем же дочерним процессом.*

---

#### `~Subprocess()`

**Сигнатура**

```cpp
~Subprocess();
```

**Краткое описание**
Уничтожает дескриптор (не завершает процесс).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; не применимо)*

**Подробно**

Деструктор освобождает базовый дескриптор процесса, принадлежащий этому объекту `Subprocess`. Важно:

* Он **не** завершает подпроцесс.
* Если есть другие копии `Subprocess`, ссылающиеся на тот же дескриптор, процесс продолжит управляться ими.
* Процесс ОС в конечном итоге завершится сам по себе, если вы явно не вызовете `terminate()`.

Вы должны вызвать `wait()` или `terminate()`, если нужно гарантировать, что процесс завершился до выхода объектов `Subprocess` из области видимости.

**Пример**

```cpp
{
  Path exe("worker.exe");
  Subprocess worker(exe);

  // Optionally wait or terminate here.
  // worker.wait();
} // 'worker' handle is released; the OS process may still be running.
```

*Этот пример показывает, как `Subprocess` выходит из области видимости; уничтожается только дескриптор, а не сам подпроцесс.*

---

#### `Subprocess &operator=(const Subprocess &other)`

**Сигнатура**

```cpp
Subprocess &operator=(const Subprocess &other);
```

**Краткое описание**
Присваивает другой `Subprocess` (делится базовым процессом).

**Параметры**

* `other` – `Subprocess`, от которого выполняется присваивание.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочку присваиваний.

**Подробно**

Оператор присваивания заставляет левый операнд ссылаться на тот же базовый процесс, что и `other`. Предыдущий дескриптор (если был) освобождается:

* Новый процесс не создаётся.
* Теперь и `*this`, и `other` разделяют один и тот же дескриптор подпроцесса.
* Самоприсваивание безопасно.

Используйте это, когда нужно переназначить переменную `Subprocess`, чтобы она ссылалась на новый или другой процесс.

**Пример**

```cpp
Path exe("task.exe");

Subprocess a(exe, "one");
Subprocess b(exe, "two");

// Now 'a' and 'b' initially refer to different processes.
a = b;  // 'a' now refers to the same process as 'b'
```

*Этот пример переназначает один `Subprocess`, чтобы он разделял дескриптор другого.*

---

#### `bool isValid() const`

**Сигнатура**

```cpp
bool isValid() const;
```

**Краткое описание**
Возвращает true, если процесс был создан успешно.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если базовый дескриптор процесса действителен; `false`, если создание не удалось или дескриптор недействителен.

**Подробно**

`isValid()` проверяет, успешно ли объект `Subprocess` создал (или получил) дескриптор подпроцесса. Частые причины неудачи:

* Путь к исполняемому файлу не существует.
* Ошибки прав доступа.
* Ограничения ресурсов ОС.

Обычно следует вызывать `isValid()` после создания или присваивания `Subprocess`, прежде чем пытаться выполнять ввод/вывод или операции жизненного цикла.

**Пример**

```cpp
Path exe("maybe_missing.exe");
Subprocess proc(exe);

if (!proc.isValid()) {
  // Handle error: executable may not exist or could not be launched.
}
```

*Этот пример проверяет, успешно ли создан подпроцесс, прежде чем продолжить.*

---

#### `bool isRunning() const`

**Сигнатура**

```cpp
bool isRunning() const;
```

**Краткое описание**
Возвращает true, если процесс всё ещё выполняется.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если подпроцесс ещё не завершился; `false`, если он уже завершился или никогда не был валиден.

**Подробно**

`isRunning()` позволяет наблюдать текущее состояние подпроцесса без блокировки:

* Для валидного, активного процесса возвращает `true`.
* После завершения процесса (нормального или через `terminate()`), возвращает `false`.

Комбинируйте это с `hasAvailable()` и методами ввода/вывода для реализации отзывчивого цикла, который читает вывод и обнаруживает завершение.

**Пример**

```cpp
Path exe("long_task.exe");
Subprocess proc(exe);

while (proc.isRunning()) {
  // Poll for output, update UI, etc.
}
```

*Этот пример периодически проверяет, активен ли долгоживущий подпроцесс.*

---

#### `int wait()`

**Сигнатура**

```cpp
int wait();
```

**Краткое описание**
Ожидает завершения и возвращает код выхода (`-1` при ошибке).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Код выхода подпроцесса при успешном завершении.
* `-1` (или другой код ошибки, определённый реализацией), если ожидание не удалось или процесс недействителен.

**Подробно**

`wait()` блокирует выполнение до завершения подпроцесса. После возврата `wait()`:

* `isRunning()` вернёт `false`.
* Вы всё ещё можете вызвать `readToString()` или `readToBuffer()` для чтения оставшегося буферизованного вывода, если это поддерживается.
* Повторные вызовы `wait()` обычно являются no-op после первого вызова или возвращают кэшированный код выхода; поведение зависит от реализации, поэтому лучше вызывать его один раз.

Используйте `wait()`, когда у вас потоковый `Subprocess` и вы хотите:

* Отправить одну или несколько команд через `write()`.
* Читать текущий вывод.
* В конце заблокироваться до завершения и получить код выхода.

**Пример**

```cpp
Path exe("job.exe");
Subprocess proc(exe, "--mode", "batch");

if (proc.isValid()) {
  int exitCode = proc.wait();
  // Examine exitCode to determine success or failure.
}
```

*Этот пример запускает пакетную задачу и блокируется до её завершения, затем анализирует код выхода.*

---

#### `bool terminate()`

**Сигнатура**

```cpp
bool terminate();
```

**Краткое описание**
Принудительно завершает процесс. Возвращает true при успехе.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если запрос на завершение успешно выполнен; `false`, если он не удался или процесс недействителен.

**Подробно**

`terminate()` пытается принудительно остановить подпроцесс. Это сильная операция:

* У дочернего процесса может не быть возможности корректно очистить ресурсы (сбросить файлы, сохранить состояние и т.д.).
* Используйте её только когда подпроцесс ведёт себя некорректно (завис, застрял или игнорирует вежливые сигналы).

После успешного вызова `terminate()`:

* `isRunning()` в итоге вернёт `false`.
* Если нужно убедиться в полном завершении процесса, можно вызвать `wait()`.

**Пример**

```cpp
Path exe("worker.exe");
Subprocess proc(exe);

if (proc.isValid()) {
  // ... some time passes, and we decide to stop the worker ...
  bool ok = proc.terminate();
  // Optionally call proc.wait() to ensure it has fully exited.
}
```

*Этот пример принудительно завершает рабочий подпроцесс, когда он больше не нужен или ведёт себя некорректно.*

---

#### `int getProcessId() const`

**Сигнатура**

```cpp
int getProcessId() const;
```

**Краткое описание**
Возвращает идентификатор процесса (PID) (`-1` при ошибке).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Идентификатор процесса ОС (PID) подпроцесса.
* `-1`, если процесс недействителен или идентификатор не может быть получен.

**Подробно**

PID однозначно идентифицирует подпроцесс на уровне операционной системы. Вы можете использовать его для:

* Логирования или отладки.
* Внешних инструментов, которые отслеживают процессы по идентификатору.

Обратите внимание, что PID может быть повторно использован ОС после завершения процесса, поэтому он имеет смысл только пока процесс жив.

**Пример**

```cpp
Path exe("worker.exe");
Subprocess proc(exe);

if (proc.isValid()) {
  int pid = proc.getProcessId();
  // You can log 'pid' or use it in external monitoring tools.
}
```

*Этот пример получает и записывает идентификатор процесса рабочего подпроцесса.*

---

#### `bool hasAvailable() const`

**Сигнатура**

```cpp
bool hasAvailable() const;
```

**Краткое описание**
Возвращает true, если доступны данные для чтения.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если есть готовые к чтению данные вывода; `false` в противном случае.

**Подробно**

`hasAvailable()` проверяет, есть ли в данный момент данные в выходных потоках подпроцесса. Он предназначен для использования перед вызовом:

* `readToBuffer()`
* `readToString()`

Типичный шаблон — избегать блокировки, проверяя `hasAvailable()` в цикле и читать только когда он возвращает `true`. Это позволяет оставаться отзывчивым и одновременно быстро реагировать на вывод.

**Пример**

```cpp
Path exe("chatty.exe");
Subprocess proc(exe);

while (proc.isRunning() || proc.hasAvailable()) {
  if (proc.hasAvailable()) {
    String chunk = proc.readToString();
    // Process 'chunk' (log it, parse it, etc.).
  }
  // Perform other work here if needed.
}
```

*Этот пример опрашивает доступный вывод, пока подпроцесс работает, и читает текстовые фрагменты по мере их появления.*

---

#### `Buffer readToBuffer()`

**Сигнатура**

```cpp
Buffer readToBuffer();
```

**Краткое описание**
Читает доступный вывод в буфер.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `Buffer`, содержащий байты, прочитанные из вывода подпроцесса. Может быть пустым, если данных нет или произошла ошибка.

**Подробно**

`readToBuffer()` читает вывод подпроцесса и возвращает его в виде `Buffer`, пригодного для двоичных данных:

* Используйте это, когда подпроцесс выдаёт не текст (например, фреймы протокола, сжатые данные).
* Комбинируйте с `hasAvailable()`, чтобы избежать блокировки до появления данных.

Если вы работаете с текстовым выводом, обычно удобнее использовать `readToString()`.

**Пример**

```cpp
Path exe("binary_emitter.exe");
Subprocess proc(exe);

if (proc.isValid()) {
  if (proc.hasAvailable()) {
    Buffer data = proc.readToBuffer();
    // Handle raw binary data in 'data'.
  }
}
```

*Этот пример читает двоичный вывод подпроцесса в `Buffer`.*

---

#### `String readToString()`

**Сигнатура**

```cpp
String readToString();
```

**Краткое описание**
Читает доступный вывод в строку.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `String`, содержащая текст, прочитанный из вывода подпроцесса. Может быть пустой, если данных нет или произошла ошибка.

**Подробно**

`readToString()` — текстовый аналог `readToBuffer()`:

* Читает доступный вывод и декодирует его как UTF-8 в `String`.
* Можно вызывать несколько раз по мере появления нового вывода.
* Комбинируйте с `hasAvailable()` и `isRunning()` в цикле, чтобы собирать полный вывод по частям.

Если вам нужен весь вывод одним махом и потоковая обработка не важна, `Capture()` часто проще.

**Пример**

```cpp
Path exe("script.exe");
Subprocess proc(exe);

String allOutput;

while (proc.isRunning() || proc.hasAvailable()) {
  if (proc.hasAvailable()) {
    String chunk = proc.readToString();
    allOutput = allOutput + chunk;
  }
}

 // 'allOutput' now contains all text produced by the script.
```

*В этом примере текстовый вывод скрипта постепенно считывается до завершения и накапливается в переменной `allOutput`.*

---

#### `int write(const Buffer &buf)`

**Сигнатура**

```cpp
int write(const Buffer &buf);
```

**Краткое описание**
Записывает буфер в stdin. Возвращает число записанных байт или `-1` при ошибке.

**Параметры**

* `buf` – `Buffer`, содержащий байты для отправки в стандартный ввод подпроцесса.

**Возвращаемое значение**

* Количество успешно записанных байт.
* `-1` при ошибке (недействительный процесс, закрытый канал или другая ошибка ввода/вывода).

**Подробно**

`write(const Buffer &)` отправляет двоичные данные в стандартный ввод подпроцесса:

* Используйте это, когда дочерний процесс ожидает двоичный протокол или нетекстовые команды.
* Учтите, что не все программы читают из стандартного ввода; данные могут быть проигнорированы, если дочерний процесс не предназначен для их потребления.
* После того, как подпроцесс завершился или закрыл ввод, последующие вызовы `write()` обычно будут завершаться с ошибкой и возвращать `-1`.

Возможно, вам придётся спроектировать дочернюю программу так, чтобы она корректно интерпретировала эти байты.

**Пример**

```cpp
Path exe("binary_consumer.exe");
Subprocess proc(exe);

if (proc.isValid()) {
  Buffer payload;
  // ... fill 'payload' with data ...

  int written = proc.write(payload);
  // Check 'written' for success or partial writes.
}
```

*Этот пример отправляет двоичные данные подпроцессу через его стандартный ввод.*

---

#### `int write(const String &str)`

**Сигнатура**

```cpp
int write(const String &str);
```

**Краткое описание**
Записывает строку в stdin. Возвращает число записанных байт или `-1` при ошибке.

**Параметры**

* `str` – `String`, содержащая UTF-8 текст для отправки в стандартный ввод подпроцесса.

**Возвращаемое значение**

* Количество успешно записанных байт.
* `-1` при ошибке.

**Подробно**

`write(const String &)` — наиболее удобный способ отправить текстовые команды или ввод в интерактивный подпроцесс:

* Текст записывается как UTF-8 байты.
* Многие командные утилиты рассматривают символ новой строки (`"\n"`) как «конец команды», поэтому часто включают перенос строки при отправке команд.
* После завершения процесса или закрытия потока ввода последующие записи завершатся ошибкой.

Используйте этот метод вместе с `readToString()` и `isRunning()` для реализации шаблонов запрос‑ответ.

**Пример**

```cpp
Path exe("interactive_tool.exe");
Subprocess proc(exe, "--interactive");

if (proc.isValid()) {
  // Send a command, followed by a newline so the tool can parse it.
  proc.write(String("status\n"));

  // Later, read the response.
  if (proc.hasAvailable()) {
    String response = proc.readToString();
    // Process 'response' as needed.
  }
}
```

*Этот пример отправляет команду в интерактивный инструмент и затем считывает ответ.*