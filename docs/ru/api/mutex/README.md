# Mutex

## Обзор

Класс `attoboy::Mutex` предоставляет простой низкоуровневый примитив синхронизации для координации доступа к общим данным между потоками. Это естественный компаньон для `attoboy::Thread`:

* `Thread` создаёт и запускает конкурентные рабочие потоки.
* `Mutex` обеспечивает, что в каждый момент времени только один поток может получить доступ к определённым критическим секциям кода или общим ресурсам.

Оборачивая мьютекс операционной системы (OS), `Mutex` предлагает:

* Компактный интерфейс без зависимостей (без стандартной библиотеки C++).
* Возможность совместного использования дескриптора между разными частями программы.
* Базовые операции: блокировка, разблокировка и неблокирующая попытка блокировки.

### Что такое мьютекс?

Мьютекс (mutual exclusion lock) — это объект синхронизации, который позволяет «владеть» им только одному потоку одновременно. Концептуально:

* Когда поток вызывает `lock()`:

  * Если мьютекс **разблокирован**, он становится заблокированным и поток продолжает выполнение.
  * Если мьютекс **уже заблокирован** другим потоком, вызывающий поток **блокируется** (ожидает), пока мьютекс не будет разблокирован.
* Когда поток-владелец вызывает `unlock()`, другой ожидающий поток (если он есть) может захватить блокировку.

Обычно мьютекс используется, когда у вас есть **общие данные**, которые могут читаться или изменяться несколькими потоками:

* Общие счётчики или статистика.
* Общие буферы или очереди.
* Общая конфигурация или кэши.

Без мьютекса (или другого механизма синхронизации) одновременный доступ может привести к:

* **Гонкам данных** — два потока записывают или читают данные одновременно с записью другим потоком, что приводит к неопределённому поведению.
* **Несогласованному состоянию** — частичные обновления видны другим потокам.
* **Трудно-воспроизводимым ошибкам** — ошибки, которые появляются только под нагрузкой и непостоянно.

### Дескрипторы мьютекса и совместное использование

Как и в случае с `Thread`, класс `Mutex` разделяет:

* Нативный объект синхронизации уровня ОС.
* Лёгкий дескриптор (`Mutex` объект), который вы держите в коде.

Важные свойства:

* **Конструктор по умолчанию** создаёт новый мьютекс.
* **Конструктор копирования** и **оператор присваивания** создают **дескрипторы, которые разделяют один и тот же базовый мьютекс**.

Это означает, что вы можете:

* Передавать объекты `Mutex` по значению.
* Хранить их в других структурах.
* Использовать любую копию как исходный объект; все они ссылаются на одну и ту же блокировку.

### Дисциплина блокировок и лучшие практики

Поскольку `Mutex` — это низкоуровневый примитив, вы несёте ответственность за:

* Вызов `lock()` перед входом в критическую секцию.
* Вызов `unlock()` во всех путях выполнения, покидающих эту критическую секцию (включая ранние выходы и обработку ошибок).
* Избежание дедлоков путём последовательного захвата нескольких мьютексов в одном и том же порядке, если вы используете более одного.

Предполагается, что мьютекс не является рекурсивным (reentrant). То есть:

* Если поток вызывает `lock()` дважды подряд на одном и том же мьютексе без вызова `unlock()` между ними, это может привести к дедлоку.

Распространённый паттерн:

```cpp
mutex.lock();
// критическая секция: доступ к разделяемым данным
mutex.unlock();
```

В более сложной логике вы должны быть уверены, что каждый вызов `lock()` соответствует соответствующему `unlock()` даже в случае ошибок.

---

## Справочник

Ниже каждая запись охватывает один публичный конструктор, метод или оператор `attoboy::Mutex`. Для каждого элемента вы найдёте:

* **Сигнатура** – точное объявление из заголовочного файла.
* **Краткое описание** – исходный однострочный комментарий Doxygen.
* Описания **параметров** и **возвращаемого значения**.
* **Подробнее** – дополнительные сведения, оговорки и небольшой пример.

> Примечание: Все примеры предполагают `using namespace attoboy;`.

---

#### `Mutex()`

**Сигнатура**

```cpp
Mutex();
```

**Краткое описание**
Создаёт мьютекс.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Конструктор по умолчанию инициализирует новый мьютекс, который изначально находится в состоянии **разблокирован**. После создания:

* Мьютекс можно безопасно передавать другим потокам (например, через указатели или ссылки).
* Любой поток может вызывать `lock()`, `unlock()` или `tryLock()` на нём.

Обычно вы создаёте один мьютекс для каждого общего ресурса или группы связанных ресурсов, которые должны быть защищены вместе.

**Пример**

```cpp
Mutex m;  // только что создан, изначально разблокирован
```

*Этот пример создаёт мьютекс, который можно использовать для защиты общих данных между потоками.*

---

#### `Mutex(const Mutex &other)`

**Сигнатура**

```cpp
Mutex(const Mutex &other);
```

**Краткое описание**
Создаёт копию (разделяет базовый мьютекс).

**Параметры**

* `other` – существующий дескриптор `Mutex` для копирования.

**Возвращаемое значение**

* *(конструктор; неприменимо)*

**Подробнее**

Конструктор копирования **не** создаёт новый мьютекс уровня ОС. Вместо этого он создаёт ещё один дескриптор, который **разделяет тот же базовый мьютекс**, что и `other`.

Это означает:

* Блокировка или разблокировка через любой дескриптор влияет на один и тот же мьютекс.
* Вы можете безопасно хранить и передавать объекты `Mutex` без опасений случайного создания отдельных, несвязанных блокировок.

Это полезно, когда:

* Вы хотите вложить мьютекс в другой объект по значению.
* Вы хотите предоставить нескольким компонентам доступ к одному и тому же мьютексу без явного совместного использования указателей.

**Пример**

```cpp
Mutex globalMutex;

void useCopy() {
  Mutex localCopy(globalMutex);  // разделяет тот же базовый мьютекс
  localCopy.lock();
  // защищённая секция
  localCopy.unlock();
}
```

*Этот пример показывает копирование дескриптора мьютекса и использование копии для защиты критической секции; оба дескриптора ссылаются на один и тот же базовый мьютекс.*

---

#### `~Mutex()`

**Сигнатура**

```cpp
~Mutex();
```

**Краткое описание**
Разрушает дескриптор мьютекса.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(деструктор; неприменимо)*

**Подробнее**

Деструктор освобождает ресурсы, связанные с **дескриптором**. Точная семантика в отношении базового мьютекса зависит от количества дескрипторов, которые на него ссылаются, но во всех случаях:

* Вы должны убедиться, что мьютекс **не заблокирован** ни одним потоком в момент логического «удаления» дескриптора.
* Разрушение дескриптора, в то время как другой поток удерживает блокировку или ожидает её, приводит к неопределённому поведению.

Хорошее практическое правило:

* Убедитесь, что все потоки, использующие мьютекс, завершили работу (или больше не будут вызывать `lock()`/`unlock()`), прежде чем последний дескриптор будет уничтожен.

**Пример**

```cpp
void useMutex() {
  Mutex m;
  m.lock();
  // критическая секция
  m.unlock();
} // m разрушается здесь; мьютекс не должен использоваться после этого
```

*Этот пример создаёт мьютекс в локальной области видимости, использует его для защиты участка кода и затем разрушает при выходе из области видимости.*

---

#### `Mutex &operator=(const Mutex &other)`

**Сигнатура**

```cpp
Mutex &operator=(const Mutex &other);
```

**Краткое описание**
Присваивает другой мьютекс (разделяет базовый мьютекс).

**Параметры**

* `other` – существующий дескриптор `Mutex`, от которого выполняется присваивание.

**Возвращаемое значение**

* Ссылка на `*this`, что позволяет цепочку присваиваний.

**Подробнее**

Оператор присваивания копированием делает так, что `*this` ссылается на **тот же базовый мьютекс**, что и `other`. Любая предыдущая ассоциация `*this` с другим мьютексом освобождается.

После присваивания:

* Блокировка и разблокировка через `*this` влияет на тот же мьютекс, что и операции через `other`.
* Новый мьютекс уровня ОС не создаётся.

Используйте это, когда хотите перенаправить существующий дескриптор для защиты другого общего ресурса или при настройке структур, содержащих члены `Mutex`.

**Пример**

```cpp
Mutex a;
Mutex b;

// Позже решили, что b должен использовать тот же мьютекс, что и a:
b = a;  // b теперь разделяет базовый мьютекс a
```

*Этот пример присваивает один дескриптор мьютекса другому, чтобы они оба ссылались на один и тот же базовый мьютекс.*

---

#### `void lock()`

**Сигнатура**

```cpp
void lock();
```

**Краткое описание**
Блокирует мьютекс, блокируясь до тех пор, пока он не станет доступен.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(нет)*

**Подробнее**

`lock()` — основной способ войти в **критическую секцию**:

* Если мьютекс в данный момент разблокирован, `lock()` немедленно блокирует его и возвращает управление.
* Если другой поток уже держит блокировку, `lock()` **блокирует** вызывающий поток до тех пор, пока мьютекс не станет доступен.

После успешного вызова `lock()` поток отвечает за вызов `unlock()` при выходе из критической секции. Несоблюдение этого приведёт к:

* Постоянной блокировке мьютекса.
* Блокировке или постоянному провалу других потоков, вызывающих `lock()` или `tryLock()`.

Следует избегать двойного вызова `lock()` подряд на одном и том же мьютексе из одного потока без промежуточного `unlock()`; это может привести к дедлоку, если мьютекс не рекурсивный.

**Пример**

```cpp
Mutex m;
int sharedCounter = 0;

// Worker function that increments a shared counter safely
void *worker(void *arg) {
  for (int i = 0; i < 1000; ++i) {
    m.lock();
    sharedCounter += 1;  // критическая секция
    m.unlock();
  }
  return nullptr;
}

// Usage:
Thread t1(&worker, nullptr);
Thread t2(&worker, nullptr);
```

*Этот пример использует `lock()` для защиты увеличения общего счётчика от одновременного доступа двумя рабочими потоками.*

---

#### `void unlock()`

**Сигнатура**

```cpp
void unlock();
```

**Краткое описание**
Разблокирует мьютекс.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(нет)*

**Подробнее**

`unlock()` освобождает владение мьютексом:

* Он должен вызываться потоком, который ранее захватил мьютекс с помощью `lock()` или `tryLock()`.
* После `unlock()` другие потоки, ожидающие в `lock()`, могут продолжить работу, а `tryLock()` может успешно захватить мьютекс.

Вызов `unlock()` на мьютексе, который не захвачен текущим потоком, приводит к неопределённому поведению. Всегда структурируйте код так, чтобы каждый `lock()` сопровождался `unlock()` во всех возможных путях управления.

Распространённый паттерн:

```cpp
m.lock();
// критическая секция
m.unlock();
```

В реальных программах необходимо также обрабатывать ранние возвраты и ошибки:

```cpp
m.lock();
// ...
if (someError) {
  m.unlock();
  return;  // убедитесь, что unlock вызывается перед выходом
}
// ...
m.unlock();
```

**Пример**

```cpp
Mutex m;
int sharedValue = 0;

void *worker(void *arg) {
  m.lock();
  sharedValue = 42;  // критическая секция: запись в разделяемые данные
  m.unlock();
  return nullptr;
}
```

*Этот пример блокирует мьютекс перед обновлением общего состояния и затем разблокирует его, чтобы позволить другим потокам продолжить работу.*

---

#### `bool tryLock()`

**Сигнатура**

```cpp
bool tryLock();
```

**Краткое описание**
Пытается захватить мьютекс без блокировки. Возвращает true, если удалось.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true`, если мьютекс был успешно захвачен вызывающим потоком.
* `false`, если мьютекс уже был захвачен другим потоком и не мог быть немедленно получен.

**Подробнее**

`tryLock()` — это **неблокирующая** альтернатива `lock()`:

* Если мьютекс свободен, он захватывается и возвращается `true`.
* Если мьютекс уже захвачен, функция немедленно возвращает `false`, не блокируя поток.

Это полезно в сценариях, когда:

* Вы хотите выполнить работу «по возможности», не ожидая.
* Вы строите поведение, похожее на lock-free, с запасным планом.
* Вы хотите избегать потенциальных дедлоков, отступая, когда блокировка недоступна.

Если `tryLock()` возвращает `true`, вы **обязаны** в итоге вызвать `unlock()` из того же потока, чтобы освободить мьютекс.

**Пример**

```cpp
Mutex m;
int sharedCounter = 0;

void *worker(void *arg) {
  // Попытка обновить общий счётчик без блокировки
  if (m.tryLock()) {
    sharedCounter += 1;  // критическая секция
    m.unlock();
  } else {
    // Не удалось немедленно получить мьютекс; пропустить или выполнить альтернативную работу
  }
  return nullptr;
}
```

*Этот пример пытается обновить общий счётчик только в том случае, если мьютекс можно получить без блокировки; в противном случае он пропускает обновление или выполняет альтернативную работу.*