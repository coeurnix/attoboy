# Math

## Обзор

Класс `attoboy::Math` — это компактный набор **статических математических утилит** и **констант**, предназначенных для покрытия наиболее распространённых числовых операций, необходимых в небольших утилитах и инструментах. Он предоставляет:

* Часто используемые константы, такие как π, e, τ и √2.
* Генерацию случайных чисel (целые, с плавающей точкой, булевы значения и элементы списков).
* Вспомогательные функции для целых и чисел с плавающей точкой (модуль, ограничение, min/max и т. п.).
* Функции округления и усечения.
* Экспоненциальные, логарифмические и степенные функции.
* Тригонометрические и гиперболические функции (используют **радианы**).
* Утилиты для интерполяции, преобразования углов и классификации значений с плавающей точкой.
* Простые вспомогательные функции для арифметики 64-битных целых.

Все члены:

* **Статические** – объект `Math` создавать не нужно. Вы просто вызываете `Math::FunctionName(...)`.
* **Без состояния** – за исключением внутреннего состояния генератора случайных чисел, устойчивого состояния или конфигурации нет.
* **Без исключений** – как и остальная часть attoboy, функции объявлены `noexcept` и не бросают исключений.

### Числа с плавающей точкой, бесконечность и NaN

Многие функции в `Math` работают с типом `float`. `float` — это 32-битное число с плавающей точкой по стандарту IEEE-754. У этого представления есть несколько важных свойств:

* **Округление** – большинство вещественных чисел нельзя представить точно, поэтому результаты являются приближенными.
* **Бесконечность** – некоторые операции (например, переполнение или деление на ноль) дают положительную или отрицательную бесконечность.
* **NaN (Not-a-Number)** – неверные операции (например, `0.0f / 0.0f`) дают специальное значение NaN.

Класс `Math` предоставляет константы и вспомогательные функции для работы с этими значениями:

* `Math::INF` и `Math::NEG_INF` представляют положительную и отрицательную бесконечность.
* `Math::NAN` представляет значение NaN.
* `Math::IsFinite(x)` сообщает, является ли `x` конечным значением (не бесконечностью и не NaN).
* `Math::IsNaN(x)` сообщает, является ли `x` NaN.

Понимание этих концепций важно при написании числового кода, который должен надежно обрабатывать крайние случаи.

### Углы в радианах против градусов

Тригонометрические функции, такие как `Sin`, `Cos` и `Tan`, ожидают **углы в радианах**, а не в градусах. Радианы — это другой способ измерения углов:

* Полный круг — это `2π` радиан (`Math::TAU`).
* 90 градусов — это `π/2` радиан.
* 180 градусов — это `π` радиан.

Класс `Math` предоставляет:

* `Math::DegToRad(degrees)` — преобразовать градусы в радианы.
* `Math::RadToDeg(radians)` — преобразовать радианы в градусы.

Используйте эти помощники, когда ваш код работает с углами, выраженными в градусах (например, ввод пользователя), а математические функции ожидают радианы.

---

## Справочник

Все члены `Math` являются статическими и обращаются как `Math::Name(...)` или `Math::CONSTANT`. Ниже сгруппированы связанные члены для наглядности.

> **Примечание:** Все примеры предполагают `using namespace attoboy;`.

---

#### `Math::PI`

**Сигнатура**

```cpp
static constexpr float PI = 3.14159265358979323846f;
```

**Кратко**
Пи (π ≈ 3.14159).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(константа; неприменимо)*

**Подробности**

`Math::PI` представляет математическую константу π, отношение длины окружности к её диаметру. Она используется практически в любых тригонометрических или круговых вычислениях.

Поскольку она объявлена как `constexpr`, её можно использовать в вычислениях на этапе компиляции.

**Пример**

```cpp
float radius = 2.0f;
float circumference = 2.0f * Math::PI * radius;  // ≈ 12.56637
```

*Этот пример вычисляет окружность круга по его радиусу с использованием π.*

---

#### `Math::E`

**Сигнатура**

```cpp
static constexpr float E = 2.71828182845904523536f;
```

**Кратко**
Число Эйлера (e ≈ 2.71828).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(константа; неприменимо)*

**Подробности**

`Math::E` — число Эйлера, основание натурального логарифма. Оно встречается в уравнениях экспоненциального роста/затухания, теории вероятностей и во многих других областях математики.

**Пример**

```cpp
float x = 1.0f;
float expApprox = Math::Pow(Math::E, x);  // ≈ e^1 = 2.71828
```

*В этом примере используется `Math::E` с `Math::Pow` для приближенного вычисления e¹.*

---

#### `Math::TAU`

**Сигнатура**

```cpp
static constexpr float TAU = 6.28318530717958647693f;
```

**Кратко**
Тау (τ = 2π ≈ 6.28318).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(константа; неприменимо)*

**Подробности**

`Math::TAU` определён как `2 * π`. Некоторые формулы проще выражаются через τ вместо π, особенно при работе с полными поворотами.

**Пример**

```cpp
float rotations = 0.25f;  // quarter-turn
float angle = rotations * Math::TAU;  // radians
```

*Этот пример преобразует долю полного оборота в радианы с использованием τ.*

---

#### `Math::SQRT_2`

**Сигнатура**

```cpp
static constexpr float SQRT_2 = 1.41421356237309504880f;
```

**Кратко**
Квадратный корень из 2 (√2 ≈ 1.41421).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(константа; неприменимо)*

**Подробности**

`Math::SQRT_2` — квадратный корень из 2, длина диагонали единичного квадрата. Полезна в геометрии и вычислениях нормализации.

**Пример**

```cpp
float diagonal = Math::SQRT_2;  // diagonal length of a 1x1 square
```

*Этот пример использует √2 для простого геометрического вычисления.*

---

#### `Math::INF`

**Сигнатура**

```cpp
static const float INF;
```

**Кратко**
Положительная бесконечность.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(константа; неприменимо)*

**Подробности**

`Math::INF` представляет положительную бесконечность. Её можно использовать как сигнальную величину или инициализировать ею «очень большое» значение при поиске минимума.

Учтите, что арифметика с бесконечностью следует правилам плавающей точки:

* `INF + 1` остаётся `INF`.
* Сравнения, такие как `x < Math::INF`, работают как ожидается для конечных `x`.

**Пример**

```cpp
float best = Math::INF;
// ... update best with smaller values over time
```

*В этом примере инициализируется «лучший» счёт положительной бесконечностью, чтобы любое реальное значение было меньше.*

---

#### `Math::NEG_INF`

**Сигнатура**

```cpp
static const float NEG_INF;
```

**Кратко**
Отрицательная бесконечность.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(константа; неприменимо)*

**Подробности**

`Math::NEG_INF` — отрицательный аналог `Math::INF`. Полезна при поиске максимумов или при представлении слишком малого значения.

**Пример**

```cpp
float best = Math::NEG_INF;
// ... update best with larger values over time
```

*В этом примере инициализируется трекер максимума отрицательной бесконечностью.*

---

#### `Math::NAN`

**Сигнатура**

```cpp
static const float NAN;
```

**Кратко**
Не-число (NaN).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* *(константа; неприменимо)*

**Подробности**

`Math::NAN` представляет значение NaN (Not-a-Number). NaN используется для представления неопределённых или невычисляемых результатов (например, `0.0f / 0.0f`).

Важно знать следующее поведение:

* NaN **не равно** ничему, включая само себя. Сравнения вроде `x == Math::NAN` всегда ложны.
* Используйте `Math::IsNaN(x)` для проверки NaN.

**Пример**

```cpp
float value = Math::NAN;
// later:
if (Math::IsNaN(value)) {
  // handle invalid result
}
```

*В этом примере NaN используется как сигнатура «недопустимого значения» и определяется с помощью `IsNaN`.*

---

#### `static int Random() noexcept`

**Сигнатура**

```cpp
static int Random() noexcept;
```

**Кратко**
Возвращает случайное целое.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Псевдослучайное целое. Точный диапазон зависит от реализации, но обычно охватывает полный диапазон `int`.

**Подробности**

`Random()` предоставляет недетерминированное целое, подходящее для общего использования, когда не требуется конкретный диапазон. Если нужен ограниченный диапазон, предпочтительнее `RandomRange`.

Поскольку функция объявлена `noexcept` и использует внутреннее состояние, её безопасно и удобно вызывать всякий раз, когда нужен быстрый случайный результат.

**Пример**

```cpp
int raw = Math::Random();
// raw can be used as a seed or combined with modulo for ad hoc ranges
```

*В этом примере получается неограниченное случайное целое.*

---

#### `static float RandomFloat() noexcept`

**Сигнатура**

```cpp
static float RandomFloat() noexcept;
```

**Кратко**
Возвращает случайный float в [0.0, 1.0).

**Параметры**

* *(нет)*

**Возвращаемое значение**

* Псевдослучайный `float` в полуоткрытом интервале `[0.0f, 1.0f)`.

**Подробности**

`RandomFloat()` идеально подходит для проверок вероятности, интерполяции или простого шума:

* Включает `0.0f`.
* Исключает `1.0f`.

Вы можете масштабировать и смещать результат в другие интервалы:

```cpp
float value = Math::RandomFloat();          // [0, 1)
float scaled = 10.0f * value;               // [0, 10)
float shifted = 5.0f + 10.0f * value;       // [5, 15)
```

**Пример**

```cpp
float chance = Math::RandomFloat();
bool success = chance < 0.25f;  // 25% chance
```

*В этом примере случайный float используется для симуляции простой проверки по вероятности.*

---

#### `static int RandomRange(int start, int end) noexcept`

**Сигнатура**

```cpp
static int RandomRange(int start, int end) noexcept;
```

**Кратко**
Возвращает случайное целое в [start, end).

**Параметры**

* `start` – включительная нижняя граница диапазона.
* `end` – исключительная верхняя граница диапазона (должна быть больше `start`).

**Возвращаемое значение**

* Случайное целое `n` такое, что `start <= n < end`.

**Подробности**

`RandomRange()` — основной способ получения ограниченных случайных целых. Функция возвращает равномерно распределённые целые в полуоткрытом интервале `[start, end)`.

За корректность аргументов (например, `end > start`) отвечает вызывающий. Передача неверных границ (например, `end <= start`) может привести к неопределённому или зависящему от реализации поведению.

**Пример**

```cpp
int roll = Math::RandomRange(1, 7);  // 1..6 inclusive, like a die
```

*В этом примере моделируется бросок шестигранного кубика.*

---

#### `static bool RandomBool() noexcept`

**Сигнатура**

```cpp
static bool RandomBool() noexcept;
```

**Кратко**
Возвращает случайное булево значение.

**Параметры**

* *(нет)*

**Возвращаемое значение**

* `true` или `false`, примерно с равной вероятностью 50% каждая.

**Подробности**

`RandomBool()` — удобная оболочка вокруг генератора случайных чисел для решений типа «подбрасывание монетки». Эквивалентно `Math::RandomFloat() < 0.5f`, но может быть более эффективной.

**Пример**

```cpp
bool heads = Math::RandomBool();
```

*В этом примере моделируется честное подбрасывание монетки.*

---

#### `template <typename T> static T RandomChoice(const List &list) noexcept`

**Сигнатура**

```cpp
template <typename T> static T RandomChoice(const List &list) noexcept;
```

**Кратко**
Возвращает случайный элемент из списка.

**Параметры**

* `list` – `List` значений, из которых выбирают. Для осмысленного результата список не должен быть пустым.

**Возвращаемое значение**

* Случайный элемент типа `T` из `list`, или `T()` если список пуст.

**Подробности**

`RandomChoice<T>()` выбирает равномерный случайный индекс в диапазоне `[0, list.length())` и возвращает элемент по этому индексу, приводя его к `T` с помощью `list.at<T>(index)`.

Если список пуст, функция возвращает значение, созданное по умолчанию для `T`. Во многих случаях это будет `0` для числовых типов или пустая `String`.

Вы отвечаете за то, чтобы вызывать эту функцию с списком, элементы которого можно привести к `T`.

**Пример**

```cpp
List options;
options.append("red").append("green").append("blue");

String color = Math::RandomChoice<String>(options);
// color is one of "red", "green", or "blue"
```

*В этом примере выбирается случайный цвет из списка строк.*

---

#### `static int Abs(int x) noexcept`

**Сигнатура**

```cpp
static int Abs(int x) noexcept;
```

**Кратко**
Возвращает абсолютное значение x.

**Параметры**

* `x` – целое число, абсолютное значение которого требуется получить.

**Возвращаемое значение**

* Ненегативное целое, равное `|x|`.

**Подробности**

`Abs(int)` убирает знак у целого, возвращая ненегативное значение. Для большинства входов `Abs(-n)` эквивалентно `-n`. Поведение на минимальном представимом целочисленном значении (например, INT_MIN) может быть определено реализацией из-за переполнения, поэтому избегайте вызова `Abs()` с таким значением.

**Пример**

```cpp
int delta = -5;
int distance = Math::Abs(delta);  // 5
```

*В этом примере преобразуется знаковая разность в ненегативное расстояние.*

---

#### `static float Abs(float x) noexcept`

**Сигнатура**

```cpp
static float Abs(float x) noexcept;
```

**Кратко**
Возвращает абсолютное значение x.

**Параметры**

* `x` – число с плавающей точкой.

**Возвращаемое значение**

* `|x|` как `float`. Для NaN результат обычно NaN.

**Подробности**

`Abs(float)` удаляет бит знака числа с плавающей точкой, давая ненегативное значение. Ведёт себя ожидаемо для конечных значений и бесконечностей.

**Пример**

```cpp
float error = -0.25f;
float magnitude = Math::Abs(error);  // 0.25f
```

*В этом примере измеряется величина знакового отклонения.*

---

#### `static int Min(int a, int b) noexcept`

**Сигнатура**

```cpp
static int Min(int a, int b) noexcept;
```

**Кратко**
Возвращает меньший из a и b.

**Параметры**

* `a` – первое целое.
* `b` – второе целое.

**Возвращаемое значение**

* Меньшее из `a` и `b`. Если равны, возвращается любое из них.

**Подробности**

`Min(int, int)` — простой помощник для выбора меньшего из двух целых.

**Пример**

```cpp
int width = Math::Min(80, 120);  // 80
```

*В этом примере выбирается меньшая из двух границ.*

---

#### `static float Min(float a, float b) noexcept`

**Сигнатура**

```cpp
static float Min(float a, float b) noexcept;
```

**Кратко**
Возвращает меньший из a и b.

**Параметры**

* `a` – первый float.
* `b` – второй float.

**Возвращаемое значение**

* Меньшее из `a` и `b`. Поведение с NaN зависит от реализации.

**Подробности**

Для обычных конечных значений `Min(float, float)` ведёт себя ожидаемо. Если один из аргументов — NaN, результат может быть определён реализацией; по возможности избегайте использования NaN в качестве входа.

**Пример**

```cpp
float alpha = Math::Min(1.0f, 0.5f);  // 0.5f
```

*В этом примере ограничивается значение прозрачности выбором меньшего из двух чисел.*

---

#### `static int Max(int a, int b) noexcept`

**Сигнатура**

```cpp
static int Max(int a, int b) noexcept;
```

**Кратко**
Возвращает больший из a и b.

**Параметры**

* `a` – первое целое.
* `b` – второе целое.

**Возвращаемое значение**

* Больший из `a` и `b`.

**Подробности**

`Max(int, int)` — противоположность `Min(int, int)`.

**Пример**

```cpp
int height = Math::Max(10, 20);  // 20
```

*В этом примере выбирается большее из двух целых.*

---

#### `static float Max(float a, float b) noexcept`

**Сигнатура**

```cpp
static float Max(float a, float b) noexcept;
```

**Кратко**
Возвращает больший из a и b.

**Параметры**

* `a` – первый float.
* `b` – второй float.

**Возвращаемое значение**

* Больший из `a` и `b`.

**Подробности**

`Max(float, float)` ведёт себя ожидаемо для конечных входов. При участии NaN результат определяется реализацией; избегайте смешивания NaN с корректными значениями, если вы не обрабатываете это явно.

**Пример**

```cpp
float limit = Math::Max(0.0f, -5.0f);  // 0.0f
```

*В этом примере гарантируется, что значение не меньше нуля, выбирая большее из двух чисел.*

---

#### `static int Clamp(int x, int minVal, int maxVal) noexcept`

**Сигнатура**

```cpp
static int Clamp(int x, int minVal, int maxVal) noexcept;
```

**Кратко**
Возвращает x, ограниченное в [minVal, maxVal].

**Параметры**

* `x` – входное целое.
* `minVal` – нижняя граница допустимого диапазона.
* `maxVal` – верхняя граница допустимого диапазона (должна быть ≥ `minVal`).

**Возвращаемое значение**

* `x`, если `minVal <= x <= maxVal`.
* `minVal`, если `x < minVal`.
* `maxVal`, если `x > maxVal`.

**Подробности**

Ограничение (clamping) полезно, когда нужно зафиксировать значение в замкнутом интервале.

Убедитесь, что `minVal <= maxVal`; в противном случае поведение определяется реализацией.

**Пример**

```cpp
int brightness = 150;
brightness = Math::Clamp(brightness, 0, 100);  // 100
```

*В этом примере целочисленное значение яркости ограничивается в диапазоне 0–100.*

---

#### `static float Clamp(float x, float minVal, float maxVal) noexcept`

**Сигнатура**

```cpp
static float Clamp(float x, float minVal, float maxVal) noexcept;
```

**Кратко**
Возвращает x, ограниченное в [minVal, maxVal].

**Параметры**

* `x` – входной float.
* `minVal` – нижняя граница.
* `maxVal` – верхняя граница.

**Возвращаемое значение**

* `x`, ограниченное в `[minVal, maxVal]`, аналогично версии для целых.

**Подробности**

Ограничение для чисел с плавающей точкой часто используется для нормированных значений (например, от 0.0 до 1.0) или для ограничения выходных данных в физически осмысленных пределах.

Как и в целочисленной версии, убедитесь, что `minVal <= maxVal`.

**Пример**

```cpp
float t = 1.5f;
t = Math::Clamp(t, 0.0f, 1.0f);  // 1.0f
```

*В этом примере параметр `t` ограничивается в нормализованном диапазоне.*

---

#### `static int Sign(int x) noexcept`

**Сигнатура**

```cpp
static int Sign(int x) noexcept;
```

**Кратко**
Возвращает -1, 0 или 1 в зависимости от знака x.

**Параметры**

* `x` – целочисленный вход.

**Возвращаемое значение**

* `-1`, если `x < 0`.
* `0`, если `x == 0`.
* `1`, если `x > 0`.

**Подробности**

`Sign(int)` — компактный способ отличить отрицательные, нулевые и положительные целые.

**Пример**

```cpp
int dx = -3;
int direction = Math::Sign(dx);  // -1
```

*В этом примере преобразуется знаковая разность в индикатор направления.*

---

#### `static float Sign(float x) noexcept`

**Сигнатура**

```cpp
static float Sign(float x) noexcept;
```

**Кратко**
Возвращает -1.0, 0.0 или 1.0 в зависимости от знака x.

**Параметры**

* `x` – входное значение с плавающей точкой.

**Возвращаемое значение**

* `-1.0f`, если `x < 0`.
* `0.0f`, если `x == 0`.
* `1.0f`, если `x > 0`.

**Подробности**

`Sign(float)` полезна в векторной математике и нормализации. Поведение при NaN определяется реализацией и по возможности не используйте NaN в качестве входа.

**Пример**

```cpp
float value = 2.5f;
float s = Math::Sign(value);  // 1.0f
```

*В этом примере определяется знак значения с плавающей точкой.*

---

#### `static bool IsEven(int x) noexcept`

**Сигнатура**

```cpp
static bool IsEven(int x) noexcept;
```

**Кратко**
Возвращает true, если x чётное.

**Параметры**

* `x` – целочисленный вход.

**Возвращаемое значение**

* `true`, если `x` делится на 2 без остатка; иначе `false`.

**Подробности**

`IsEven()` определяет, равен ли младший бит `x` нулю. Работает и для отрицательных чисел.

**Пример**

```cpp
int n = 4;
bool even = Math::IsEven(n);  // true
```

*В этом примере проверяется, является ли целое чётным.*

---

#### `static bool IsOdd(int x) noexcept`

**Сигнатура**

```cpp
static bool IsOdd(int x) noexcept;
```

**Кратко**
Возвращает true, если x нечётное.

**Параметры**

* `x` – целочисленный вход.

**Возвращаемое значение**

* `true`, если `x` не делится на 2; иначе `false`.

**Подробности**

`IsOdd()` по сути является отрицанием `IsEven()` для целых чисел.

**Пример**

```cpp
int n = 5;
bool odd = Math::IsOdd(n);  // true
```

*В этом примере проверяется, является ли целое нечётным.*

---

#### `static bool IsPowerOfTwo(int x) noexcept`

**Сигнатура**

```cpp
static bool IsPowerOfTwo(int x) noexcept;
```

**Кратко**
Возвращает true, если x степень двойки.

**Параметры**

* `x` – целочисленный вход (как правило, положительный).

**Возвращаемое значение**

* `true`, если `x` имеет вид `2^n` для некоторого неотрицательного целого `n`.
* `false` для нуля, отрицательных значений или чисел, не являющихся степенями двойки.

**Подробности**

Этот помощник полезен при работе с размерами буферов, выравниванием или другими низкоуровневыми величинами, которые должны быть степенями двойки.

**Пример**

```cpp
int size = 64;
bool ok = Math::IsPowerOfTwo(size);  // true
```

*В этом примере проверяется, является ли размер степенью двойки, что часто требуется для некоторых алгоритмов.*

---

#### `static float Floor(float x) noexcept`

**Сигнатура**

```cpp
static float Floor(float x) noexcept;
```

**Кратко**
Возвращает наибольшее целое ≤ x.

**Параметры**

* `x` – входное число с плавающей точкой.

**Возвращаемое значение**

* Наибольшее значение с плавающей точкой, которое является целым и не больше `x`.

**Подробности**

`Floor()` округляет в сторону **отрицательной бесконечности**:

* `Floor(2.8f)` → `2.0f`
* `Floor(-2.1f)` → `-3.0f`

**Пример**

```cpp
float x = 3.7f;
float r = Math::Floor(x);  // 3.0f
```

*В этом примере число с плавающей точкой округляется вниз до ближайшего целого.*

---

#### `static float Ceil(float x) noexcept`

**Сигнатура**

```cpp
static float Ceil(float x) noexcept;
```

**Кратко**
Возвращает наименьшее целое ≥ x.

**Параметры**

* `x` – входное число с плавающей точкой.

**Возвращаемое значение**

* Наименьшее значение с плавающей точкой, которое является целым и не меньше `x`.

**Подробности**

`Ceil()` округляет в сторону **положительной бесконечности**:

* `Ceil(2.1f)` → `3.0f`
* `Ceil(-2.9f)` → `-2.0f`

**Пример**

```cpp
float x = 3.1f;
float r = Math::Ceil(x);  // 4.0f
```

*В этом примере число с плавающей точкой округляется вверх до ближайшего целого.*

---

#### `static float Trunc(float x) noexcept`

**Сигнатура**

```cpp
static float Trunc(float x) noexcept;
```

**Кратко**
Возвращает x с удалённой дробной частью (в сторону нуля).

**Параметры**

* `x` – входное число с плавающей точкой.

**Возвращаемое значение**

* `x` с удалённой дробной частью, округлённое в сторону нуля.

**Подробности**

`Trunc()` ведёт себя как приведение к целочисленному типу с последующим приведением назад к `float`:

* `Trunc(2.8f)` → `2.0f`
* `Trunc(-2.8f)` → `-2.0f`

**Пример**

```cpp
float x = -3.9f;
float r = Math::Trunc(x);  // -3.0f
```

*В этом примере дробная часть отрицательного значения удаляется усечением в сторону нуля.*

---

#### `static float Round(float x) noexcept`

**Сигнатура**

```cpp
static float Round(float x) noexcept;
```

**Кратко**
Возвращает x, округлённое до ближайшего целого.

**Параметры**

* `x` – входное число с плавающей точкой.

**Возвращаемое значение**

* `x`, округлённое до ближайшего целого значения в виде `float`.

**Подробности**

`Round()` округляет до ближайшего целого. Поведение при .5 (например, `2.5f`) зависит от реализации; может использоваться округление от нуля или до ближайшего чётного числа.

**Пример**

```cpp
float x = 2.6f;
float r = Math::Round(x);  // 3.0f
```

*В этом примере значение округляется до ближайшего целого.*

---

#### `static float Exp2(float x) noexcept`

**Сигнатура**

```cpp
static float Exp2(float x) noexcept;
```

**Кратко**
Возвращает 2^x.

**Параметры**

* `x` – показатель степени.

**Возвращаемое значение**

* `2^x` как `float`.

**Подробности**

`Exp2()` удобна для степеней двойки, часто используется в бинарном масштабировании и обработке сигналов.

**Пример**

```cpp
float x = 3.0f;
float value = Math::Exp2(x);  // 8.0f
```

*В этом примере вычисляется 2³ с помощью `Exp2`.*

---

#### `static float Log2(float x) noexcept`

**Сигнатура**

```cpp
static float Log2(float x) noexcept;
```

**Кратко**
Возвращает log₂(x).

**Параметры**

* `x` – положительное число с плавающей точкой.

**Возвращаемое значение**

* Логарифм по основанию 2 от `x`. Для `x <= 0` результат может быть NaN или зависеть от реализации.

**Подробности**

`Log2()` полезна для вычисления количества бит, необходимых для представления значения, или преобразования между показателями степени и факторами масштаба.

**Пример**

```cpp
float x = 8.0f;
float bits = Math::Log2(x);  // 3.0f
```

*В этом примере вычисляется логарифм по основанию 2 от 8.*

---

#### `static float Ln(float x) noexcept`

**Сигнатура**

```cpp
static float Ln(float x) noexcept;
```

**Кратко**
Возвращает натуральный логарифм ln(x).

**Параметры**

* `x` – положительное число с плавающей точкой.

**Возвращаемое значение**

* `ln(x)` как `float`.

**Подробности**

`Ln()` даёт натуральный логарифм, обратную функцию к `Exp()` при основании `e`. Для `x <= 0` результат обычно NaN или отрицательная бесконечность, в зависимости от значения и реализации.

**Пример**

```cpp
float x = Math::E;
float value = Math::Ln(x);  // ≈ 1.0f
```

*В этом примере проверяется, что натуральный логарифм числа e примерно равен 1.*

---

#### `static float Log10(float x) noexcept`

**Сигнатура**

```cpp
static float Log10(float x) noexcept;
```

**Кратко**
Возвращает log₁₀(x).

**Параметры**

* `x` – положительное число с плавающей точкой.

**Возвращаемое значение**

* Десятичный логарифм `x`.

**Подробности**

`Log10()` часто используется для расчёта децибел, порядков величины и в научной нотации.

**Пример**

```cpp
float x = 1000.0f;
float value = Math::Log10(x);  // 3.0f
```

*В этом примере вычисляется десятичный логарифм от 1000.*

---

#### `static float Exp(float x) noexcept`

**Сигнатура**

```cpp
static float Exp(float x) noexcept;
```

**Кратко**
Возвращает e^x.

**Параметры**

* `x` – показатель степени.

**Возвращаемое значение**

* `e^x` как `float`.

**Подробности**

`Exp()` — экспоненциальная функция с основанием `Math::E`. Она является обратной для `Ln()`.

**Пример**

```cpp
float x = 1.0f;
float value = Math::Exp(x);  // ≈ 2.71828
```

*В этом примере вычисляется e¹.*

---

#### `static float Pow(float x, float y) noexcept`

**Сигнатура**

```cpp
static float Pow(float x, float y) noexcept;
```

**Кратко**
Возвращает x^y.

**Параметры**

* `x` – основание.
* `y` – показатель.

**Возвращаемое значение**

* `x`, возведённое в степень `y`.

**Подробности**

`Pow()` — общая степенная функция. Для специальных случаев (например, степени двойки или квадраты) более специализированные функции могут быть эффективнее, но `Pow()` наиболее гибкая.

Некоторые сочетания `x` и `y` могут дать NaN (например, отрицательное основание с нецелым показателем).

**Пример**

```cpp
float base = 2.0f;
float exp = 4.0f;
float value = Math::Pow(base, exp);  // 16.0f
```

*В этом примере 2 возводится в четвёртую степень.*

---

#### `static int Pow2(int x) noexcept`

**Сигнатура**

```cpp
static int Pow2(int x) noexcept;
```

**Кратко**
Возвращает 2^x (целая версия).

**Параметры**

* `x` – показатель (целое).

**Возвращаемое значение**

* Целое, равное `2^x`, если оно помещается в `int`.

**Подробности**

`Pow2(int)` обычно реализуется как битовый сдвиг, что делает её эффективной для целочисленных степеней двойки. Если `x` слишком велик, результат может переполнить; вы должны обеспечить, чтобы `x` находился в безопасном диапазоне.

**Пример**

```cpp
int bits = 5;
int value = Math::Pow2(bits);  // 32
```

*В этом примере вычисляется 2⁵ как целое число.*

---

#### `static float Sqrt(float x) noexcept`

**Сигнатура**

```cpp
static float Sqrt(float x) noexcept;
```

**Кратко**
Возвращает квадратный корень из x.

**Параметры**

* `x` – неотрицательный float.

**Возвращаемое значение**

* Квадратный корень `x`. Для отрицательных `x` результат обычно NaN.

**Подробности**

`Sqrt()` — стандартный квадратный корень. Для отрицательных входов результат не определён в действительных числах; ожидайте NaN в таких случаях.

**Пример**

```cpp
float area = 9.0f;
float side = Math::Sqrt(area);  // 3.0f
```

*В этом примере вычисляется длина стороны квадрата по его площади.*

---

#### `static float Sin(float x) noexcept`

**Сигнатура**

```cpp
static float Sin(float x) noexcept;
```

**Кратко**
Возвращает синус x (в радианах).

**Параметры**

* `x` – угол в радианах.

**Возвращаемое значение**

* Синус `x`.

**Подробности**

`Sin()` использует радианы, а не градусы. При необходимости преобразуйте градусы в радианы с помощью `DegToRad()`.

**Пример**

```cpp
float deg = 90.0f;
float rad = Math::DegToRad(deg);
float s = Math::Sin(rad);  // ≈ 1.0f
```

*В этом примере вычисляется синус 90 градусов путем преобразования в радианы.*

---

#### `static float Cos(float x) noexcept`

**Сигнатура**

```cpp
static float Cos(float x) noexcept;
```

**Кратко**
Возвращает косинус x (в радианах).

**Параметры**

* `x` – угол в радианах.

**Возвращаемое значение**

* Косинус `x`.

**Подробности**

`Cos()` — функция косинуса, также ожидает радианы. Используйте вместе с `Sin()` для базовой векторной и поворотной математики.

**Пример**

```cpp
float deg = 0.0f;
float rad = Math::DegToRad(deg);
float c = Math::Cos(rad);  // 1.0f
```

*В этом примере вычисляется косинус 0 градусов.*

---

#### `static float Tan(float x) noexcept`

**Сигнатура**

```cpp
static float Tan(float x) noexcept;
```

**Кратко**
Возвращает тангенс x (в радианах).

**Параметры**

* `x` – угол в радианах.

**Возвращаемое значение**

* Тангенс `x`. Может стремиться к бесконечности вблизи нечётных кратных π/2.

**Подробности**

`Tan()` следует использовать с осторожностью в точках, где тангенс не определён (`π/2`, `3π/2` и т. п.), так как результат может сильно возрастать и привести к переполнению или потере точности.

**Пример**

```cpp
float deg = 45.0f;
float rad = Math::DegToRad(deg);
float t = Math::Tan(rad);  // ≈ 1.0f
```

*В этом примере вычисляется тангенс 45 градусов.*

---

#### `static float Atan2(float y, float x) noexcept`

**Сигнатура**

```cpp
static float Atan2(float y, float x) noexcept;
```

**Кратко**
Возвращает арктангенс y/x (в радианах), с учётом знаков для квадранта.

**Параметры**

* `y` – компонент по Y.
* `x` – компонент по X.

**Возвращаемое значение**

* Угол в радианах между положительной осью X и точкой `(x, y)`, обычно в `(-π, π]`.

**Подробности**

`Atan2()` предпочтительнее `Atan()`, когда у вас есть и X, и Y компоненты, так как она корректно определяет квадрант результата. Широко используется для преобразования декартовой системы координат в полярную.

**Пример**

```cpp
float x = 0.0f;
float y = 1.0f;
float angle = Math::Atan2(y, x);  // ≈ π/2
```

*В этом примере вычисляется угол вектора, направленного строго вверх.*

---

#### `static float Atan(float x) noexcept`

**Сигнатура**

```cpp
static float Atan(float x) noexcept;
```

**Кратко**
Возвращает арктангенс x (в радианах).

**Параметры**

* `x` – входное значение.

**Возвращаемое значение**

* `atan(x)` в радианах, обычно в `(-π/2, π/2)`.

**Подробности**

`Atan()` возвращает угол, тангенс которого равен `x`. Если у вас есть отдельные X и Y компоненты, предпочтительнее использовать `Atan2()` для корректной обработки квадрантов.

**Пример**

```cpp
float slope = 1.0f;
float angle = Math::Atan(slope);  // ≈ π/4
```

*В этом примере наклон 1 преобразуется в угол в радианах.*

---

#### `static float Asin(float x) noexcept`

**Сигнатура**

```cpp
static float Asin(float x) noexcept;
```

**Кратко**
Возвращает арксинус x (в радианах).

**Параметры**

* `x` – входное значение в диапазоне [-1, 1].

**Возвращаемое значение**

* Угол в радианах, синус которого равен `x`. Для значений вне [-1, 1] результат обычно NaN.

**Подробности**

`Asin()` полезен для восстановления углов по значениям синуса, например, в геометрии треугольников.

**Пример**

```cpp
float v = 0.5f;
float angle = Math::Asin(v);  // ≈ 0.5236 (30 degrees)
```

*В этом примере вычисляется угол, синус которого равен 0.5.*

---

#### `static float Cosh(float x) noexcept`

**Сигнатура**

```cpp
static float Cosh(float x) noexcept;
```

**Кратко**
Возвращает гиперболический косинус x.

**Параметры**

* `x` – входное значение.

**Возвращаемое значение**

* Гиперболический косинус `x`.

**Подробности**

`Cosh()` — гиперболический аналог косинуса, определяемый через экспоненты. Используется реже, чем `Sin`, `Cos` или `Tan`, но полезна в некоторых продвинутых математических моделях.

**Пример**

```cpp
float x = 1.0f;
float value = Math::Cosh(x);
```

*В этом примере вычисляется гиперболический косинус от 1.*

---

#### `static float Mod(float x, float y) noexcept`

**Сигнатура**

```cpp
static float Mod(float x, float y) noexcept;
```

**Кратко**
Возвращает остаток от деления x / y для чисел с плавающей точкой.

**Параметры**

* `x` – делимое.
* `y` – делитель (не должен быть нулём).

**Возвращаемое значение**

* Остаток от `x / y` как `float`.

**Подробности**

`Mod()` ведёт себя аналогично выражению `x - y * floor(x / y)` или соответствующим функциям остатка для чисел с плавающей точкой. Если `y` равно нулю, результат неопределёнен; избегайте деления на ноль.

**Пример**

```cpp
float angle = Math::Mod(370.0f, 360.0f);  // 10.0f
```

*В этом примере угол сворачивается в диапазон 0–360 градусов с помощью остатка от деления.*

---

#### `static float Lerp(float a, float b, float t) noexcept`

**Сигнатура**

```cpp
static float Lerp(float a, float b, float t) noexcept;
```

**Кратко**
Возвращает линейную интерполяцию между a и b по параметру t.

**Параметры**

* `a` – начальное значение.
* `b` – конечное значение.
* `t` – параметр интерполяции, обычно в `[0.0f, 1.0f]`.

**Возвращаемое значение**

* `(1 - t) * a + t * b` как `float`.

**Подробности**

`Lerp()` широко используется в анимации и плавных переходах:

* `t = 0` → возвращает `a`.
* `t = 1` → возвращает `b`.
* `t` между 0 и 1 → смешивает `a` и `b`.

Значения `t` вне `[0, 1]` дают экстраполяцию за пределы концов отрезка.

**Пример**

```cpp
float start = 0.0f;
float end = 10.0f;
float halfway = Math::Lerp(start, end, 0.5f);  // 5.0f
```

*В этом примере вычисляется середина между двумя значениями.*

---

#### `static float Step(float edge, float x) noexcept`

**Сигнатура**

```cpp
static float Step(float edge, float x) noexcept;
```

**Кратко**
Возвращает 0, если x < edge, иначе 1.

**Параметры**

* `edge` – пороговое значение.
* `x` – входное значение.

**Возвращаемое значение**

* `0.0f`, если `x < edge`.
* `1.0f`, если `x >= edge`.

**Подробности**

`Step()` реализует простую ступенчатую функцию, часто используемую для пороговой обработки:

* Всё, что ниже `edge`, отображается в ноль.
* Всё, что равно или выше `edge`, отображается в единицу.

Полезна для быстрой логики переключения в численных вычислениях.

**Пример**

```cpp
float edge = 0.5f;
float x = 0.7f;
float result = Math::Step(edge, x);  // 1.0f
```

*В этом примере непрерывное значение преобразуется в бинарный выход на основе порога.*

---

#### `static float DegToRad(float degrees) noexcept`

**Сигнатура**

```cpp
static float DegToRad(float degrees) noexcept;
```

**Кратко**
Преобразует градусы в радианы.

**Параметры**

* `degrees` – угол в градусах.

**Возвращаемое значение**

* Эквивалентный угол в радианах.

**Подробности**

Используйте `DegToRad()`, когда получаете углы в градусах (например, от пользователя или файла), но требуется вызвать тригонометрические функции, которые ожидают радианы.

Преобразование: `degrees * (π / 180)`.

**Пример**

```cpp
float degrees = 180.0f;
float radians = Math::DegToRad(degrees);  // ≈ π
```

*В этом примере 180 градусов преобразуются в радианы.*

---

#### `static float RadToDeg(float radians) noexcept`

**Сигнатура**

```cpp
static float RadToDeg(float radians) noexcept;
```

**Кратко**
Преобразует радианы в градусы.

**Параметры**

* `radians` – угол в радианах.

**Возвращаемое значение**

* Эквивалентный угол в градусах.

**Подробности**

`RadToDeg()` является обратной функцией для `DegToRad()`, преобразуя радианы обратно в градусы, которые часто более удобочитаемы для отображения.

**Пример**

```cpp
float angle = Math::PI;
float degrees = Math::RadToDeg(angle);  // ≈ 180.0f
```

*В этом примере π радиан преобразуются в градусы.*

---

#### `static bool IsFinite(float x) noexcept`

**Сигнатура**

```cpp
static bool IsFinite(float x) noexcept;
```

**Кратко**
Возвращает true, если x конечен (не бесконечность и не NaN).

**Параметры**

* `x` – число с плавающей точкой.

**Возвращаемое значение**

* `true`, если `x` не является бесконечностью и не NaN; иначе `false`.

**Подробности**

`IsFinite()` важна при проверке результатов вычислений, которые могут переполниться или дать NaN. Она отличает обычные числа от специальных случаев.

**Пример**

```cpp
float value = Math::INF;
bool ok = Math::IsFinite(value);  // false
```

*В этом примере показано, что положительная бесконечность не считается конечной.*

---

#### `static bool IsNaN(float x) noexcept`

**Сигнатура**

```cpp
static bool IsNaN(float x) noexcept;
```

**Кратко**
Возвращает true, если x является NaN.

**Параметры**

* `x` – число с плавающей точкой.

**Возвращаемое значение**

* `true`, если `x` — значение NaN; иначе `false`.

**Подробности**

Используйте `IsNaN()` для проверки NaN, потому что сравнения вроде `x == Math::NAN` всегда ложны.

Применяйте её всегда, когда есть подозрение, что вычисление могло дать недопустимый результат.

**Пример**

```cpp
float value = Math::NAN;
bool bad = Math::IsNaN(value);  // true
```

*В этом примере обнаруживается значение NaN с помощью `IsNaN`.*

---

#### `static long long Add64(long long a, long long b) noexcept`

**Сигнатура**

```cpp
static long long Add64(long long a, long long b) noexcept;
```

**Кратко**
Возвращает сумму a + b (64-битные целые).

**Параметры**

* `a` – первый операнд.
* `b` – второй операнд.

**Возвращаемое значение**

* `a + b` как 64-битное целое.

**Подробности**

`Add64()` складывает два 64-битных целых. Если результат выходит за пределы типа `long long`, поведение определяется реализацией, как и при нативном переполнении целых в C++.

**Пример**

```cpp
long long a = 1000000000LL;
long long b = 2000000000LL;
long long sum = Math::Add64(a, b);
```

*В этом примере складываются два больших 64-битных числа.*

---

#### `static long long Sub64(long long a, long long b) noexcept`

**Сигнатура**

```cpp
static long long Sub64(long long a, long long b) noexcept;
```

**Кратко**
Возвращает разность a - b (64-битные целые).

**Параметры**

* `a` – уменьшаемое.
* `b` – вычитаемое.

**Возвращаемое значение**

* `a - b` как 64-битное целое.

**Подробности**

`Sub64()` вычитает одно 64-битное целое из другого. Как и при сложении, переполнение определяется реализацией.

**Пример**

```cpp
long long total = 5000LL;
long long used = 1200LL;
long long remaining = Math::Sub64(total, used);  // 3800
```

*В этом примере вычисляется остаток, вычитая одно 64-битное значение из другого.*

---

#### `static long long Div64(long long a, long long b) noexcept`

**Сигнатура**

```cpp
static long long Div64(long long a, long long b) noexcept;
```

**Кратко**
Возвращает частное a / b (64-битные целые).

**Параметры**

* `a` – делимое.
* `b` – делитель (не должен быть нулём).

**Возвращаемое значение**

* Частное `a / b` как 64-битное целое, с целочисленным делением (дробная часть отбрасывается).

**Подробности**

`Div64()` делит два 64-битных целых. Деление на ноль не определено и должно быть избегнуто. Результат усечён в сторону нуля.

**Пример**

```cpp
long long bytes = 4096LL;
long long blockSize = 512LL;
long long blocks = Math::Div64(bytes, blockSize);  // 8
```

*В этом примере вычисляется, сколько целых блоков помещается в количестве байт.*

---

#### `static long long Mod64(long long a, long long b) noexcept`

**Сигнатура**

```cpp
static long long Mod64(long long a, long long b) noexcept;
```

**Кратко**
Возвращает остаток от деления a / b (64-битные целые).

**Параметры**

* `a` – делимое.
* `b` – делитель (не должен быть нулём).

**Возвращаемое значение**

* Остаток от целочисленного деления `a / b`.

**Подробности**

`Mod64()` дополняет `Div64()`, возвращая остаток. Как и в любом целочисленном модуле, деление на ноль не определено.

**Пример**

```cpp
long long bytes = 4100LL;
long long blockSize = 512LL;
long long remainder = Math::Mod64(bytes, blockSize);  // 4
```

*В этом примере вычисляется остаток байтов при делении на фиксированный размер блока.*